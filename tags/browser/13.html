<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/8c9c9c1497342ebd-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/90b9a6008fbaec66-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/aaa5adfbee94ea73-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/f7f7943a91e71716-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/49964d369cf2e029.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/ce6a7f582a819c93.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/5a76cc91da7d955b.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/b156f85051d44ed2.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-d087066ce42baf9f.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-0e492acdb34e0e7d.js" async="" crossorigin=""></script><script src="/_next/static/chunks/938-073485517c55f951.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-d3c7d898fafbc3cf.js" async="" crossorigin=""></script><script src="/_next/static/chunks/250-8b90be581650ff9d.js" async=""></script><script src="/_next/static/chunks/35-a0ff3f64741c4cff.js" async=""></script><script src="/_next/static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-f6cdfa3ec1fc64aa.js" async=""></script><script src="/_next/static/chunks/304-f6bea3ededee4fbe.js" async=""></script><script src="/_next/static/chunks/730-7ade87634bab4187.js" async=""></script><script src="/_next/static/chunks/566-b141861ca793acbd.js" async=""></script><script src="/_next/static/chunks/406-510aa82f57e1650d.js" async=""></script><script src="/_next/static/chunks/553-fac5a7c0d4eb7378.js" async=""></script><script src="/_next/static/chunks/app/(layoutCase)/layout-fb5aa513e9ce1000.js" async=""></script><title>Create Next App</title><meta name="description" content="Generated by create next app"/><meta name="next-size-adjust"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" as="style"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><aside id="sidebar" class="layout_sidebar__e3ohZ"><header class="layout_profile_wrapper__f1nCL"><a href="/posts"><img alt="프로필 사진" loading="lazy" width="112" height="112" decoding="async" data-nimg="1" class="layout_img__9R9xU" style="color:transparent" srcSet="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fprofile1.67069bdd.jpg&amp;w=128&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fprofile1.67069bdd.jpg&amp;w=256&amp;q=75 2x" src="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fprofile1.67069bdd.jpg&amp;w=256&amp;q=75"/></a><h1 class="layout_blog_name_txt__rwN5K">my blog</h1><p class="layout_site_subtitle__eWLo_">You can only earn as much as an ant does by working like an ant.</p></header><nav><ul class="layout_nav__Cq50F"><li class="layout_nav_item__V5eSj"><a class="layout_nav_link__Tk4UB" href="/posts"><i class="fa-fw fas fa-home layout_ico__lcTLT"></i><span class="layout_nav_txt__KL2gD">HOME</span></a></li><li class="layout_nav_item__V5eSj"><a class="layout_nav_link__Tk4UB" href="/categories"><i class="fa-fw fas fa-stream layout_ico__lcTLT"></i><span class="layout_nav_txt__KL2gD">CATEGORIES</span></a></li><li class="layout_nav_item__V5eSj layout_active__viTit"><a class="layout_nav_link__Tk4UB" href="/tags"><i class="fa-fw fas fa-tags layout_ico__lcTLT"></i><span class="layout_nav_txt__KL2gD">TAGS</span></a></li><li class="layout_nav_item__V5eSj"><a class="layout_nav_link__Tk4UB" href="/archives"><i class="fa-fw fas fa-archive layout_ico__lcTLT"></i><span class="layout_nav_txt__KL2gD">ARCHIVES</span></a></li><li class="layout_nav_item__V5eSj"><a class="layout_nav_link__Tk4UB" href="/algorithm"><i class="fa-solid fa-mug-saucer layout_ico__lcTLT"></i><span class="layout_nav_txt__KL2gD">CODING</span></a></li></ul></nav><div class="sidebar-bottom"></div></aside><div class="layout_main_wrapper__1M1Uy"><div class="layout_container__d8eWg"><header class="breadCrumb_topbar_wrapper__dGN_V"><div class="breadCrumb_top_bar__b_rV9"><nav class="breadCrumb_breadcrumb__l7WLX"><span><a class="breadCrumb_topbar_txt__ExrWf" href="/">Home</a><a class="breadCrumb_topbar_txt__ExrWf" href="">JWT와 토큰 관리 방법</a></span></nav><search class="searchBar_search__Ftlhc"><i class="fas fa-search fa-fw searchBar_search_ico__STStc"></i><input id="search" class="searchBar_search_input__1XpQF" placeholder="Search..." autoComplete="off"/></search></div><div class="breadCrumb_mobile_topbar__N1Azi"><button class="breadCrumb_sidebar_trigger__APgD8"><i class="fas fa-bars fa-fw breadCrumb_sidebar_trigger_ico__K9DdV"></i></button><div class="breadCrumb_mobile_topbar_title__oCVBS">Carys</div><button class="breadCrumb_search_trigger__PxWyf"><i class="fas fa-search fa-fw breadCrumb_search_trigger_ico__yqqpz"></i></button></div></header><div class="layout_contents__3qIEg"><main class="layout_inner_content__B1flj"><article><header><h1 class="postDetail_h1__36D1I">JWT와 토큰 관리 방법</h1></header></article><div class="postDetail_post_meta__zCdVW"><span>Posted<time class="postDetail_time__99zYg"> Aug 8, 2019</time></span><span class="postDetail_update__21dkl">Updated<time class="postDetail_time__99zYg"> Sep 23, 2023</time></span></div><div><span class="postDetail_post_meta__zCdVW">By<!-- --> <em><a class="postDetail_author__jc_NJ" href="https://github.com/nam-yeun-hwa">Carys Chung</a></em></span></div><div class="postDetail_content__OTeO2">JWT(JSON Web Token)는 JSON 객체를 사용하여 모바일이나 웹의 사용자 인증을 위해 사용하며 정보를 안전성 있게 암호화한 토큰을 의미한다.</div><h4 class="postDetail_h4__Af1O8">📝 <!-- -->Access Token</h4><div class="postDetail_content__OTeO2">액세스 토큰은 주로 인증된 사용자가 보호된 리소스에 접근할 수 있는 권한을 부여하는 데 사용되는 문자열입니다. 주로 웹 애플리케이션, 모바일 앱 등에서 사용자 인증 및 권한 부여에 쓰입니다. 여러 인증 프로토콜에서 사용되며, 대표적으로 OAuth 2.0에서 정의되어 있으며</br></br>기본적으로 Access Token은 다음과 같은 특징을 가지고 있다.</div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4"><b>유효 기간(Expiration)</b> : Access Token은 일정 기간 동안만 유효하다. 일반적으로 짧은 시간(예: 2시간) 동안만 유효하며, 이 기간이 지나면 재발급이나 새로운 인증이 필요하다.</li><li class="liststyle_dot__SMzS4">        <b>권한 범위(범위)</b> : Access Token에는 사용자가 수행할 수 있는 특정 작업 또는 리소스에 대한 권한 범위가 지정된다. Scope는 해당 토큰으로 어떤 작업이 가능한지를 결정하는 데 사용된다.</li><li class="liststyle_dot__SMzS4">        <b>발급자(Issuer)</b> : 토큰을 발급한 인증 서버(발급자)의 정보가 토큰에 포함될 수 있다. 클라이언트는 이 정보를 사용하여 토큰의 신뢰성을 확인할 수 있다.</li><li class="liststyle_dot__SMzS4">        <b>서명(Signature)</b> : 보안을 강화하기 위해 토큰은 발급자에 의해 서명된다. 서명을 통해 토큰이 유효하며 조작되지 않았음을 검증할 수 있다.</li><li class="liststyle_dot__SMzS4">        <b>사용자 식별 정보</b> : Access Token에는 사용자를 고유하게 식별할 수 있는 정보(사용자 ID 등)가 포함될 수 있다. 이를 통해 서버는 특정 사용자에 대한 작업을 수행할 수 있다.</li></ul><h4 class="postDetail_h4__Af1O8">📝 <!-- -->Refresh token</h4><div class="postDetail_content__OTeO2">access 토큰이 만료가 됐을 경우 access 토큰을 재발급 받을 수 있도록 서버에 요청할 수 있다. fresh token은 access token을 재발급받을 수 있는 token이다. 이 token은 서버에 저장되기 때문에(stateful) refresh token이 해커에 의해 탈취당했다고 판단되었을 때 서버에서 refresh token을 삭제함으로써 강제 로그아웃을 시킬 수 있다.</br></br>

        이런 특징을 이용해서 access token + refresh token의 조합을 구성하면 access token의 경제적인 장점과 refresh token의 보안적인 장점을 둘 다 챙길 수 있다. access token은 보안 적으로 취약하니 2시간 정도로 짧게 가져가고, refresh token은 처리 비용이 많이 들기 때문에 2주 정도로 길게 가져가는 방식을 주로 사용한다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">client.interceptors.request.use(
    function (config) {
        const user = localStorage.getItem('user');
        if (!user) {
            config.headers["accessToken"] = null;
            config.headers["refreshToken"] = null;
            return config
        }
        const { accessToken, refreshToken } = JSON.parse(user)
        config.headers["accessToken"] = accessToken;
        config.headers["refreshToken"] = refreshToken;
        return config
    }
)</pre></div></div><div class="postDetail_content__OTeO2">reqeust를 보낼때 localStorage에 token 정보가 있다면 헤더에 토큰 정보를 저장하고 없다면 null로 처리를 한다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">client.interceptors.response.use(
    function (response) {
        return response
    },
    async function (error) {
      if (error.response && error.response.status === 403) {
          try {
              const originalRequest = error.config;
              const data = await client.get('auth/refreshtoken')
              if (data) {
                  const {accessToken, refreshToken} = data.data
                  localStorage.removeItem('user')
                  localStorage.setItem('user', JSON.stringify(data.data, ['accessToken', 'refreshToken']))
                  originalRequest.headers['accessToken'] = accessToken;
                  originalRequest.headers['refreshToken'] = refreshToken;
                  return await client.request(originalRequest);
                  }
          } catch (error){
              localStorage.removeItem('user');
              console.log(error);
          }
          return Promise.reject(error)
      }
      return Promise.reject(error)
    }
)</pre></div></div><div class="postDetail_content__OTeO2">response를 받았을 때, error가 발생했고 해당 error의 status가 403이라면 기존의 originalRequest를 auth/refreshtoken 으로 전달해 토큰을 재발급 받도록 한다.</br></br>
        여기서 403 이외의 오류가 들어온다면 토큰 재발급에 실패한것으로 처리를 한다.</br></br>
        재발급 받은 토큰을 다시 로컬스토리지에 저장 하고 헤더 부분에 토큰 정보를 변경하고 다시 originalRequest를 보낸다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">import axios from 'axios';

const client = axios.create({
    baseURL: 'http://localhost:4000/'
})

client.interceptors.request.use(
    function (config) {
        const user = localStorage.getItem('user');
        if (!user) {
            config.headers["accessToken"] = null;
            config.headers["refreshToken"] = null;
            return config
        }
        const { accessToken, refreshToken } = JSON.parse(user)
        config.headers["accessToken"] = accessToken;
        config.headers["refreshToken"] = refreshToken;
        return config
    }
)

client.interceptors.response.use(
    function (response) {
        return response
    },
    async function (error) {
      if (error.response && error.response.status === 403) {
          try {
              const originalRequest = error.config;
              const data = await client.get('auth/refreshtoken')
              if (data) {
                  const {accessToken, refreshToken} = data.data
                  localStorage.removeItem('user')
                  localStorage.setItem('user', JSON.stringify(data.data, ['accessToken', 'refreshToken']))
                  originalRequest.headers['accessToken'] = accessToken;
                  originalRequest.headers['refreshToken'] = refreshToken;
                  return await client.request(originalRequest);
                  }
          } catch (error){
              localStorage.removeItem('user');
              console.log(error);
          }
          return Promise.reject(error)
      }
      return Promise.reject(error)
    }
)

export default client;</pre></div></div><h2 class="postDetail_h2__ZGkVK">보안</h2><h2 class="postDetail_h2__ZGkVK">CSRF(Cross Site Request Forgery)</h2><div class="postDetail_content__OTeO2">CSRF는 Cross-Site Request Forgery의 약자로, 한 사이트에서 인증된 사용자의 권한을 가로채어 다른 사이트에서 공격자가 의도한 동작을 수행하게 하는 공격이다. 이 공격은 사용자가 자신의 의지와 무관하게 공격자가 의도한 요청을 악의적인 웹사이트를 통해 전송함으로써 이루어진다.</div><h4 class="postDetail_h4__Af1O8">📝 <!-- -->CSRF 작동 원리</h4><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">사용자가 특정 웹사이트에 로그인하여 인증을 받는다.</li><li class="liststyle_dot__SMzS4">          이 사용자가 다른 웹사이트(공격자의 사이트)를 방문한다.</li><li class="liststyle_dot__SMzS4">         공격자의 사이트에서는 사용자의 권한으로 특정 동작(예: 글쓰기, 계정 변경 등)을 요청하는 HTTP 요청을 생성한다.</li><li class="liststyle_dot__SMzS4">         이를 트리거하기 위해 공격자는 이미 로그인된 사용자의 브라우저에서 악의적인 요청을 보낼 수 있는 방법을 찾는다.</li></ul><h4 class="postDetail_h4__Af1O8">📝 <!-- -->예시 시나리오</h4><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">사용자 A가 은행 웹사이트에 로그인한다.</li><li class="liststyle_dot__SMzS4">        사용자 A가 악의적인 이메일 링크를 클릭하여 공격자의 웹사이트에 접속한다.</li><li class="liststyle_dot__SMzS4">        해당 웹사이트에서는 사용자 A의 권한으로 은행 웹사이트에 자동으로 자금 이체를 요청하는 HTTP 요청을 생성한다.</li><li class="liststyle_dot__SMzS4">        이를 통해 은행 웹사이트는 사용자 A의 권한으로 이체를 실행하게 된다.</li></ul><h2 class="postDetail_h2__ZGkVK">XSS(Cross Site Scripting)</h2><div class="postDetail_content__OTeO2">XSS라고 불리는 이유는 CSS가 이미 약자가 있기 때문이고 code injection attack이라고도 한다.

        XSS도 다양한 공격 방법이 있는데 우선은
        <b>공격자가 의도하는 악의적인 js 코드를 피해자의 웹 브라우저에서 실행</b>시키는 것 정도로 알고 있으면 된다.
        
        이 방법으로 피해자 브라우저에 저장된 중요 정보들을 탈취 가능하다.</div><blockquote class="Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_warning__ZYPQt"><p class="Prompts_detail__nD6Io">아무리 다른 공격(CSRF 등)에 대한 방비를 열심히 했다 해도 XSS가 뚫린다면 아무 소용이 없다. js코드로 의도하지 않은 request를 날린다던가 localStorage, 변수 값 등 모든 것이 탈취 가능하기 때문이다. XSS 공격 방지는 웹 보안의 뿌리이며 XSS 공격을 막는 것은 웹 보안을 위한 최소한의 조치이다.</p></blockquote><h2 class="postDetail_h2__ZGkVK">해결 1) localStorage에 저장하는 방법</h2><h4 class="postDetail_h4__Af1O8">📝 <!-- -->CSRF 공격에는 안전하다.</h4><div class="postDetail_content__OTeO2">그 이유는 자동으로 request에 담기는 쿠키와는 다르게 js 코드에 의해 헤더에 담기므로 XSS를 뚫지 않는 이상 공격자가 정상적인 사용자인 척 request를 보내기가 어렵다.</div><h4 class="postDetail_h4__Af1O8">📝 <!-- -->XSS에 취약하다.</h4><div class="postDetail_content__OTeO2">공격자가 localStorage에 접근하는 js 코드 한 줄만 주입하면 localStorage를 공격자가 내 집처럼 드나들 수 있다.</div><h2 class="postDetail_h2__ZGkVK">해결 2) cookie에 저장하는 방법</h2><h4 class="postDetail_h4__Af1O8">📝 <!-- -->XSS 공격으로부터 localStorage에 비해 안전하다.</h4><div class="postDetail_content__OTeO2">쿠키의 httpOnly 옵션을 사용하면 Js에서 쿠키에 접근 자체가 불가능하다.</br>
        그래서 XSS 공격으로 쿠키 정보를 탈취할 수 없다.(httpOnly 옵션은 서버에서 설정할 수 있음) 하지만 XSS 공격으로부터 완전히 안전한 것은 아니다.</div><div class="postDetail_content__OTeO2">httpOnly 옵션으로 쿠키의 내용을 볼 수 없다 해도 js로 request를 보낼 수 있으므로 자동으로 request에 실리는 쿠키의 특성 상 사용자의 컴퓨터에서 요청을 위조할 수 있기 때문이다.</br>
        공격자가 귀찮을 뿐이지 XSS가 뚫린다면 httpOnly cookie도 안전하진 않다.</div><h4 class="postDetail_h4__Af1O8">📝 <!-- -->CSRF 공격에 취약하다.</h4><div class="postDetail_content__OTeO2">자동으로 http request에 담아서 보내기 때문에 공격자가 request url만 안다면 사용자가 관련 link를 클릭하도록 유도하여 request를 위조하기 쉽다.</div><h2 class="postDetail_h2__ZGkVK">해결 3 : refresh token 사용하는 방법</h2><div class="postDetail_content__OTeO2">가장 좋은 방법으로는 refresh token을 사용하는 방법이 있다. CSRF 공격으로부터 안전한 환경을 유지하기 위해 쿠키에 SameSite 속성을 설정하고, 리프레시 토큰을 활용하여 요청의 유효성을 검증하는 방법이다. 백엔드 api 개발자와 소통이 가능하다면 refresh token을 httpOnly 쿠키로 설정하고
        url이 새로고침 될 때마다 refresh token을 request에 담아 새로운 accessToken을 발급 받는다. </br></br>
        
        발급 받은 accessToken은 js private variable에 저장한다.</br></br>
        
        이런 방식을 사용하는 경우, refresh token이 CSRF에 의해 사용된다 하더라도 공격자는 accessToken을 알 수 없다.</br></br>
        
        CSRF는 피해자의 컴퓨터를 제어할 수 있는 것이 아니기 때문이다. 요청을 위조하여 피해자가 의도하지 않은 서버 동작을 일으키는 공격방법이기 때문에 refresh token을 통해 받아온 response(accessToken)는 공격자가 확인할 수 없다.</br></br>
        
        따라서 쿠키를 사용하여 XSS를 막고 refresh token 방식을 이용하여 CSRF를 막을 수 있다.</div><div class="row"><nav class="postNavigation_post_navigation__Zbcpm"><a class="postNavigation_post_navgation_common__q8_Hl postNavigation_post_navigation_pre__SPHh_" aria-label="Older" href="/posts/12"><p class="postNavigation_post_navigation_text__3cjma">프로미스(Promise)의 세 가지 상태와 활용</p></a><a class="postNavigation_post_navgation_common__q8_Hl postNavigation_post_navigation_next__yVEzg postNavigation_post_not_cursor___7LQp" aria-label="Newer" href="/posts/14"><p class="postNavigation_post_navigation_text__3cjma">-</p></a></nav></div><div class="footer_footer_container__MsSvO"><footer class="footer_footer__AwYty"><p class="footer_copylight___J5l0">© 2024 bunny Chung. Some rights reserved.</p><p class="footer_theme__bwXbg">Using the theme ...</p></footer></div></main><aside class="panel_panel_wrapper__bjPKT"><div class="panel_access__NiFhF"><section class="panel_access_lastmod__v6pgX"><h2 class="panel_panel_heading__n9W6w">Recently Updated</h2><ul class="panel_panel_recently__U0_Zp"><li class="panel_text_truncate__SFfHf"><a href="/posts/1">리액트와 불변성</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/2">함수형 프로그래밍</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/3">프론트 서버</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/4">브라우저에서 이벤트가 발생하고 전파되는 방식</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/5">일반함수 VS 화살표 함수의 this 바인딩</a></li></ul></section><section class="panel_panel_tag_contain__h_Bwi"><h2 class="panel_panel_heading__n9W6w">Trending Tags</h2><div class="panel_panel_tag__eNz5c"><a class="panel_tag__3AiMO" href="/tags/React">React</a><a class="panel_tag__3AiMO" href="/tags/Javascript">Javascript</a><a class="panel_tag__3AiMO" href="/tags/browser">browser</a><a class="panel_tag__3AiMO" href="/tags/JWT">JWT</a><a class="panel_tag__3AiMO" href="/tags/Token">Token</a></div></section></div></aside></div></div></div><script src="/_next/static/chunks/webpack-d087066ce42baf9f.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/8c9c9c1497342ebd-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/media/90b9a6008fbaec66-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n3:HL[\"/_next/static/media/aaa5adfbee94ea73-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n4:HL[\"/_next/static/media/f7f7943a91e71716-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n5:HL[\"/_next/static/css/49964d369cf2e029.css\",\"style\",{\"crossOrigin\":\"\"}]\n6:HL[\"/_next/static/css/ce6a7f582a"])</script><script>self.__next_f.push([1,"819c93.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L7\"\n"])</script><script>self.__next_f.push([1,"8:HL[\"/_next/static/css/5a76cc91da7d955b.css\",\"style\",{\"crossOrigin\":\"\"}]\n9:HL[\"/_next/static/css/b156f85051d44ed2.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"a:I[7690,[],\"\"]\nc:I[5250,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"35\",\"static/chunks/35-a0ff3f64741c4cff.js\",\"216\",\"static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-f6cdfa3ec1fc64aa.js\"],\"\"]\ne:I[777,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"35\",\"static/chunks/35-a0ff3f64741c4cff.js\",\"216\",\"static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-f6cdfa3ec1fc64aa.js\"],\"\"]\nf:I[5613,[],\"\"]\n12:I[1778,[],\"\"]\n15:I[2971,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"304\""])</script><script>self.__next_f.push([1,",\"static/chunks/304-f6bea3ededee4fbe.js\",\"730\",\"static/chunks/730-7ade87634bab4187.js\",\"566\",\"static/chunks/566-b141861ca793acbd.js\",\"35\",\"static/chunks/35-a0ff3f64741c4cff.js\",\"406\",\"static/chunks/406-510aa82f57e1650d.js\",\"553\",\"static/chunks/553-fac5a7c0d4eb7378.js\",\"464\",\"static/chunks/app/(layoutCase)/layout-fb5aa513e9ce1000.js\"],\"\"]\n1c:I[8955,[],\"\"]\nd:T638,"])</script><script>self.__next_f.push([1,"import axios from 'axios';\n\nconst client = axios.create({\n    baseURL: 'http://localhost:4000/'\n})\n\nclient.interceptors.request.use(\n    function (config) {\n        const user = localStorage.getItem('user');\n        if (!user) {\n            config.headers[\"accessToken\"] = null;\n            config.headers[\"refreshToken\"] = null;\n            return config\n        }\n        const { accessToken, refreshToken } = JSON.parse(user)\n        config.headers[\"accessToken\"] = accessToken;\n        config.headers[\"refreshToken\"] = refreshToken;\n        return config\n    }\n)\n\nclient.interceptors.response.use(\n    function (response) {\n        return response\n    },\n    async function (error) {\n      if (error.response \u0026\u0026 error.response.status === 403) {\n          try {\n              const originalRequest = error.config;\n              const data = await client.get('auth/refreshtoken')\n              if (data) {\n                  const {accessToken, refreshToken} = data.data\n                  localStorage.removeItem('user')\n                  localStorage.setItem('user', JSON.stringify(data.data, ['accessToken', 'refreshToken']))\n                  originalRequest.headers['accessToken'] = accessToken;\n                  originalRequest.headers['refreshToken'] = refreshToken;\n                  return await client.request(originalRequest);\n                  }\n          } catch (error){\n              localStorage.removeItem('user');\n              console.log(error);\n          }\n          return Promise.reject(error)\n      }\n      return Promise.reject(error)\n    }\n)\n\nexport default client;"])</script><script>self.__next_f.push([1,"10:[\"tagname\",\"browser\",\"d\"]\n11:[\"postid\",\"13\",\"d\"]\n13:\"$L14\"\n16:[]\n17:{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"}\n18:{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"}\n19:{\"display\":\"inline-block\"}\n1a:{\"fontSize\":14,\"f"])</script><script>self.__next_f.push([1,"ontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0}\n"])</script><script>self.__next_f.push([1,"7:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/49964d369cf2e029.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ce6a7f582a819c93.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$La\",null,{\"buildId\":\"7ZgKHK68MdevaeTJA-XKH\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/tags/browser/13\",\"initialTree\":[\"\",{\"children\":[\"(layoutCase)\",{\"children\":[\"tags\",{\"children\":[[\"tagname\",\"browser\",\"d\"],{\"children\":[[\"postid\",\"13\",\"d\"],{\"children\":[\"__PAGE__?{\\\"tagname\\\":\\\"browser\\\",\\\"postid\\\":\\\"13\\\"}\",{}]}]}]}],\"modal\":[\"__DEFAULT__\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"(layoutCase)\",{\"children\":[\"tags\",{\"children\":[[\"tagname\",\"browser\",\"d\"],{\"children\":[[\"postid\",\"13\",\"d\"],{\"children\":[\"__PAGE__\",{},[\"$Lb\",[[\"$\",\"article\",null,{\"className\":\"$undefined\",\"children\":[\"$\",\"header\",null,{\"children\":[\"$\",\"h1\",null,{\"className\":\"postDetail_h1__36D1I\",\"children\":\"JWT와 토큰 관리 방법\"}]}]}],[\"$\",\"div\",null,{\"className\":\"postDetail_post_meta__zCdVW\",\"children\":[[\"$\",\"span\",null,{\"children\":[\"Posted\",[\"$\",\"time\",null,{\"className\":\"postDetail_time__99zYg\",\"children\":\" Aug 8, 2019\"}]]}],[\"$\",\"span\",null,{\"className\":\"postDetail_update__21dkl\",\"children\":[\"Updated\",[\"$\",\"time\",null,{\"className\":\"postDetail_time__99zYg\",\"children\":\" Sep 23, 2023\"}]]}]]}],[\"$\",\"div\",null,{\"children\":[\"$\",\"span\",null,{\"className\":\"postDetail_post_meta__zCdVW\",\"children\":[\"By\",\" \",[\"$\",\"em\",null,{\"children\":[\"$\",\"$Lc\",null,{\"href\":\"https://github.com/nam-yeun-hwa\",\"className\":\"postDetail_author__jc_NJ\",\"children\":\"Carys Chung\"}]}]]}]}],[[\"$\",\"div\",\"0\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"JWT(JSON Web Token)는 JSON 객체를 사용하여 모바일이나 웹의 사용자 인증을 위해 사용하며 정보를 안전성 있게 암호화한 토큰을 의미한다.\"}}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"postDetail_h4__Af1O8\",\"children\":[\"📝 \",\"Access Token\"]}]],[\"$\",\"div\",\"2\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"액세스 토큰은 주로 인증된 사용자가 보호된 리소스에 접근할 수 있는 권한을 부여하는 데 사용되는 문자열입니다. 주로 웹 애플리케이션, 모바일 앱 등에서 사용자 인증 및 권한 부여에 쓰입니다. 여러 인증 프로토콜에서 사용되며, 대표적으로 OAuth 2.0에서 정의되어 있으며\u003c/br\u003e\u003c/br\u003e기본적으로 Access Token은 다음과 같은 특징을 가지고 있다.\"}}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e유효 기간(Expiration)\u003c/b\u003e : Access Token은 일정 기간 동안만 유효하다. 일반적으로 짧은 시간(예: 2시간) 동안만 유효하며, 이 기간이 지나면 재발급이나 새로운 인증이 필요하다.\"}}],\"$undefined\",[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"        \u003cb\u003e권한 범위(범위)\u003c/b\u003e : Access Token에는 사용자가 수행할 수 있는 특정 작업 또는 리소스에 대한 권한 범위가 지정된다. Scope는 해당 토큰으로 어떤 작업이 가능한지를 결정하는 데 사용된다.\"}}],\"$undefined\",[\"$\",\"li\",\"4\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"        \u003cb\u003e발급자(Issuer)\u003c/b\u003e : 토큰을 발급한 인증 서버(발급자)의 정보가 토큰에 포함될 수 있다. 클라이언트는 이 정보를 사용하여 토큰의 신뢰성을 확인할 수 있다.\"}}],\"$undefined\",[\"$\",\"li\",\"6\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"        \u003cb\u003e서명(Signature)\u003c/b\u003e : 보안을 강화하기 위해 토큰은 발급자에 의해 서명된다. 서명을 통해 토큰이 유효하며 조작되지 않았음을 검증할 수 있다.\"}}],\"$undefined\",[\"$\",\"li\",\"8\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"        \u003cb\u003e사용자 식별 정보\u003c/b\u003e : Access Token에는 사용자를 고유하게 식별할 수 있는 정보(사용자 ID 등)가 포함될 수 있다. 이를 통해 서버는 특정 사용자에 대한 작업을 수행할 수 있다.\"}}]]}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"postDetail_h4__Af1O8\",\"children\":[\"📝 \",\"Refresh token\"]}]],[\"$\",\"div\",\"5\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"access 토큰이 만료가 됐을 경우 access 토큰을 재발급 받을 수 있도록 서버에 요청할 수 있다. fresh token은 access token을 재발급받을 수 있는 token이다. 이 token은 서버에 저장되기 때문에(stateful) refresh token이 해커에 의해 탈취당했다고 판단되었을 때 서버에서 refresh token을 삭제함으로써 강제 로그아웃을 시킬 수 있다.\u003c/br\u003e\u003c/br\u003e\\n\\n        이런 특징을 이용해서 access token + refresh token의 조합을 구성하면 access token의 경제적인 장점과 refresh token의 보안적인 장점을 둘 다 챙길 수 있다. access token은 보안 적으로 취약하니 2시간 정도로 짧게 가져가고, refresh token은 처리 비용이 많이 들기 때문에 2주 정도로 길게 가져가는 방식을 주로 사용한다.\"}}],[\"$\",\"div\",null,{\"className\":\"LanguageConsole_console_container__AqYGR\",\"children\":[[\"$\",\"div\",null,{\"className\":\"LanguageConsole_console_header__inJS4\",\"children\":[[\"$\",\"span\",null,{\"className\":\"LanguageConsole_title__QSrQq\",\"data-label-text\":\"Javascript\",\"children\":[\"$\",\"i\",null,{\"className\":\"fas fa-code fa-fw small LanguageConsole_ico_title__oetQW\"}]}],[\"$\",\"button\",null,{\"className\":\"LanguageConsole_copy__l7rff\",\"children\":[\"$\",\"i\",null,{\"className\":\"far fa-clipboard LanguageConsole_ico_clipboard__tvVJz\"}]}]]}],[\"$\",\"div\",null,{\"className\":\"LanguageConsole_console_content__O4Cw8\",\"children\":[\"$\",\"pre\",null,{\"className\":\"LanguageConsole_console_code__9O_nt\",\"dangerouslySetInnerHTML\":{\"__html\":\"client.interceptors.request.use(\\n    function (config) {\\n        const user = localStorage.getItem('user');\\n        if (!user) {\\n            config.headers[\\\"accessToken\\\"] = null;\\n            config.headers[\\\"refreshToken\\\"] = null;\\n            return config\\n        }\\n        const { accessToken, refreshToken } = JSON.parse(user)\\n        config.headers[\\\"accessToken\\\"] = accessToken;\\n        config.headers[\\\"refreshToken\\\"] = refreshToken;\\n        return config\\n    }\\n)\"}}]}]]}],[\"$\",\"div\",\"7\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"reqeust를 보낼때 localStorage에 token 정보가 있다면 헤더에 토큰 정보를 저장하고 없다면 null로 처리를 한다.\"}}],[\"$\",\"div\",null,{\"className\":\"LanguageConsole_console_container__AqYGR\",\"children\":[[\"$\",\"div\",null,{\"className\":\"LanguageConsole_console_header__inJS4\",\"children\":[[\"$\",\"span\",null,{\"className\":\"LanguageConsole_title__QSrQq\",\"data-label-text\":\"Javascript\",\"children\":[\"$\",\"i\",null,{\"className\":\"fas fa-code fa-fw small LanguageConsole_ico_title__oetQW\"}]}],[\"$\",\"button\",null,{\"className\":\"LanguageConsole_copy__l7rff\",\"children\":[\"$\",\"i\",null,{\"className\":\"far fa-clipboard LanguageConsole_ico_clipboard__tvVJz\"}]}]]}],[\"$\",\"div\",null,{\"className\":\"LanguageConsole_console_content__O4Cw8\",\"children\":[\"$\",\"pre\",null,{\"className\":\"LanguageConsole_console_code__9O_nt\",\"dangerouslySetInnerHTML\":{\"__html\":\"client.interceptors.response.use(\\n    function (response) {\\n        return response\\n    },\\n    async function (error) {\\n      if (error.response \u0026\u0026 error.response.status === 403) {\\n          try {\\n              const originalRequest = error.config;\\n              const data = await client.get('auth/refreshtoken')\\n              if (data) {\\n                  const {accessToken, refreshToken} = data.data\\n                  localStorage.removeItem('user')\\n                  localStorage.setItem('user', JSON.stringify(data.data, ['accessToken', 'refreshToken']))\\n                  originalRequest.headers['accessToken'] = accessToken;\\n                  originalRequest.headers['refreshToken'] = refreshToken;\\n                  return await client.request(originalRequest);\\n                  }\\n          } catch (error){\\n              localStorage.removeItem('user');\\n              console.log(error);\\n          }\\n          return Promise.reject(error)\\n      }\\n      return Promise.reject(error)\\n    }\\n)\"}}]}]]}],[\"$\",\"div\",\"9\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"response를 받았을 때, error가 발생했고 해당 error의 status가 403이라면 기존의 originalRequest를 auth/refreshtoken 으로 전달해 토큰을 재발급 받도록 한다.\u003c/br\u003e\u003c/br\u003e\\n        여기서 403 이외의 오류가 들어온다면 토큰 재발급에 실패한것으로 처리를 한다.\u003c/br\u003e\u003c/br\u003e\\n        재발급 받은 토큰을 다시 로컬스토리지에 저장 하고 헤더 부분에 토큰 정보를 변경하고 다시 originalRequest를 보낸다.\"}}],[\"$\",\"div\",null,{\"className\":\"LanguageConsole_console_container__AqYGR\",\"children\":[[\"$\",\"div\",null,{\"className\":\"LanguageConsole_console_header__inJS4\",\"children\":[[\"$\",\"span\",null,{\"className\":\"LanguageConsole_title__QSrQq\",\"data-label-text\":\"Javascript\",\"children\":[\"$\",\"i\",null,{\"className\":\"fas fa-code fa-fw small LanguageConsole_ico_title__oetQW\"}]}],[\"$\",\"button\",null,{\"className\":\"LanguageConsole_copy__l7rff\",\"children\":[\"$\",\"i\",null,{\"className\":\"far fa-clipboard LanguageConsole_ico_clipboard__tvVJz\"}]}]]}],[\"$\",\"div\",null,{\"className\":\"LanguageConsole_console_content__O4Cw8\",\"children\":[\"$\",\"pre\",null,{\"className\":\"LanguageConsole_console_code__9O_nt\",\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}]]}],[false,[\"$\",\"h2\",null,{\"className\":\"postDetail_h2__ZGkVK\",\"children\":\"보안\"}],false,false],[false,[\"$\",\"h2\",null,{\"className\":\"postDetail_h2__ZGkVK\",\"children\":\"CSRF(Cross Site Request Forgery)\"}],false,false],[\"$\",\"div\",\"13\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"CSRF는 Cross-Site Request Forgery의 약자로, 한 사이트에서 인증된 사용자의 권한을 가로채어 다른 사이트에서 공격자가 의도한 동작을 수행하게 하는 공격이다. 이 공격은 사용자가 자신의 의지와 무관하게 공격자가 의도한 요청을 악의적인 웹사이트를 통해 전송함으로써 이루어진다.\"}}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"postDetail_h4__Af1O8\",\"children\":[\"📝 \",\"CSRF 작동 원리\"]}]],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"사용자가 특정 웹사이트에 로그인하여 인증을 받는다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"          이 사용자가 다른 웹사이트(공격자의 사이트)를 방문한다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"         공격자의 사이트에서는 사용자의 권한으로 특정 동작(예: 글쓰기, 계정 변경 등)을 요청하는 HTTP 요청을 생성한다.\"}}],[\"$\",\"li\",\"3\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"         이를 트리거하기 위해 공격자는 이미 로그인된 사용자의 브라우저에서 악의적인 요청을 보낼 수 있는 방법을 찾는다.\"}}]]}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"postDetail_h4__Af1O8\",\"children\":[\"📝 \",\"예시 시나리오\"]}]],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"사용자 A가 은행 웹사이트에 로그인한다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"        사용자 A가 악의적인 이메일 링크를 클릭하여 공격자의 웹사이트에 접속한다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"        해당 웹사이트에서는 사용자 A의 권한으로 은행 웹사이트에 자동으로 자금 이체를 요청하는 HTTP 요청을 생성한다.\"}}],[\"$\",\"li\",\"3\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"        이를 통해 은행 웹사이트는 사용자 A의 권한으로 이체를 실행하게 된다.\"}}]]}],[false,[\"$\",\"h2\",null,{\"className\":\"postDetail_h2__ZGkVK\",\"children\":\"XSS(Cross Site Scripting)\"}],false,false],[\"$\",\"div\",\"19\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"XSS라고 불리는 이유는 CSS가 이미 약자가 있기 때문이고 code injection attack이라고도 한다.\\n\\n        XSS도 다양한 공격 방법이 있는데 우선은\\n        \u003cb\u003e공격자가 의도하는 악의적인 js 코드를 피해자의 웹 브라우저에서 실행\u003c/b\u003e시키는 것 정도로 알고 있으면 된다.\\n        \\n        이 방법으로 피해자 브라우저에 저장된 중요 정보들을 탈취 가능하다.\"}}],[false,false,[\"$\",\"blockquote\",null,{\"className\":\"Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_warning__ZYPQt\",\"children\":[\"$\",\"p\",null,{\"className\":\"Prompts_detail__nD6Io\",\"dangerouslySetInnerHTML\":{\"__html\":\"아무리 다른 공격(CSRF 등)에 대한 방비를 열심히 했다 해도 XSS가 뚫린다면 아무 소용이 없다. js코드로 의도하지 않은 request를 날린다던가 localStorage, 변수 값 등 모든 것이 탈취 가능하기 때문이다. XSS 공격 방지는 웹 보안의 뿌리이며 XSS 공격을 막는 것은 웹 보안을 위한 최소한의 조치이다.\"}}]}],false],[false,[\"$\",\"h2\",null,{\"className\":\"postDetail_h2__ZGkVK\",\"children\":\"해결 1) localStorage에 저장하는 방법\"}],false,false],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"postDetail_h4__Af1O8\",\"children\":[\"📝 \",\"CSRF 공격에는 안전하다.\"]}]],[\"$\",\"div\",\"23\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"그 이유는 자동으로 request에 담기는 쿠키와는 다르게 js 코드에 의해 헤더에 담기므로 XSS를 뚫지 않는 이상 공격자가 정상적인 사용자인 척 request를 보내기가 어렵다.\"}}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"postDetail_h4__Af1O8\",\"children\":[\"📝 \",\"XSS에 취약하다.\"]}]],[\"$\",\"div\",\"25\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"공격자가 localStorage에 접근하는 js 코드 한 줄만 주입하면 localStorage를 공격자가 내 집처럼 드나들 수 있다.\"}}],[false,[\"$\",\"h2\",null,{\"className\":\"postDetail_h2__ZGkVK\",\"children\":\"해결 2) cookie에 저장하는 방법\"}],false,false],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"postDetail_h4__Af1O8\",\"children\":[\"📝 \",\"XSS 공격으로부터 localStorage에 비해 안전하다.\"]}]],[\"$\",\"div\",\"28\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"쿠키의 httpOnly 옵션을 사용하면 Js에서 쿠키에 접근 자체가 불가능하다.\u003c/br\u003e\\n        그래서 XSS 공격으로 쿠키 정보를 탈취할 수 없다.(httpOnly 옵션은 서버에서 설정할 수 있음) 하지만 XSS 공격으로부터 완전히 안전한 것은 아니다.\"}}],[\"$\",\"div\",\"29\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"httpOnly 옵션으로 쿠키의 내용을 볼 수 없다 해도 js로 request를 보낼 수 있으므로 자동으로 request에 실리는 쿠키의 특성 상 사용자의 컴퓨터에서 요청을 위조할 수 있기 때문이다.\u003c/br\u003e\\n        공격자가 귀찮을 뿐이지 XSS가 뚫린다면 httpOnly cookie도 안전하진 않다.\"}}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"postDetail_h4__Af1O8\",\"children\":[\"📝 \",\"CSRF 공격에 취약하다.\"]}]],[\"$\",\"div\",\"31\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"자동으로 http request에 담아서 보내기 때문에 공격자가 request url만 안다면 사용자가 관련 link를 클릭하도록 유도하여 request를 위조하기 쉽다.\"}}],[false,[\"$\",\"h2\",null,{\"className\":\"postDetail_h2__ZGkVK\",\"children\":\"해결 3 : refresh token 사용하는 방법\"}],false,false],[\"$\",\"div\",\"33\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"가장 좋은 방법으로는 refresh token을 사용하는 방법이 있다. CSRF 공격으로부터 안전한 환경을 유지하기 위해 쿠키에 SameSite 속성을 설정하고, 리프레시 토큰을 활용하여 요청의 유효성을 검증하는 방법이다. 백엔드 api 개발자와 소통이 가능하다면 refresh token을 httpOnly 쿠키로 설정하고\\n        url이 새로고침 될 때마다 refresh token을 request에 담아 새로운 accessToken을 발급 받는다. \u003c/br\u003e\u003c/br\u003e\\n        \\n        발급 받은 accessToken은 js private variable에 저장한다.\u003c/br\u003e\u003c/br\u003e\\n        \\n        이런 방식을 사용하는 경우, refresh token이 CSRF에 의해 사용된다 하더라도 공격자는 accessToken을 알 수 없다.\u003c/br\u003e\u003c/br\u003e\\n        \\n        CSRF는 피해자의 컴퓨터를 제어할 수 있는 것이 아니기 때문이다. 요청을 위조하여 피해자가 의도하지 않은 서버 동작을 일으키는 공격방법이기 때문에 refresh token을 통해 받아온 response(accessToken)는 공격자가 확인할 수 없다.\u003c/br\u003e\u003c/br\u003e\\n        \\n        따라서 쿠키를 사용하여 XSS를 막고 refresh token 방식을 이용하여 CSRF를 막을 수 있다.\"}}]],[\"$\",\"$Le\",null,{\"postid\":\"13\"}],[\"$\",\"div\",null,{\"className\":\"footer_footer_container__MsSvO\",\"children\":[\"$\",\"footer\",null,{\"className\":\"footer_footer__AwYty\",\"children\":[[\"$\",\"p\",null,{\"className\":\"footer_copylight___J5l0\",\"children\":\"© 2024 bunny Chung. Some rights reserved.\"}],[\"$\",\"p\",null,{\"className\":\"footer_theme__bwXbg\",\"children\":\"Using the theme ...\"}]]}]}]],null]]},[\"$\",\"$Lf\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"tags\",\"children\",\"$10\",\"children\",\"$11\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L12\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/b156f85051d44ed2.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]]},[\"$\",\"$Lf\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"tags\",\"children\",\"$10\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L12\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[\"$\",\"$Lf\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"tags\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L12\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]],\"modal\":[\"__DEFAULT__\",{},[\"$13\",null,null]]},[null,[\"$\",\"$L15\",null,{\"children\":[\"$\",\"$Lf\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L12\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}],\"modal\":[\"$\",\"$Lf\",null,{\"parallelRouterKey\":\"modal\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"modal\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L12\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$16\",\"styles\":null}],\"params\":{}}],null]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css\",\"as\":\"style\"}]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"$Lf\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L12\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":\"$17\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":\"$18\",\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":\"$19\",\"children\":[\"$\",\"h2\",null,{\"style\":\"$1a\",\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/5a76cc91da7d955b.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]}]]}],null]],\"initialHead\":[false,\"$L1b\"],\"globalErrorComponent\":\"$1c\"}]]\n"])</script><script>self.__next_f.push([1,"1b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Create Next App\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Generated by create next app\"}],[\"$\",\"meta\",\"4\",{\"name\":\"next-size-adjust\"}]]\nb:null\n14:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>