2:I[5250,["250","static/chunks/250-8b90be581650ff9d.js","399","static/chunks/399-caf055eb211349e2.js","216","static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-585d3f04b6239a7e.js"],""]
3:I[8843,["250","static/chunks/250-8b90be581650ff9d.js","399","static/chunks/399-caf055eb211349e2.js","216","static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-585d3f04b6239a7e.js"],""]
4:I[777,["250","static/chunks/250-8b90be581650ff9d.js","399","static/chunks/399-caf055eb211349e2.js","216","static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-585d3f04b6239a7e.js"],""]
5:I[5613,[],""]
8:I[1778,[],""]
c:I[3866,["250","static/chunks/250-8b90be581650ff9d.js","399","static/chunks/399-caf055eb211349e2.js","46","static/chunks/46-f5c36f830a2ce4c4.js","730","static/chunks/730-f56ebe909f1c8bdb.js","35","static/chunks/35-f78335334d884639.js","464","static/chunks/app/(layoutCase)/layout-8ff98cce509a96df.js"],""]
6:["tagname","%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9","d"]
7:["postid","61","d"]
9:"$La"
d:[]
e:{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"}
f:{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"}
10:{"display":"inline-block"}
11:{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0}
0:["Yjx90b2IIcmdYNysIldso",[[["",{"children":["(layoutCase)",{"children":["tags",{"children":[["tagname","%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9","d"],{"children":[["postid","61","d"],{"children":["__PAGE__?{\"tagname\":\"지연로딩\",\"postid\":\"61\"}",{}]}]}]}],"search":["__DEFAULT__",{}]}]},"$undefined","$undefined",true],["",{"children":["(layoutCase)",{"children":["tags",{"children":[["tagname","%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9","d"],{"children":[["postid","61","d"],{"children":["__PAGE__",{},["$L1",[[["$","article",null,{"className":"$undefined","children":["$","header",null,{"children":["$","h1",null,{"className":"postUserInfo_h1__uhAqy","children":"[TECH-QA] 프로토타입(Prototype)과 프로토타입체이닝"}]}]}],["$","div",null,{"className":"postUserInfo_post_meta__ABvuC","children":[["$","span",null,{"children":["Posted"," ",["$","time",null,{"className":"postUserInfo_time__2exyR","children":["2 months"," "]}]]}],["$","span",null,{"className":"postUserInfo_update__f345P","children":["Updated"," ",["$","time",null,{"className":"postUserInfo_time__2exyR","children":"2 months"}]]}]]}],["$","div",null,{"children":["$","span",null,{"className":"postUserInfo_post_meta__ABvuC","children":["By"," ",["$","em",null,{"children":["$","$L2",null,{"href":"https://nam-yeun-hwa.github.io/","className":"postUserInfo_author__fVGYM","children":"베짱이가 되고싶은 개미。"}]}]]}]}]],[[false,["$","h2",null,{"className":"heading_h2__fsXMw","style":{"fontWeight":"NORMAL"},"children":"프로토타입(prototype)"}],false,false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"프로토타입(prototype)이란 객체가 생성될 때 그 객체를 만드는 데 사용된 원형, 즉 <b>템플릿 역할</b>을 하는 프로토타입 객체를 의미합니다. 모든 자바스크립트 객체는 이 프로토타입 객체와 연결되어 있으며, 이 연결은 객체의 숨겨진 속성인 <span class=\"point\">__proto__</span>  (proto 속성)를 통해 참조됩니다. 이 <span class=\"point\">__proto__</span> 속성은 <b>해당 객체가 어떤 프로토타입 객체를 기반</b>으로 만들어졌는지를 가리키는 링크 역할을 합니다. 따라서 프로토타입은 객체와 그 원형 객체를 연결하는 핵심적인 메커니즘이라고 볼 수 있습니다."}}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","기본 객체의 __proto__"]}]],["$","$L3",null,{"code":"// 빈 객체 생성\nconst obj = {};\n\nconsole.log(obj.__proto__); // [Object: null prototype] {} (Object.prototype)\n\nconsole.log(obj.__proto__.__proto__); // null","children":"$undefined"}],[false,["$","blockquote",null,{"className":"Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_info__Jt15_","children":["$","p",null,{"className":"Prompts_detail__nD6Io","dangerouslySetInnerHTML":{"__html":"obj는 기본 객체로, Object 생성자를 통해 만들어졌습니다.</br>\nobj.__proto__는 <b>Object.prototype을 참조</b>합니다. 이는 <b>모든 기본 객체의 프로토타입</b>입니다.</br>\nObject.prototype의 __proto__는 null로, 프로토타입 체인의 끝을 나타냅니다."}}]}],false,false],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","배열 객체의 __proto__"]}]],["$","$L3",null,{"code":"const arr = [1, 2, 3];\n\nconsole.log(arr.__proto__); // [Array: null prototype] [] (Array.prototype)\n\nconsole.log(arr.__proto__.__proto__); // [Object: null prototype] {} (Object.prototype)\n\nconsole.log(arr.__proto__.__proto__.__proto__); // null","children":"$undefined"}],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"arr는 배열 객체로, Array 생성자를 통해 만들어졌습니다."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"arr.__proto__는 Array.prototype을 참조하며, 배열 관련 메서드(push, pop 등)가 이 프로토타입에 정의되어 있습니다."}}],["$","li","2",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"Array.prototype의 __proto__는 Object.prototype을 참조합니다. 따라서 배열도 기본적으로 객체의 속성을 상속받습니다."}}]]}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","커스텀 객체와 생성자 함수"]}]],["$","$L3",null,{"code":"// 생성자 함수 정의\nfunction Person(name) {\n  this.name = name;\n}\n\n// Person.prototype에 메서드 추가\nPerson.prototype.sayHello = function () {\n  console.log(\"Hello, I'm ${this.name}\");\n};\n\n// 객체 생성\nconst person = new Person(\"Alice\");\n\n// person의 __proto__ 확인\nconsole.log(person.__proto__); // Person { sayHello: [Function (anonymous)] } (Person.prototype)\n\n// Person.prototype의 __proto__ 확인\nconsole.log(person.__proto__.__proto__); // [Object: null prototype] {} (Object.prototype)\n\n// 프로토타입 체인을 따라 메서드 호출\nperson.sayHello(); // Hello, I'm Alice","children":"$undefined"}],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"Person은 생성자 함수로, new Person()으로 생성된 person 객체의 __proto__는 Person.prototype을 참조합니다."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"Person.prototype에는 sayHello 메서드가 정의되어 있으므로, person은 이 메서드를 상속받아 사용할 수 있습니다."}}],["$","li","2",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"Person.prototype.__proto__는 Object.prototype을 참조하며, 체인은 결국 null로 끝납니다."}}]]}],[["$","blockquote",null,{"className":"Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_tip__CZ2Ex","children":["$","p",null,{"className":"Prompts_detail__nD6Io","dangerouslySetInnerHTML":{"__html":"__proto__는 비표준 속성이지만, 대부분의 브라우저에서 디버깅 용도로 접근 가능합니다. </br> 실제 코드에서는 Object.getPrototypeOf(obj)를 사용하는 것이 권장됩니다."}}]}],false,false,false],["$","$L3",null,{"code":"console.log(Object.getPrototypeOf(person) === Person.prototype); // true","children":"$undefined"}],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"__proto__는 객체와 프로토타입 간의 연결을 보여주며, 이를 통해 프로토타입 체이닝이 동작합니다."}}]]}],[false,["$","h2",null,{"className":"heading_h2__fsXMw","style":{"fontWeight":"NORMAL"},"children":"프로토타입 체인(prototype chain)"}],false,false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"프로토타입 체인(prototype chain)에 대해 살펴보면, 객체의 __proto__ 속성이 또 다른 객체의 프로토타입을 참조하고, 그 참조된 프로토타입 객체의 __proto__가 다시 또 다른 프로토타입을 참조하는 식으로 연쇄적으로 이어진 구조를 말합니다. 이 체인은 최종적으로 Object.prototype이라는 기본 프로토타입 객체에 도달 할 때까지 이어지며, 그 끝에는 __proto__가 null인 지점이 존재합니다."}}],[false,["$","h2",null,{"className":"heading_h2__fsXMw","style":{"fontWeight":"NORMAL"},"children":"프로토타입 체이닝(prototype chaining)"}],false,false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"이러한 프로토타입 체인을 활용하여 자바스크립트는 속성이나 메서드를 검색하는데, 이를 프로토타입 체이닝(prototype chaining)이라고 합니다. 예를 들어, 객체에서 특정 속성이나 메서드를 호출하려 할 때, 자바스크립트 엔진은 먼저 그 객체 자체에서 해당 속성을 찾습니다. 만약 찾지 못하면 __proto__를 통해 연결된 프로토타입 객체로 이동하여 검색을 계속하고, 이 과정을 체인을 따라 끝까지 반복합니다. 이렇게 체인을 따라가며 속성을 탐색하는 방식이 프로토타입 체이닝의 핵심입니다."}}],[false,["$","h2",null,{"className":"heading_h2__fsXMw","style":{"fontWeight":"NORMAL"},"children":"프로토타입 기반 상속(prototype-based inheritance)"}],false,false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"자바스크립트에서 객체는 자신의 프로토타입 객체로부터 속성과 메서드를 \"상속\"받아 사용할 수 있습니다."}}],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"<b>동적 연결</b>: 객체는 __proto__를 통해 프로토타입 객체와 연결되며, 이 연결은 런타임에 동적으로 속성이나 메서드를 참조할 수 있게 합니다."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"<b>공유</b>: 프로토타입에 정의된 속성이나 메서드는 해당 프로토타입을 상속받는 모든 객체가 공유합니다. 즉, 각 객체마다 새로 생성되지 않고 프로토타입에서 참조됩니다."}}],["$","li","2",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"<b>체인 구조</b>: 상속은 단일 객체 수준에서 끝나는 것이 아니라, 프로토타입 체인을 따라 여러 단계로 이어질 수 있습니다."}}]]}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","객체를 통해 상속으로 이해하는 예시"]}]],["$","$L3",null,{"code":"// 부모 역할을 할 프로토타입 객체\nconst animal = {\n  eat: function() {\n    console.log(\"${this.name} is eating!\");\n  }\n};\n\n// 자식 객체 생성 및 상속 설정\nconst dog = {\n  name: \"Dog\"\n};\nObject.setPrototypeOf(dog, animal);\n\n// 상속받은 메서드 호출\ndog.eat(); \n// 출력: \"Dog is eating!\"\n\n// 프로토타입 확인\nconsole.log(dog.__proto__ === animal); \n// 출력: true","children":"$undefined"}],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"dog 객체는 animal 객체를 프로토타입으로 상속받았습니다."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"dog 자체에는 eat 메서드가 없지만, __proto__를 통해 animal의 eat 메서드를 상속받아 사용할 수 있습니다."}}]]}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","생성자 함수를 통한 상속 예시"]}]],["$","$L3",null,{"code":"// 부모 생성자 함수\nfunction Animal(name) {\n  this.name = name;\n}\nAnimal.prototype.eat = function() {\n  console.log(\"${this.name} is eating!\");\n};\n\n// 자식 생성자 함수\nfunction Dog(name) {\n  Animal.call(this, name); // Animal의 속성 상속\n}\nObject.setPrototypeOf(Dog.prototype, Animal.prototype); // 프로토타입 상속\n\n// 객체 생성\nconst myDog = new Dog(\"Max\");\n\n// 상속받은 메서드 호출\nmyDog.eat(); \n// 출력: \"Max is eating!\"\n\n// 프로토타입 체인 확인\nconsole.log(myDog.__proto__ === Dog.prototype); \n// 출력: true\nconsole.log(myDog.__proto__.__proto__ === Animal.prototype); \n// 출력: true","children":"$undefined"}],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"Dog는 Animal의 프로토타입을 상속받아 eat 메서드를 사용할 수 있습니다."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"Animal.call(this, name)으로 <b>name 속성을 상속</b>받고, Object.setPrototypeOf로 프로토타입 체인을 연결해 <b>메서드까지 상속</b>받았습니다."}}],["$","li","2",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"이는 전통적인 상속처럼 \"부모(Animal)로부터 자식(Dog)이 기능을 물려받는다\"는 개념으로 이해할 수 있습니다."}}]]}],[false,false,["$","h3",null,{"className":"heading_h3__UisKt","style":{"fontWeight":"NORMAL"},"children":"상속으로 볼 수 있는 이유"}],false],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"<b>속성과 메서드 재사용</b>: 객체가 프로토타입에서 속성과 메서드를 물려받아 사용하므로, 코드 중복을 줄이고 재사용성을 높이는 상속의 목적을 충족합니다."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"<b>계층 구조</b>: 프로토타입 체인을 통해 부모-자식 관계와 유사한 계층 구조를 형성합니다."}}],["$","li","2",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"<b>확장 가능성</b>: 프로토타입에 새로운 기능을 추가하면 이를 상속받는 모든 객체가 그 기능을 사용할 수 있어, 상속의 유연성을 보여줍니다."}}]]}],[false,false,["$","blockquote",null,{"className":"Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_warning__ZYPQt","children":["$","p",null,{"className":"Prompts_detail__nD6Io","dangerouslySetInnerHTML":{"__html":"<b>주의할 점</b></br>\n\t\t\t\t자바스크립트의 상속은 클래스 기반 언어처럼 고정된 계층 구조를 따르지 않고, 객체 간의 동적 연결(__proto__)에 의존합니다.\n상속받은 속성이나 메서드는 실제로 객체 자체에 복사되는 것이 아니라 참조되는 것이므로, <b>프로토타입을 수정하면 모든 상속받은 객체에 영향을 미칩니다.</b>"}}]}],false]],["$","$L4",null,{"postid":61,"prePostTitle":{"id":62,"title":"[TECH-QA] 리액트 리렌더링","date":"2025-04-12 15:34:33","folder":"Javascript","tag":["JavaScript","TECH-QA","react","리렌더링"],"preview":"리액트에서 리렌더링(re-rendering)은 컴포넌트가 다시 그려지는 과정입니다. 즉, 어떤 변화가 발생했을 때, 리액트가 해당 컴포넌트(혹은 그 자식들 포함)를 다시 실행해서 UI를 업데이트하는 걸 말합니다.","post":[{"type":"normal","value":"리액트에서 리렌더링(re-rendering)은 컴포넌트가 다시 그려지는 과정입니다. 즉, 어떤 변화가 발생했을 때, 리액트가 해당 컴포넌트(혹은 그 자식들 포함)를 다시 실행해서 UI를 업데이트하는 걸 말합니다. 리렌더링이 너무 많이 발생하면 성능에 부정적인 영향을 줄 수 있습니다. 특히 대규모 애플리케이션이나 자주 렌더링되는 컴포넌트에서는 주의가 필요합니다. 그래서 이번 글에서는 리액트 리렌더링에 대해 이야기 해보려고 합니다."},{"type":"Heading","headingType":"h3","value":"언제 리렌더링이 발생할까요?"},{"type":"stringlist","value":"state가 변경될 때\n\t\t\t\tprops가 변경될 때\n\t\t\t\tcontext 값이 변경될 때\n\t\t\t\t부모 컴포넌트가 리렌더링되면 자식도 리렌더링"},{"type":"normal","value":"위와 같은 경우에 리액트 컴포넌트에서는 리렌더링이 발생합니다. 한 컴포넌트에 여러가지 스테이트들이 존재하고 UI에서는 여러 인터렉션(버튼 클릭, 입력, 체크박스 등)이 발생하며 스테이드 값들이 변경될때 컴포넌트는 리렌더링 되고 있다고 생각하면 됩니다."},{"type":"GuideMessage","value":"리렌더링된다고 해서 DOM 전체를 다시 그리는 건 아닙니다. 리액트는 \"Virtual DOM\"을 이용해서 변경된 부분만 최소한으로 UI를 업데이트 하며 컴포넌트에 있는 함수들은 새로 생성됩니다. 예를 들면 아래 코드를 보시면 이해 하실 수 있습니다."},{"type":"code","value":"const MyComponent = () => {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => setCount(count + 1);\n\n  return <button onClick={handleClick}>{count}</button>;\n};\n"},{"type":"normal","value":"위 함수가 리렌더링이 일어나면 "},{"type":"stringlist","value":"버튼 클릭 → setCount 호출 → count 값 변경\n\n변경된 state로 인해 MyComponent() 함수 전체가 다시 실행됨\n\ncount, handleClick, JSX 등이 다시 계산됨\n\nVirtual DOM에서 변화 비교 후, 실제 DOM은 필요한 부분만 업데이트됨"},{"type":"normal","value":"위와 같은 일이 이루어 집니다. 여기에서 UI는 최소한으로 부분 업데이트 되며 handleClick 함수는 새로 생성됩니다. 새로 생성된다 함은 함수 객체 자체가 메모리에 새로 만들어지는 것입니다. "},{"type":"code","value":"const handleClick = () => setCount(count + 1);"},{"type":"normal","value":"위 코드는 함수 표현식(= 함수 리터럴)이기 때문에 이 줄이 실행될 때마다 새로운 함수 객체가 메모리에 만들어집니다. </br> 코드로 확인해 보겠습니다."},{"type":"code","value":"const MyComponent = () => {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => setCount(count + 1);\n\n  useEffect(() => {\n    console.log(\"handleClick 함수가 새로 만들어졌어요!\");\n  }, [handleClick]);\n\n  return <button onClick={handleClick}>{count}</button>;\n};\n"},{"type":"stringlist","value":"버튼을 누르면 setCount로 상태가 바뀌고,\n\n컴포넌트가 다시 렌더링됨,\n\n그러면 handleClick도 새로 생성됨,\n\n따라서 useEffect가 실행됨 → 콘솔에 로그 출력!"},{"type":"Heading","headingType":"h3","value":"그럼 왜 리렌더링 때마다 새로 생성될까요?"},{"type":"normal","value":"리액트 함수형 컴포넌트는 결국 함수이자, 매번 실행되는 실행 단위입니다. 여기서 컴포넌트가 호출되면, 그 내부의 handleClick = () => { ... }도 다시 실행되는 것입니다.\n그래서 이 때마다 새로운 함수 객체가 생성되는 것이라고 볼 수 있습니다. 그럼 조금 더 들어가서 리액트 컴포넌트가 리렌더링이 덜 되도록 하는 방법에 대해 생각해 보도록 하겠습니다."},{"type":"normal","value":"한 컴포넌트에서 여러 기능을 가지고 여러 스테이트들을 관리하던 것을 훅에서 스테이트 값이나 상태 값을 관리하고, 컴포넌트는 순수하게 인터렉션만 처리하도록 설계된 경우, 해당 컴포넌트는 스테이트 변경에 따른 리렌더링을 피할 수 있습니다. 하지만 이게 보장되려면 몇 가지 조건과 주의점이 필요합니다. 아래에서 이 상황을 자세히 분석하고, 왜 리렌더링이 일어나지 않을 수 있는지, 그리고 어떤 경우에 주의해야 하는지 설명하겠습니다. 코드를 통해 살펴 보겠습니다."},{"type":"Heading","headingType":"h4","value":"[커스텀 훅] usePdfController.js"},{"type":"code","value":"const usePdfController = () => {\n  const [file, setFile] = useState(null);\n  const pdfInputRef = useRef(null);\n\n  const handlePDFChange = (event) => {\n    const selectedFile = event.target.files[0];\n    setFile(selectedFile);\n  };\n\n  return { file, pdfInputRef, handlePDFChange };\n};"},{"type":"Heading","headingType":"h4","value":"[자식 컴포넌트] FileUpload.jsx (인터랙션만 처리)"},{"type":"code","value":"const FileUpload = ({ onChange, InputRef, children }) => {\n  return (\n    <label>\n      {children}\n      <input type=\"file\" ref={InputRef} onChange={onChange} style={{ display: 'none' }} />\n    </label>\n  );\n};\n"},{"type":"Heading","headingType":"h4","value":"[부모 컴포넌트] StampController.jsx"},{"type":"code","value":"const StampController = () => {\n  const { file, pdfInputRef, handlePDFChange } = usePdfController();\n\n  return (\n    <div>\n      <FileUpload InputRef={pdfInputRef} onChange={handlePDFChange}>\n        PDF 업로드\n      </FileUpload>\n      {file?.name && <div>{file.name}</div>}\n    </div>\n  );\n};"},{"type":"stringlist","value":"<b>스테이트 관리</b>: 스테이트는 커스텀 훅(예: usePdfController) 또는 스토어(예: useCanvasStore)에서 관리.\n<b>인터랙션 컴포넌트</b>: 특정 컴포넌트(예: FileUpload, Button)는 사용자 인터랙션(클릭, 파일 선택 등)만 처리하고, 스테이트나 상태 값을 직접 소유하지 않음.\n<b>인터랙션 처리</b>: 인터랙션은 훅이나 스토어에서 제공하는 함수(예: handlePDFChange, handleDownload)를 호출."},{"type":"Heading","headingType":"h3","value":"자식 컴포넌트 <FileUpload/> 리렌더링"},{"type":"Heading","headingType":"h4","value":"스테이트 소유 여부"},{"type":"stringlist","value":"자식 컴포넌트 FileUpload은 자체 스테이트를 가지지 않습니다. 따라서 FileUpload 내부에서 useState나 useReducer로 인해 리렌더링이 발생할 가능성이 없습니다.\n스테이트는 usePdfController에서 관리되며, file 변경은 StampController 같은 부모 컴포넌트에 영향을 줍니다."},{"type":"Heading","headingType":"h4","value":"Props 안정성"},{"type":"stringlist","value":"자식 컴포넌트 FileUpload가 받는 props(예: onChange, InputRef)가 변경되지 않는 한, React는 이 컴포넌트를 리렌더링하지 않습니다.\nFileUpload가 props로 받는 handlePDFChange가 메모이제이션되지 않으면, StampController가 리렌더링될 때마다 handlePDFChange는 <b>새로운 함수 참조가 생성</b>되어 FileUpload의 props가 변경된 것으로 간주되어 자식 컴포넌트 FileUpload는 리렌더링 됩니다. 이를 피하기 위해 <u>커스텀 훅 usePdfController에서 handlePDFChange를 메모이제이션(useCallback)하여, 함수가 매 렌더링마다 동일한 참조를 유지</u>하도록 합니다.\n"},{"type":"code","value":"// usePdfController.js\n// ★★★커스텀 훅 내부에서 useCallback 사용\n  const handlePDFChange = useCallback((event) => {\n  const selectedFile = event.target.files[0];\n  setFile(selectedFile);\n}, []);"},{"type":"stringlist","value":"InputRef는 useRef로 생성된 참조로, 렌더링 간에 변경되지 않습니다."},{"type":"Heading","headingType":"h4","value":"부모 컴포넌트의 리렌더링 영향 "},{"type":"stringlist","value":"부모 컴포넌트 StampController가 자주 리렌더링되면, 자식 컴포넌트 FileUpload도 기본적으로 리렌더링됩니다. \n\t\t\t\tReact는 부모가 리렌더링되면 자식도 렌더링 시도\n\t\t\t\t이를 피하기 위해서는 자식 컴포넌트인 FileUpload을 React.memo로 감싸줍니다."},{"type":"code","value":"const FileUpload = ({ onChange, InputRef, children }) => {\n  console.log('FileUpload rendered');\n  return (\n    <label>\n      {children}\n      <input type=\"file\" ref={InputRef} onChange={onChange} style={{ display: 'none' }} />\n    </label>\n  );\n};\nexport default React.memo(FileUpload);"},{"type":"stringlist","value":"이렇게 하면 onChange, InputRef, children이 변경되지 않는 한 FileUpload은 리렌더링되지 않습니다. 부모컴포넌트 StampController가 file 상태 변경으로 리렌더링되더라도, 자식 컴포넌트 FileUpload가 React.memo로 감싸져 있다면 props가 변경되지 않는 한 리렌더링을 건너뜁니다"},{"type":"stringlist","value":"React.memo는 props의 얕은 비교(shallow comparison)를 수행해 props가 변경되지 않는 한 컴포넌트의 리렌더링을 방지합니다."},{"type":"stringlist","value":"인터랙션의 경우 (예: 파일 선택)은 handlePDFChange를 호출하고, 이는 usePdfController의 file 상태를 변경합니다. 하지만 이 변경은 StampController의 렌더링에만 직접 영향을 주고, FileUpload은 스테이트를 소유하지 않으므로 간접적인 리렌더링을 피할 수 있습니다."},{"type":"Heading","headingType":"h4","value":"<FileUpload/> Children Props 변경"},{"type":"normal","value":"FileUpload의 children(예: \"PDF 업로드\")이 동적으로 생성되거나 매번 새로운 참조를 가지면, React.memo를 사용하더라도 리렌더링될 수 있습니다. children이 정적이거나 메모이제이션된 값을 사용하도록 합니다."},{"type":"code","value":"<FileUpload InputRef={pdfInputRef} onChange={handlePDFChange}>\n  PDF 업로드\n</FileUpload>"},{"type":"Heading","headingType":"h4","value":"<FileUpload/> 같은 자식 컴포넌트가 스토어 상태를 직접 구독하지 않도록 하여 리렌더링을 방지 한다."},{"type":"code","value":"// 잘못된 예\nconst FileUpload = ({ onChange, InputRef, children }) => {\n  const { file } = useCanvasStore(); // 스토어 구독\n  return <input type=\"file\" ref={InputRef} onChange={onChange} />;\n};\n\n// 올바른 예\nconst FileUpload = ({ onChange, InputRef, children }) => {\n  return <input type=\"file\" ref={InputRef} onChange={onChange} />;\n};"},{"type":"Heading","headingType":"h3","value":"리렌더링이 되지 않는 조건을 지켜는 방법"},{"type":"stringlist","value":"컴포넌트가 자체 스테이트를 소유하지 않고 커스텀 훅으로 관리.\n\t\t\t\t컴포넌트가 스토어나 Context를 직접 구독하지 않고 커스텀 훅으로 관리하도록 함.\n전달된 props(함수, 참조, 값)가 메모이제이션되어 전달 받도록 하기.\n컴포넌트가 React.memo로 감싸져 있어 부모 리렌더링의 영향을 받지 않음."}]},"nextPostTile":{"id":60,"title":"[TECH-QA] JWT(JSON Web Token) 인증 방식","date":"2025-04-02 15:44:33","folder":"Javascript","tag":["JavaScript","TECH-QA","JWT","CSRF","XSS"],"preview":"JWT(JSON Web Token)는 웹에서 사용자 인증을 위해 널리 사용되는 토큰 기반 인증 방식입니다. JWT는 세 가지 주요 부분으로 구성되며, 각 부분은 점(.)으로 구분됩니다","post":[{"type":"normal","value":"JWT(JSON Web Token)는 웹에서 사용자 인증을 위해 널리 사용되는 <b>토큰 기반 인증 방식</b>입니다. JWT는 세 가지 주요 부분으로 구성되며, 각 부분은 점(.)으로 구분됩니다 "},{"type":"stringlist","value":"Header(헤더)\n\tPayload(페이로드)\n\tSignature(서명)"},{"type":"normal","value":"이를 <u>Base64 URL 인코딩 방식</u>으로 <u>직렬화</u>하여 <b>헤더 . 페이로드 . 서명 형태의 문자열</b>로 표현됩니다."},{"type":"Heading","headingType":"h3","value":"Header"},{"type":"stringlist","value":"토큰의 유형(보통 \"JWT\")\n\t\t\t\t서명에 사용된 알고리즘을 정의(예: HMAC SHA256, RSA 등)"},{"type":"code","value":"{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}"},{"type":"Heading","headingType":"h3","value":"Payload"},{"type":"normal","value":"사용자 인증에 필요한 정보(클레임, Claims)를 포함합니다. 여기에는 사용자 ID, 권한, 발급 시간(iat), 만료 시간(exp) 등 표준 클레임과 함께 개발자가 추가한 커스텀 클레임이 들어갈 수 있습니다."},{"type":"code","value":"{\n  \"sub\": \"user123\",\n  \"name\": \"John Doe\",\n  \"iat\": 1712016000,\n  \"exp\": 1712023200\n}"},{"type":"Heading","headingType":"h3","value":"Signature"},{"type":"normal","value":"Header와 Payload를 조합한 후 서버의 비밀 키(secret key)를 사용해 서명한 값입니다. 이 서명은 토큰의 무결성을 보장하며, 클라이언트가 토큰을 위조하거나 변조했는지 확인하는 데 사용됩니다. 서명 생성 과정은 다음과 같습니다"},{"type":"code","value":"HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret)"},{"type":"GuideMessage","value":"<b>서버의 비밀 키</b></br>\n\t\t\t\t- 서버의 비밀 키(secret key)는 서버 애플리케이션이 설계되고 배포되는 단계에서 생성되거나 설정됩니다.</br>\n\t\t\t\t- JWT를 생성하고 검증하기 위해 서버 측에서 미리 설정되고 관리되는 고정된 값입니다. </br>\n\t\t\t\t- 이 키는 JWT의 Signature 부분을 생성하고, 나중에 토큰의 유효성을 검증할 때 사용됩니다.\n\t\t\t\t","promptTypeProps":"TIP"},{"type":"Heading","headingType":"h3","value":"장점"},{"type":"stringlist","value":"<b>상태 비저장(Stateless)</b>: 사용자 인증정보를 서버나 세션스토리지에 유지할 필요가 없어 확장성이 뛰어나고, 분산 시스템에서 유리합니다.\n<b>단일 토큰으로 인증</b> : 사용자 인증에 필요한 정보를 토큰 자체에 담고 있어 클라이언트 측에서 들어오는 요청만으로 유효성 검사를 합니다. API 호출 시마다 헤더(Authorization: Bearer <token>)에 포함시켜 간단히 인증을 처리할 수 있습니다.\n<b>호환성</b> : JSON 기반이므로 다양한 플랫폼과 언어에서 쉽게 파싱하고 사용할 수 있습니다."},{"type":"Heading","headingType":"h3","value":"단점 및 고려사항"},{"type":"stringlist","value":"<b>수정 및 폐기 불가</b> : 한 번 발급된 JWT는 만료 전까지 유효하며 중간에 무효화하기 어렵습니다. 이를 보완하려면 Refresh Token을 함께 사용해 짧은 유효기간의 Access Token을 주기적으로 갱신하는 방식이 일반적입니다.\n<b>토큰 탈취 위험</b> : 토큰이 클라이언트에 저장되므로(주로 브라우저의 localStorage나 cookie), XSS(Cross-Site Scripting) 공격에 노출될 가능성이 있습니다. 이를 방지하려면 <b>HTTPS를 사용하고, 토큰을 HttpOnly, Secure 속성이 설정된 쿠키에 저장</b>하는 것이 좋습니다.\n<b>Payload 노출</b> : JWT의 Payload는 암호화되지 않고 Base64로 인코딩만 되어 있어 누구나 디코딩해 내용을 볼 수 있습니다. 따라서 민감한 정보(예: 비밀번호)는 절대 포함시키지 않아야 합니다."},{"type":"Heading","headingType":"h2","value":"토큰 탈취 위험"},{"type":"GuideMessage","value":"<b>HttpOnly</b></br>\n\t\t\t\tHttpOnly는 쿠키에 붙이는 속성 중 하나로,\nJavaScript에서 해당 쿠키에 접근하지 못하게 막는 기능입니다.</br></br>\n<b>Secure</b></br>HTTPS에서만 전송되게 하는 속성 입니다.</br></br>\n<b>SameSite</b></br>CSRF 방지를 위해 쿠키가 어떤 상황에서 자동으로 브라우저에 전송될지를 제한하는 속성입니다.</br>SameSite=Strict 설정일때에는 쿠키가 동일 출처 요청에만 전송되도록 설정합니다.\n\t\t\t\t","promptTypeProps":"INFO"},{"type":"code","value":"Set-Cookie : sessionId=abc123; Secure; HttpOnly; SameSite=Strict\n\t\t\t\t\n//JavaScript로 접근 불가\nconsole.log(document.cookie); // \"\" (빈 문자열 출력)"},{"type":"normal","value":"<b>JWT를 쿠키에 저장할 때</b> : 클라이언트는 이 토큰을 JavaScript로 읽을 수 없고, 브라우저가 자동으로 서버 요청에 포함시켜 인증을 처리합니다."},{"type":"code","value":"Set-Cookie: token=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyMTIzIn0.서명; Path=/; Secure; HttpOnly"},{"type":"normal","value":"HTTPOnly는 쿠키를 클라이언트 측 스크립트로부터 보호하는 간단하면서도 강력한 보안 메커니즘입니다. 특히 인증 관련 데이터를 쿠키에 저장할 때 필수적으로 고려해야 하며, Secure와 SameSite 속성과 함께 사용하면 웹 애플리케이션의 보안을 더욱 강화할 수 있습니다. 다만, 클라이언트 측에서 토큰을 직접 다뤄야 하는 경우에는 대안(예: Authorization 헤더)을 고려해야 합니다."},{"type":"Heading","headingType":"h3","value":"유효기간 설정의 중요성"},{"type":"stringlist","value":"유효기간(exp)을 짧게 설정하는 것은 보안을 강화하는 핵심 방법입니다. 예를 들어, Access Token은 15분~1시간, Refresh Token은 하루 정도로 설정하는 경우가 많습니다. 유효기간이 길면 토큰이 유출되었을 때 악용될 시간이 늘어나므로, 짧은 주기로 갱신하며 보안과 편의성을 균형 있게 유지하는 것이 중요합니다."},{"type":"normal","value":"JWT는 인증 외에도 권한 부여(Authorization)나 정보 교환(예: SSO, Single Sign-On)에도 사용됩니다. 예를 들어, OAuth 2.0 프레임워크에서 ID 토큰으로 활용되기도 합니다.\n\n결론적으로, JWT는 서버 부하를 줄이고 효율적인 인증을 가능하게 하지만, 보안 설계(짧은 유효기간, Refresh Token 도입, HTTPS 필수 등)를 신중히 고려해야 효과적으로 사용할 수 있습니다."},{"type":"Heading","headingType":"h3","value":"로그인 과정에서의 JWT"},{"type":"stringlist","value":"사용자의 자격 증명(예: ID, 비밀번호)을 확인합니다.\n인증이 성공하면, 서버는 미리 설정된 비밀 키를 사용해 JWT를 생성합니다.\n생성된 JWT(헤더.페이로드.서명 형태)는 사용자에게 반환됩니다."},{"type":"normal","value":"여기서 발행되는 것은 JWT 자체이며, 비밀 키는 그 과정에서 사용되는 도구일 뿐입니다."},{"type":"stringlist","value":"비밀 키: my-secret-key (서버에 고정적으로 저장됨)\nJWT: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIn0.서명값"}]},"segment":"posts"}],["$","div",null,{"className":"footer_footer_container__MsSvO","children":["$","footer",null,{"className":"footer_footer__AwYty","children":[["$","p",null,{"className":"footer_copylight___J5l0","children":["© 2024 ","베짱이가 되고싶은 개미。"," Some rights reserved."]}],["$","p",null,{"className":"footer_theme__bwXbg","children":"portfolio v1.0.0-alpha.3"}]]}]}]],null]]},["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","(layoutCase)","children","tags","children","$6","children","$7","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/175d6c648827cdb6.css","precedence":"next","crossOrigin":""}]]}]]},["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","(layoutCase)","children","tags","children","$6","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","(layoutCase)","children","tags","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]],"search":["__DEFAULT__",{},["$9","$Lb",null]]},[null,["$","$Lc",null,{"children":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","(layoutCase)","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":null}],"search":["$","$L5",null,{"parallelRouterKey":"search","segmentPath":["children","(layoutCase)","search"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$d","styles":null}],"params":{}}],null]]},[null,["$","html",null,{"lang":"en","className":"","children":[["$","head",null,{"children":[["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css","as":"style"}],["$","link",null,{"rel":"preconnect","href":"https://fonts.googleapis.com"}],["$","link",null,{"rel":"preconnect","href":"https://fonts.gstatic.com"}],["$","link",null,{"rel":"stylesheet","href":"https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR&display=swap","as":"style"}]]}],["$","body",null,{"children":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":"$e","children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":"$f","children":"404"}],["$","div",null,{"style":"$10","children":["$","h2",null,{"style":"$11","children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/0c496b0e03d530ba.css","precedence":"next","crossOrigin":""}]]}]}]]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/5048045ff4a95083.css","precedence":"next","crossOrigin":""}]],"$L12"]]]]
b:E{"digest":"NEXT_NOT_FOUND"}
12:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"be come 💡"}],["$","meta","3",{"name":"description","content":"App for an Ant Who Wants to Become a Bejjangyi"}]]
1:null
a:null
