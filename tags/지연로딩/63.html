<!DOCTYPE html><html lang="en" class=""><head><meta charSet="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/92e7b59ea9c09c1b.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/04d20c09b3119d43.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/9149e1f00c2ba43a.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-9a0d20cac54890b0.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-0e492acdb34e0e7d.js" async="" crossorigin=""></script><script src="/_next/static/chunks/938-073485517c55f951.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-d3c7d898fafbc3cf.js" async="" crossorigin=""></script><script src="/_next/static/chunks/250-8b90be581650ff9d.js" async=""></script><script src="/_next/static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-0227d192c056155e.js" async=""></script><script src="/_next/static/chunks/304-2ef64042fd5d1e1c.js" async=""></script><script src="/_next/static/chunks/730-f56ebe909f1c8bdb.js" async=""></script><script src="/_next/static/chunks/516-eaf4d30099c06448.js" async=""></script><script src="/_next/static/chunks/927-14bb68f63c9c7538.js" async=""></script><script src="/_next/static/chunks/338-f2b637e42a7ca177.js" async=""></script><script src="/_next/static/chunks/app/(layoutCase)/layout-66e4d36269f645f8.js" async=""></script><title>be come 💡</title><meta name="description" content="App for an Ant Who Wants to Become a Bejjangyi"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" as="style"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR&amp;display=swap" as="style"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><aside id="sidebar" class="sidemenu_sidebar__EmvJl"><header class="sidemenu_profile_wrapper__R57aU"><a href="/posts"><img alt="프로필 사진" loading="lazy" width="112" height="112" decoding="async" data-nimg="1" class="imageLoader_img__X4hab" style="color:transparent" srcSet="https://nam-yeun-hwa.github.io/image/profile1.jpg?w=128&amp;q=75 1x, https://nam-yeun-hwa.github.io/image/profile1.jpg?w=256&amp;q=75 2x" src="https://nam-yeun-hwa.github.io/image/profile1.jpg?w=256&amp;q=75"/></a><h1 class="sidemenu_blog_name_txt__AfWhD">my blog</h1><p class="sidemenu_site_subtitle__eLcN7">You can only earn as much as an ant does by working like an ant.</p></header><nav><ul class="sidemenu_nav__6C5tz"><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/posts"><i class="fa-fw fas fa-home sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">HOME</span></a></li><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/categories"><i class="fa-fw fas fa-stream sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">CATEGORIES</span></a></li><li class="sidemenu_nav_item__tt_B1 sidemenu_active__fflT6"><a class="sidemenu_nav_link__WTCmf" href="/tags"><i class="fa-fw fas fa-tags sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">TAGS</span></a></li><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/archives"><i class="fa-fw fas fa-archive sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">ARCHIVES</span></a></li><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/algorithm"><i class="fa-solid fa-mug-saucer sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">CODING</span></a></li></ul></nav><div class="sidebar-bottom"></div></aside><div class="layout_main_wrapper__1M1Uy"><div class="contents_container__AfHAx"><header class="breadCrumb_topbar_wrapper__dGN_V"><div class="breadCrumb_top_bar__b_rV9"><nav class="breadCrumb_breadcrumb__l7WLX"><span><a class="breadCrumb_topbar_txt__ExrWf" href="/">Home</a><a class="breadCrumb_topbar_txt__ExrWf" href="">[TECH-QA] 원시값과 참조형</a></span></nav><search class="searchBar_search__Ftlhc"><i class="fas fa-search fa-fw searchBar_search_ico__STStc"></i><input id="search" class="searchBar_search_input__1XpQF" placeholder="Search..." autoComplete="off" value=""/></search></div><div class="breadCrumb_mobile_topbar__N1Azi"><button class="breadCrumb_sidebar_trigger__APgD8"><i class="fas fa-bars fa-fw breadCrumb_sidebar_trigger_ico__K9DdV"></i></button><div class="breadCrumb_mobile_topbar_title__oCVBS">be come 💡</div><button class="breadCrumb_search_trigger__PxWyf"><i class="fas fa-search fa-fw breadCrumb_search_trigger_ico__yqqpz"></i></button></div></header><div class="contents_contents__Hpf57"><main class="contents_inner_content__wyt37"><article><header><h1 class="postUserInfo_h1__uhAqy">[TECH-QA] 원시값과 참조형</h1></header></article><div class="postUserInfo_post_meta__ABvuC"><span>Posted<!-- --> <time class="postUserInfo_time__2exyR">17 hours<!-- --> </time></span><span class="postUserInfo_update__f345P">Updated<!-- --> <time class="postUserInfo_time__2exyR">17 hours</time></span></div><div><span class="postUserInfo_post_meta__ABvuC">By<!-- --> <em><a class="postUserInfo_author__fVGYM" href="https://nam-yeun-hwa.github.io/">베짱이가 되고싶은 개미。</a></em></span></div><div class="postDetail_content__OTeO2">자바스크립트에서 원시값(Primitive Values)과 참조형(Reference Types)의 동작 방식, 그리고 이들의 불변성(Immutability)과 가변성(Mutability)에 대해 설명 해 보겠습니다.</div><h2 class="heading_h2__fsXMw">원시값 (Primitive Values)</h2><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4"><b>정의</b> : 원시값은 더 이상 쪼갤 수 없는 기본 데이터 타입으로, 자바스크립트에서는 undefined, null, boolean, number, bigint, string, symbol이 이에 해당합니다.</li><li class="liststyle_dot__SMzS4"><b>복제 방식</b> : 다른 변수에 원시값을 복사할 때, 해당 값이 그대로 복사되어 새로운 변수에 저장됩니다. 이때 메모리 주소 개념은 관여하지 않고, <b>단순히 값만 복사</b>됩니다.</li><li class="liststyle_dot__SMzS4"><b>불변성</b> : 원시값은 불변값입니다. 값을 변경하려고 하면, 기존 메모리 공간의 값을 수정하는 대신 새로운 메모리 공간에 새로운 값을 저장하고, 변수가 참조하던 메모리 주소를 변경합니다.</li></ul><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">let a = 10; // a는 숫자 10을 저장
let b = a;  // b에 a의 값 10을 복사 (독립적인 메모리 공간)

console.log(a); // 10
console.log(b); // 10

b = 20; // b에 새로운 값 20을 할당 (새로운 메모리 공간 사용)
console.log(a); // 10 (a는 여전히 10을 참조)
console.log(b); // 20</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">b = a를 실행하면, a의 값 10이 복사되어 b에 저장됩니다. 이때 <b>a와 b는 각각 독립적인 메모리 공간</b>을 가리킵니다.</li><li class="liststyle_dot__SMzS4">b = 20으로 값을 변경하면, b는 새로운 메모리 공간에 20을 저장하고 그 주소를 참조합니다. a는 영향을 받지 않습니다.</li><li class="liststyle_dot__SMzS4">원시값은 불변적이므로, a나 b의 값을 직접 수정하는 대신 새로운 값을 메모리에 할당합니다.</li></ul><h2 class="heading_h2__fsXMw">참조형 (Reference Types)</h2><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4"><b>정의</b> : 참조형은 <span class="point">객체(Object)</span>, <span class="point">배열(Array)</span>, <span class="point">함수(Function)</span> 등으로, 여러 값을 하나의 단위로 묶은 데이터 타입입니다.</li><li class="liststyle_dot__SMzS4"><b>복제 방식</b> : 참조형은 값이 담긴 <b>메모리 주소를 복제</b>합니다. 즉, 변수는 실제 데이터(객체)가 저장된 메모리 주소를 가리키며, 복사 시 이 주소를 복사합니다. <span class="point">따라서 복사된 변수는 원본 객체와 동일한 메모리 주소를 참조</span>합니다.</li><li class="liststyle_dot__SMzS4"><b>가변성</b> : 참조형은 가변값입니다. 객체가 저장된 메모리 공간은 수정 가능하며, 변수는 해당 객체를 직접 변경할 수 있습니다. 객체의 프로퍼티를 추가, 갱신, 삭제할 수 있습니다.</li></ul><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">let obj1 = { name: "Alice", age: 25 }; // obj1은 객체의 메모리 주소를 참조
let obj2 = obj1; // obj2는 obj1과 동일한 메모리 주소를 참조

console.log(obj1); // { name: "Alice", age: 25 }
console.log(obj2); // { name: "Alice", age: 25 }

// obj2를 통해 객체 수정
obj2.age = 30;
obj2.city = "Seoul"; // 동적으로 프로퍼티 추가

console.log(obj1); // { name: "Alice", age: 30, city: "Seoul" }
console.log(obj2); // { name: "Alice", age: 30, city: "Seoul" }

// 프로퍼티 삭제
delete obj1.city;

console.log(obj1); // { name: "Alice", age: 30 }
console.log(obj2); // { name: "Alice", age: 30 }</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">obj2 = obj1은 obj1이 참조하는 객체의 메모리 주소를 obj2에 복사합니다. 따라서 obj1과 obj2는 동일한 객체를 가리킵니다.</li><li class="liststyle_dot__SMzS4">obj2.age = 30 또는 obj2.city = "Seoul"로 객체를 수정하면, 동일한 메모리 공간을 참조하는 obj1에도 변경 사항이 반영됩니다.</li><li class="liststyle_dot__SMzS4">참조형은 가변적이므로, 객체의 프로퍼티를 동적으로 추가(city), 갱신(age), 삭제(delete obj1.city)할 수 있습니다.</li></ul><h2 class="heading_h2__fsXMw">원시값 vs 참조형 비교</h2><table class="BasicTypeTable_table__Emrp_"><thead><tr><th><div class="headerAction_element__WDAVu"><div class="headerAction_txt__tbutB">특징</div></div></th><th><div class="headerAction_element__WDAVu"><div class="headerAction_txt__tbutB">원시값 (Primitive)</div></div></th><th><div class="headerAction_element__WDAVu"><div class="headerAction_txt__tbutB">참조형 (Reference)</div></div></th></tr></thead><tbody><tr class="BasicTypeTable_td__r_Im5"><td>데이터 타입</td><td>number, string, boolean 등</td><td>object, array, function 등</td></tr><tr class="BasicTypeTable_td__r_Im5"><td>복제 방식</td><td>값 자체 복사</td><td>메모리 주소 복사</td></tr><tr class="BasicTypeTable_td__r_Im5"><td>변경 가능성</td><td>불변 (새로운 값으로 교체)</td><td>가변 (객체 내부 수정 가능)</td></tr><tr class="BasicTypeTable_td__r_Im5"><td>메모리 동작</td><td>새로운 메모리 공간 생성</td><td>동일한 메모리 공간 공유</td></tr><tr class="BasicTypeTable_td__r_Im5"><td>예시</td><td>let x = 5; x = 10;</td><td>let obj = {a: 1}; obj.a = 2;</td></tr></tbody></table><h2 class="heading_h2__fsXMw">참조형의 깊은 복사(Deep Copy)</h2><div class="postDetail_content__OTeO2">참조형의 기본 복사는 얕은 복사(Shallow Copy)로, 동일한 객체를 참조하게 됩니다. 객체를 독립적으로 복사하려면 깊은 복사가 필요합니다.</div><h4 class="heading_h4__ZTbA0">📝 <!-- -->얕은 복사 vs 깊은 복사</h4><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">// 얕은 복사
let original = { name: "Bob", info: { age: 40 } };
let shallowCopy = Object.assign({}, original);

shallowCopy.name = "Charlie";
shallowCopy.info.age = 50;

console.log(original); // { name: "Bob", info: { age: 50 } } (info는 여전히 공유됨)
console.log(shallowCopy); // { name: "Charlie", info: { age: 50 } }

// 깊은 복사
let deepCopy = JSON.parse(JSON.stringify(original));

deepCopy.name = "David";
deepCopy.info.age = 60;

console.log(original); // { name: "Bob", info: { age: 50 } } (변경되지 않음)
console.log(deepCopy); // { name: "David", info: { age: 60 } }</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">얕은 복사(Object.assign)는 최상위 프로퍼티만 복사하고, 중첩 객체(info)는 여전히 원본과 공유됩니다.</li><li class="liststyle_dot__SMzS4">깊은 복사(JSON.parse(JSON.stringify()))는 객체 전체를 새로 생성하여 독립적인 복사본을 만듭니다.</li></ul><h4 class="heading_h4__ZTbA0">📝 <!-- -->원시값 활용</h4><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">function updateScore(score) {
    score = score + 10; // 새로운 메모리 공간에 값을 저장
    return score;
}

let playerScore = 50;
console.log(updateScore(playerScore)); // 60
console.log(playerScore); // 50 (원본 값은 변경되지 않음)</pre></div></div><div class="postDetail_content__OTeO2">원시값은 함수 내부에서 수정해도 원본에 영향을 주지 않습니다.</div><h4 class="heading_h4__ZTbA0">📝 <!-- -->참조형 활용</h4><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">function updateProfile(profile) {
    profile.age += 1; // 동일한 객체를 직접 수정
    profile.city = "Busan"; // 동적 프로퍼티 추가
}

let user = { name: "Eve", age: 28 };
updateProfile(user);

console.log(user); // { name: "Eve", age: 29, city: "Busan" }</pre></div></div><div class="postDetail_content__OTeO2">참조형은 함수 내부에서 수정하면 원본 객체가 변경됩니다. user 원본 객체가 { name: "Eve", age: 28 } 에서 { name: "Eve", age: 29, city: "Busan" } 으로 변경 됨</div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4"><b>원시값</b>: 값 자체를 복사, 불변, 재할당 시 새로운 메모리 공간 사용.</li><li class="liststyle_dot__SMzS4"><b>참조형</b>: 메모리 주소를 복사, 가변, 객체 내부를 직접 수정 가능 (프로퍼티 추가/갱신/삭제).</li><li class="liststyle_dot__SMzS4">원시값은 독립적이고 안전하지만 수정이 제한적이며, 참조형은 유연하지만 공유 메모리로 인해 주의가 필요합니다.</li><li class="liststyle_dot__SMzS4">깊은 복사를 통해 참조형의 독립적인 복사가 가능합니다.</li></ul><div class="postDetail_content__OTeO2">자바스크립트에서 깊은 복사(Deep Copy)를 하는 방법은 여러 가지가 있습니다. 상황에 따라 간단한 객체부터 복잡한 객체까지 처리할 수 있습니다. 아래에 대표적인 방법과 예제를 정리해 보겠습니다.</div><div class="postDetail_content__OTeO2">구조적 복제 (Structured Clone)</div><div class="postDetail_content__OTeO2">structuredClone()은 브라우저 환경(Node.js 17+ 또는 최신 브라우저)에서 제공되는 깊은 복사를 위한 네이티브 메서드입니다. 이 방법은 JSON 방식보다 더 다양한 데이터 타입(예: Date, Map, Set 등)을 처리할 수 있습니다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">// 원본 객체
let original = {
  name: "Bob",
  info: { age: 50, date: new Date() },
  hobbies: ["reading", "gaming"]
};

// 깊은 복사 (structuredClone 사용)
let deepCopy = structuredClone(original);

// 복사본 수정
deepCopy.name = "David";
deepCopy.info.age = 60;
deepCopy.hobbies.push("coding");

console.log(original);
// 출력: { name: "Bob", info: { age: 50, date: [Date] }, hobbies: ["reading", "gaming"] }

console.log(deepCopy);
// 출력: { name: "David", info: { age: 60, date: [Date] }, hobbies: ["reading", "gaming", "coding"] }</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">structuredClone()은 객체와 그 하위 구조를 완전히 독립적으로 복사합니다.</li><li class="liststyle_dot__SMzS4">원본 객체의 info.age나 hobbies 배열이 수정되지 않음을 확인할 수 있습니다.</li><li class="liststyle_dot__SMzS4">Date 객체도 별도의 인스턴스로 복사되며, JSON 방식과 달리 손실 없이 복사됩니다.</li></ul><h4 class="heading_h4__ZTbA0">📝 <!-- -->재귀 함수를 사용한 깊은 복사</h4><div class="postDetail_content__OTeO2">직접 깊은 복사를 구현하는 방법으로, 객체와 배열을 재귀적으로 순회하며 복사합니다. 이 방법은 커스터마이징이 가능하고, 특정 데이터 타입을 추가로 처리할 수 있습니다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">// 깊은 복사 함수
function deepCopy(obj) {
  // 원시값이거나 null인 경우 그대로 반환
  if (obj === null || typeof obj !== "object") {
    return obj;
  }

  // 배열인 경우
  if (Array.isArray(obj)) {
    return obj.map(item => deepCopy(item));
  }

  // 객체인 경우
  const copy = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      copy[key] = deepCopy(obj[key]);
    }
  }
  return copy;
}</pre></div></div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">

// 원본 객체
let original = {
  name: "Bob",
  info: { age: 50 },
  hobbies: ["reading", "gaming"]
};

// 깊은 복사
let deepCopy = deepCopy(original);

// 복사본 수정
deepCopy.name = "David";
deepCopy.info.age = 60;
deepCopy.hobbies.push("coding");

console.log(original);
// 출력: { name: "Bob", info: { age: 50 }, hobbies: ["reading", "gaming"] }

console.log(deepCopy);
// 출력: { name: "David", info: { age: 60 }, hobbies: ["reading", "gaming", "coding"] }</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">deepCopy 함수는 재귀적으로 객체의 모든 프로퍼티를 복사합니다.</li><li class="liststyle_dot__SMzS4">배열과 객체를 구분하여 처리하며, 원시값은 그대로 반환합니다.</li><li class="liststyle_dot__SMzS4">이 방식은 JSON 방식의 한계를 극복하고, 함수나 undefined 같은 값도 커스터마이징하여 처리할 수 있습니다(필요 시 추가 로직 구현 가능).</li></ul><h4 class="heading_h4__ZTbA0">📝 <!-- -->Lodash 라이브러리의 _.cloneDeep</h4><div class="postDetail_content__OTeO2">실제 프로젝트에서는 Lodash 같은 라이브러리를 사용하는 경우가 많습니다. Lodash의 _.cloneDeep 메서드는 깊은 복사를 간편하게 수행하며, 다양한 데이터 타입을 안전하게 처리합니다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">// Lodash를 사용하기 위해 필요 (HTML에서는 CDN 또는 모듈로 임포트)
// 예: <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>

// 원본 객체
let original = {
  name: "Bob",
  info: { age: 50 },
  hobbies: ["reading", "gaming"]
};

// 깊은 복사 (Lodash 사용)
let deepCopy = _.cloneDeep(original);

// 복사본 수정
deepCopy.name = "David";
deepCopy.info.age = 60;
deepCopy.hobbies.push("coding");

console.log(original);
// 출력: { name: "Bob", info: { age: 50 }, hobbies: ["reading", "gaming"] }

console.log(deepCopy);
// 출력: { name: "David", info: { age: 60 }, hobbies: ["reading", "gaming", "coding"] }</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">_.cloneDeep은 Lodash 라이브러리의 깊은 복사 메서드로, 복잡한 객체 구조를 안전하게 복사합니다.</li><li class="liststyle_dot__SMzS4">JSON 방식보다 다양한 데이터 타입(예: 함수, RegExp, Map)을 지원하며, 성능도 최적화되어 있습니다.</li><li class="liststyle_dot__SMzS4">실제 프로젝트에서 신뢰할 수 있는 방법 중 하나입니다.</li></ul><table class="BasicTypeTable_table__Emrp_"><thead><tr><th><div class="headerAction_element__WDAVu"><div class="headerAction_txt__tbutB">방법</div></div></th><th><div class="headerAction_element__WDAVu"><div class="headerAction_txt__tbutB">장점</div></div></th><th><div class="headerAction_element__WDAVu"><div class="headerAction_txt__tbutB">단점</div></div></th></tr></thead><tbody><tr class="BasicTypeTable_td__r_Im5"><td>JSON.parse(JSON.stringify())</td><td>간단하고 별도 라이브러리 불필요</td><td>undefined, 함수, Date 등 일부 데이터 타입 손실 가능</td></tr><tr class="BasicTypeTable_td__r_Im5"><td>structuredClone()</td><td>네이티브 API, 다양한 데이터 타입 지원, 손실 없음</td><td>브라우저/Node.js 버전 의존성 (구형 환경에서 동작하지 않을 수 있음)</td></tr><tr class="BasicTypeTable_td__r_Im5"><td>재귀 함수 (deepCopy)</td><td>커스터마이징 가능, 모든 데이터 타입 처리 가능</td><td>직접 구현해야 하며, 복잡한 객체에서 성능 고려 필요</td></tr><tr class="BasicTypeTable_td__r_Im5"><td>Lodash _.cloneDeep</td><td>신뢰성 높음, 다양한 데이터 타입 지원, 테스트 완료된 라이브러리</td><td>외부 라이브러리 의존성 추가 필요</td></tr></tbody></table><h4 class="heading_h4__ZTbA0">📝 <!-- -->복잡한 객체(중첩 객체, 배열, Date, Map 포함)를 사용한 예제</h4><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">// 원본 객체 (복잡한 구조)
let original = {
  name: "Bob",
  info: {
    age: 50,
    birthday: new Date("1975-01-01"),
    address: { city: "Seoul", country: "Korea" }
  },
  hobbies: ["reading", { type: "gaming", level: "pro" }],
  metadata: new Map([["id", 123], ["active", true]])
};

// 깊은 복사
let deepCopy = structuredClone(original);

// 복사본 수정
deepCopy.name = "David";
deepCopy.info.age = 60;
deepCopy.info.address.city = "Busan";
deepCopy.hobbies[1].level = "expert";
deepCopy.metadata.set("id", 456);

console.log(original);
// 출력: {
//   name: "Bob",
//   info: { age: 50, birthday: [Date 1975-01-01], address: { city: "Seoul", country: "Korea" } },
//   hobbies: ["reading", { type: "gaming", level: "pro" }],
//   metadata: Map { "id" => 123, "active" => true }
// }

console.log(deepCopy);
// 출력: {
//   name: "David",
//   info: { age: 60, birthday: [Date 1975-01-01], address: { city: "Busan", country: "Korea" } },
//   hobbies: ["reading", { type: "gaming", level: "expert" }],
//   metadata: Map { "id" => 456, "active" => true }
// }</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">중첩 객체(address), 배열 내 객체(hobbies[1]), Date, Map 등 다양한 데이터 타입이 포함된 복잡한 객체를 복사했습니다.</li><li class="liststyle_dot__SMzS4">structuredClone은 모든 수준에서 독립적인 복사본을 생성하여 원본이 수정되지 않음을 보여줍니다.</li></ul><div class="row"><nav class="postNavigation_post_navigation__Zbcpm"><a class="postNavigation_post_navgation_common__q8_Hl postNavigation_post_navigation_pre__SPHh_ postNavigation_post_not_cursor___7LQp" aria-label="Older" href="/posts/64"><p class="postNavigation_post_navigation_text__3cjma">-</p></a><a class="postNavigation_post_navgation_common__q8_Hl postNavigation_post_navigation_next__yVEzg" aria-label="Newer" href="/posts/62"><p class="postNavigation_post_navigation_text__3cjma">[TECH-QA] 리액트 리렌더링</p></a></nav></div><div class="footer_footer_container__MsSvO"><footer class="footer_footer__AwYty"><p class="footer_copylight___J5l0">© 2024 <!-- -->베짱이가 되고싶은 개미。<!-- --> Some rights reserved.</p><p class="footer_theme__bwXbg">portfolio v1.0.0-alpha.3</p></footer></div></main><aside class="panel_panel_wrapper__bjPKT"><div class="panel_access__NiFhF"><section class="panel_access_lastmod__v6pgX"><h2 class="panel_panel_heading__n9W6w">Recently Updated</h2><ul class="panel_panel_recently__U0_Zp"><li class="panel_text_truncate__SFfHf"><a href="/posts/63">[TECH-QA] 원시값과 참조형</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/62">[TECH-QA] 리액트 리렌더링</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/61">[TECH-QA] 프로토타입(Prototype)과 프로토타입체이닝</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/60">[TECH-QA] JWT(JSON Web Token) 인증 방식</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/58">[TECH-QA] 컴파일(Compile)과 빌드(Build) 그리고 React 웹팩(Webpack)과 바벨(Babel)</a></li></ul></section><section class="panel_panel_tag_contain__h_Bwi"><h2 class="panel_panel_heading__n9W6w">Trending Tags</h2><div class="panel_panel_tag__eNz5c"><a class="panel_tag__3AiMO" href="/tags/JavaScript">JavaScript</a><a class="panel_tag__3AiMO" href="/tags/TECH-QA">TECH-QA</a><a class="panel_tag__3AiMO" href="/tags/react">react</a><a class="panel_tag__3AiMO" href="/tags/리렌더링">리렌더링</a><a class="panel_tag__3AiMO" href="/tags/Prototype">Prototype</a><a class="panel_tag__3AiMO" href="/tags/JWT">JWT</a><a class="panel_tag__3AiMO" href="/tags/React">React</a><a class="panel_tag__3AiMO" href="/tags/English">English</a><a class="panel_tag__3AiMO" href="/tags/midjourney">midjourney</a><a class="panel_tag__3AiMO" href="/tags/스키너의 심리상자 열기">스키너의 심리상자 열기</a><a class="panel_tag__3AiMO" href="/tags/독서">독서</a><a class="panel_tag__3AiMO" href="/tags/next">next</a><a class="panel_tag__3AiMO" href="/tags/지연로딩">지연로딩</a><a class="panel_tag__3AiMO" href="/tags/Lazy-loading">Lazy-loading</a><a class="panel_tag__3AiMO" href="/tags/CSS">CSS</a><a class="panel_tag__3AiMO" href="/tags/Tailwind">Tailwind</a><a class="panel_tag__3AiMO" href="/tags/mysql">mysql</a><a class="panel_tag__3AiMO" href="/tags/database">database</a><a class="panel_tag__3AiMO" href="/tags/TDD">TDD</a><a class="panel_tag__3AiMO" href="/tags/콜백함수">콜백함수</a><a class="panel_tag__3AiMO" href="/tags/browser">browser</a><a class="panel_tag__3AiMO" href="/tags/HTTP-Protocol">HTTP-Protocol</a><a class="panel_tag__3AiMO" href="/tags/git">git</a><a class="panel_tag__3AiMO" href="/tags/FrontEnd">FrontEnd</a><a class="panel_tag__3AiMO" href="/tags/Vue">Vue</a></div></section></div></aside></div></div></div><script src="/_next/static/chunks/webpack-9a0d20cac54890b0.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/92e7b59ea9c09c1b.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/css/04d20c09b3119d43.css\",\"style\",{\"crossOrigin\":\"\"}]\n4:HL[\"/_next/static/css/9149e1f00c2ba43a.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"5:I[7690,[],\"\"]\n7:I[5250,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"216\",\"static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-0227d192c056155e.js\"],\"\"]\n8:I[8843,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"216\",\"static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-0227d192c056155e.js\"],\"\"]\n9:I[2973,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"216\",\"static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-0227d192c056155e.js\"],\"\"]\nb:I[777,[\"250\",\"static/ch"])</script><script>self.__next_f.push([1,"unks/250-8b90be581650ff9d.js\",\"216\",\"static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-0227d192c056155e.js\"],\"\"]\nc:I[5613,[],\"\"]\nf:I[1778,[],\"\"]\n13:I[5210,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"304\",\"static/chunks/304-2ef64042fd5d1e1c.js\",\"730\",\"static/chunks/730-f56ebe909f1c8bdb.js\",\"516\",\"static/chunks/516-eaf4d30099c06448.js\",\"927\",\"static/chunks/927-14bb68f63c9c7538.js\",\"338\",\"static/chunks/338-f2b637e42a7ca177.js\",\"464\",\"static/chunks/app/(layoutCase)/layout-66e4d36269f645f8."])</script><script>self.__next_f.push([1,"js\"],\"\"]\n1a:I[8955,[],\"\"]\na:T43f,"])</script><script>self.__next_f.push([1,"// 원본 객체 (복잡한 구조)\nlet original = {\n  name: \"Bob\",\n  info: {\n    age: 50,\n    birthday: new Date(\"1975-01-01\"),\n    address: { city: \"Seoul\", country: \"Korea\" }\n  },\n  hobbies: [\"reading\", { type: \"gaming\", level: \"pro\" }],\n  metadata: new Map([[\"id\", 123], [\"active\", true]])\n};\n\n// 깊은 복사\nlet deepCopy = structuredClone(original);\n\n// 복사본 수정\ndeepCopy.name = \"David\";\ndeepCopy.info.age = 60;\ndeepCopy.info.address.city = \"Busan\";\ndeepCopy.hobbies[1].level = \"expert\";\ndeepCopy.metadata.set(\"id\", 456);\n\nconsole.log(original);\n// 출력: {\n//   name: \"Bob\",\n//   info: { age: 50, birthday: [Date 1975-01-01], address: { city: \"Seoul\", country: \"Korea\" } },\n//   hobbies: [\"reading\", { type: \"gaming\", level: \"pro\" }],\n//   metadata: Map { \"id\" =\u003e 123, \"active\" =\u003e true }\n// }\n\nconsole.log(deepCopy);\n// 출력: {\n//   name: \"David\",\n//   info: { age: 60, birthday: [Date 1975-01-01], address: { city: \"Busan\", country: \"Korea\" } },\n//   hobbies: [\"reading\", { type: \"gaming\", level: \"expert\" }],\n//   metadata: Map { \"id\" =\u003e 456, \"active\" =\u003e true }\n// }"])</script><script>self.__next_f.push([1,"d:[\"tagname\",\"%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9\",\"d\"]\ne:[\"postid\",\"63\",\"d\"]\n10:\"$L11\"\n14:[]\n15:{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"}\n16:{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"}\n17:{\"display\":\"inline-b"])</script><script>self.__next_f.push([1,"lock\"}\n18:{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0}\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/92e7b59ea9c09c1b.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"RMW_GLxxDNzkAX35FwgHj\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/tags/%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9/63\",\"initialTree\":[\"\",{\"children\":[\"(layoutCase)\",{\"children\":[\"tags\",{\"children\":[[\"tagname\",\"%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9\",\"d\"],{\"children\":[[\"postid\",\"63\",\"d\"],{\"children\":[\"__PAGE__?{\\\"tagname\\\":\\\"지연로딩\\\",\\\"postid\\\":\\\"63\\\"}\",{}]}]}]}],\"search\":[\"__DEFAULT__\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"(layoutCase)\",{\"children\":[\"tags\",{\"children\":[[\"tagname\",\"%EC%A7%80%EC%97%B0%EB%A1%9C%EB%94%A9\",\"d\"],{\"children\":[[\"postid\",\"63\",\"d\"],{\"children\":[\"__PAGE__\",{},[\"$L6\",[[[\"$\",\"article\",null,{\"className\":\"$undefined\",\"children\":[\"$\",\"header\",null,{\"children\":[\"$\",\"h1\",null,{\"className\":\"postUserInfo_h1__uhAqy\",\"children\":\"[TECH-QA] 원시값과 참조형\"}]}]}],[\"$\",\"div\",null,{\"className\":\"postUserInfo_post_meta__ABvuC\",\"children\":[[\"$\",\"span\",null,{\"children\":[\"Posted\",\" \",[\"$\",\"time\",null,{\"className\":\"postUserInfo_time__2exyR\",\"children\":[\"17 hours\",\" \"]}]]}],[\"$\",\"span\",null,{\"className\":\"postUserInfo_update__f345P\",\"children\":[\"Updated\",\" \",[\"$\",\"time\",null,{\"className\":\"postUserInfo_time__2exyR\",\"children\":\"17 hours\"}]]}]]}],[\"$\",\"div\",null,{\"children\":[\"$\",\"span\",null,{\"className\":\"postUserInfo_post_meta__ABvuC\",\"children\":[\"By\",\" \",[\"$\",\"em\",null,{\"children\":[\"$\",\"$L7\",null,{\"href\":\"https://nam-yeun-hwa.github.io/\",\"className\":\"postUserInfo_author__fVGYM\",\"children\":\"베짱이가 되고싶은 개미。\"}]}]]}]}]],[[\"$\",\"div\",\"0\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"자바스크립트에서 원시값(Primitive Values)과 참조형(Reference Types)의 동작 방식, 그리고 이들의 불변성(Immutability)과 가변성(Mutability)에 대해 설명 해 보겠습니다.\"}}],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"children\":\"원시값 (Primitive Values)\"}],false,false],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e정의\u003c/b\u003e : 원시값은 더 이상 쪼갤 수 없는 기본 데이터 타입으로, 자바스크립트에서는 undefined, null, boolean, number, bigint, string, symbol이 이에 해당합니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e복제 방식\u003c/b\u003e : 다른 변수에 원시값을 복사할 때, 해당 값이 그대로 복사되어 새로운 변수에 저장됩니다. 이때 메모리 주소 개념은 관여하지 않고, \u003cb\u003e단순히 값만 복사\u003c/b\u003e됩니다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e불변성\u003c/b\u003e : 원시값은 불변값입니다. 값을 변경하려고 하면, 기존 메모리 공간의 값을 수정하는 대신 새로운 메모리 공간에 새로운 값을 저장하고, 변수가 참조하던 메모리 주소를 변경합니다.\"}}]]}],[\"$\",\"$L8\",\"3\",{\"code\":\"let a = 10; // a는 숫자 10을 저장\\nlet b = a;  // b에 a의 값 10을 복사 (독립적인 메모리 공간)\\n\\nconsole.log(a); // 10\\nconsole.log(b); // 10\\n\\nb = 20; // b에 새로운 값 20을 할당 (새로운 메모리 공간 사용)\\nconsole.log(a); // 10 (a는 여전히 10을 참조)\\nconsole.log(b); // 20\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"b = a를 실행하면, a의 값 10이 복사되어 b에 저장됩니다. 이때 \u003cb\u003ea와 b는 각각 독립적인 메모리 공간\u003c/b\u003e을 가리킵니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"b = 20으로 값을 변경하면, b는 새로운 메모리 공간에 20을 저장하고 그 주소를 참조합니다. a는 영향을 받지 않습니다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"원시값은 불변적이므로, a나 b의 값을 직접 수정하는 대신 새로운 값을 메모리에 할당합니다.\"}}]]}],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"children\":\"참조형 (Reference Types)\"}],false,false],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e정의\u003c/b\u003e : 참조형은 \u003cspan class=\\\"point\\\"\u003e객체(Object)\u003c/span\u003e, \u003cspan class=\\\"point\\\"\u003e배열(Array)\u003c/span\u003e, \u003cspan class=\\\"point\\\"\u003e함수(Function)\u003c/span\u003e 등으로, 여러 값을 하나의 단위로 묶은 데이터 타입입니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e복제 방식\u003c/b\u003e : 참조형은 값이 담긴 \u003cb\u003e메모리 주소를 복제\u003c/b\u003e합니다. 즉, 변수는 실제 데이터(객체)가 저장된 메모리 주소를 가리키며, 복사 시 이 주소를 복사합니다. \u003cspan class=\\\"point\\\"\u003e따라서 복사된 변수는 원본 객체와 동일한 메모리 주소를 참조\u003c/span\u003e합니다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e가변성\u003c/b\u003e : 참조형은 가변값입니다. 객체가 저장된 메모리 공간은 수정 가능하며, 변수는 해당 객체를 직접 변경할 수 있습니다. 객체의 프로퍼티를 추가, 갱신, 삭제할 수 있습니다.\"}}]]}],[\"$\",\"$L8\",\"7\",{\"code\":\"let obj1 = { name: \\\"Alice\\\", age: 25 }; // obj1은 객체의 메모리 주소를 참조\\nlet obj2 = obj1; // obj2는 obj1과 동일한 메모리 주소를 참조\\n\\nconsole.log(obj1); // { name: \\\"Alice\\\", age: 25 }\\nconsole.log(obj2); // { name: \\\"Alice\\\", age: 25 }\\n\\n// obj2를 통해 객체 수정\\nobj2.age = 30;\\nobj2.city = \\\"Seoul\\\"; // 동적으로 프로퍼티 추가\\n\\nconsole.log(obj1); // { name: \\\"Alice\\\", age: 30, city: \\\"Seoul\\\" }\\nconsole.log(obj2); // { name: \\\"Alice\\\", age: 30, city: \\\"Seoul\\\" }\\n\\n// 프로퍼티 삭제\\ndelete obj1.city;\\n\\nconsole.log(obj1); // { name: \\\"Alice\\\", age: 30 }\\nconsole.log(obj2); // { name: \\\"Alice\\\", age: 30 }\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"obj2 = obj1은 obj1이 참조하는 객체의 메모리 주소를 obj2에 복사합니다. 따라서 obj1과 obj2는 동일한 객체를 가리킵니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"obj2.age = 30 또는 obj2.city = \\\"Seoul\\\"로 객체를 수정하면, 동일한 메모리 공간을 참조하는 obj1에도 변경 사항이 반영됩니다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"참조형은 가변적이므로, 객체의 프로퍼티를 동적으로 추가(city), 갱신(age), 삭제(delete obj1.city)할 수 있습니다.\"}}]]}],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"children\":\"원시값 vs 참조형 비교\"}],false,false],[\"$\",\"$L9\",\"10\",{\"header\":[{\"accessorKey\":\"feature\",\"header\":\"특징\"},{\"accessorKey\":\"primitive\",\"header\":\"원시값 (Primitive)\"},{\"accessorKey\":\"reference\",\"header\":\"참조형 (Reference)\"}],\"contents\":[{\"feature\":\"데이터 타입\",\"primitive\":\"number, string, boolean 등\",\"reference\":\"object, array, function 등\"},{\"feature\":\"복제 방식\",\"primitive\":\"값 자체 복사\",\"reference\":\"메모리 주소 복사\"},{\"feature\":\"변경 가능성\",\"primitive\":\"불변 (새로운 값으로 교체)\",\"reference\":\"가변 (객체 내부 수정 가능)\"},{\"feature\":\"메모리 동작\",\"primitive\":\"새로운 메모리 공간 생성\",\"reference\":\"동일한 메모리 공간 공유\"},{\"feature\":\"예시\",\"primitive\":\"let x = 5; x = 10;\",\"reference\":\"let obj = {a: 1}; obj.a = 2;\"}]}],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"children\":\"참조형의 깊은 복사(Deep Copy)\"}],false,false],[\"$\",\"div\",\"12\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"참조형의 기본 복사는 얕은 복사(Shallow Copy)로, 동일한 객체를 참조하게 됩니다. 객체를 독립적으로 복사하려면 깊은 복사가 필요합니다.\"}}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"children\":[\"📝 \",\"얕은 복사 vs 깊은 복사\"]}]],[\"$\",\"$L8\",\"14\",{\"code\":\"// 얕은 복사\\nlet original = { name: \\\"Bob\\\", info: { age: 40 } };\\nlet shallowCopy = Object.assign({}, original);\\n\\nshallowCopy.name = \\\"Charlie\\\";\\nshallowCopy.info.age = 50;\\n\\nconsole.log(original); // { name: \\\"Bob\\\", info: { age: 50 } } (info는 여전히 공유됨)\\nconsole.log(shallowCopy); // { name: \\\"Charlie\\\", info: { age: 50 } }\\n\\n// 깊은 복사\\nlet deepCopy = JSON.parse(JSON.stringify(original));\\n\\ndeepCopy.name = \\\"David\\\";\\ndeepCopy.info.age = 60;\\n\\nconsole.log(original); // { name: \\\"Bob\\\", info: { age: 50 } } (변경되지 않음)\\nconsole.log(deepCopy); // { name: \\\"David\\\", info: { age: 60 } }\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"얕은 복사(Object.assign)는 최상위 프로퍼티만 복사하고, 중첩 객체(info)는 여전히 원본과 공유됩니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"깊은 복사(JSON.parse(JSON.stringify()))는 객체 전체를 새로 생성하여 독립적인 복사본을 만듭니다.\"}}]]}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"children\":[\"📝 \",\"원시값 활용\"]}]],[\"$\",\"$L8\",\"17\",{\"code\":\"function updateScore(score) {\\n    score = score + 10; // 새로운 메모리 공간에 값을 저장\\n    return score;\\n}\\n\\nlet playerScore = 50;\\nconsole.log(updateScore(playerScore)); // 60\\nconsole.log(playerScore); // 50 (원본 값은 변경되지 않음)\"}],[\"$\",\"div\",\"18\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"원시값은 함수 내부에서 수정해도 원본에 영향을 주지 않습니다.\"}}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"children\":[\"📝 \",\"참조형 활용\"]}]],[\"$\",\"$L8\",\"20\",{\"code\":\"function updateProfile(profile) {\\n    profile.age += 1; // 동일한 객체를 직접 수정\\n    profile.city = \\\"Busan\\\"; // 동적 프로퍼티 추가\\n}\\n\\nlet user = { name: \\\"Eve\\\", age: 28 };\\nupdateProfile(user);\\n\\nconsole.log(user); // { name: \\\"Eve\\\", age: 29, city: \\\"Busan\\\" }\"}],[\"$\",\"div\",\"21\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"참조형은 함수 내부에서 수정하면 원본 객체가 변경됩니다. user 원본 객체가 { name: \\\"Eve\\\", age: 28 } 에서 { name: \\\"Eve\\\", age: 29, city: \\\"Busan\\\" } 으로 변경 됨\"}}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e원시값\u003c/b\u003e: 값 자체를 복사, 불변, 재할당 시 새로운 메모리 공간 사용.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e참조형\u003c/b\u003e: 메모리 주소를 복사, 가변, 객체 내부를 직접 수정 가능 (프로퍼티 추가/갱신/삭제).\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"원시값은 독립적이고 안전하지만 수정이 제한적이며, 참조형은 유연하지만 공유 메모리로 인해 주의가 필요합니다.\"}}],[\"$\",\"li\",\"3\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"깊은 복사를 통해 참조형의 독립적인 복사가 가능합니다.\"}}]]}],[\"$\",\"div\",\"23\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"자바스크립트에서 깊은 복사(Deep Copy)를 하는 방법은 여러 가지가 있습니다. 상황에 따라 간단한 객체부터 복잡한 객체까지 처리할 수 있습니다. 아래에 대표적인 방법과 예제를 정리해 보겠습니다.\"}}],[\"$\",\"div\",\"24\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"구조적 복제 (Structured Clone)\"}}],[\"$\",\"div\",\"25\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"structuredClone()은 브라우저 환경(Node.js 17+ 또는 최신 브라우저)에서 제공되는 깊은 복사를 위한 네이티브 메서드입니다. 이 방법은 JSON 방식보다 더 다양한 데이터 타입(예: Date, Map, Set 등)을 처리할 수 있습니다.\"}}],[\"$\",\"$L8\",\"26\",{\"code\":\"// 원본 객체\\nlet original = {\\n  name: \\\"Bob\\\",\\n  info: { age: 50, date: new Date() },\\n  hobbies: [\\\"reading\\\", \\\"gaming\\\"]\\n};\\n\\n// 깊은 복사 (structuredClone 사용)\\nlet deepCopy = structuredClone(original);\\n\\n// 복사본 수정\\ndeepCopy.name = \\\"David\\\";\\ndeepCopy.info.age = 60;\\ndeepCopy.hobbies.push(\\\"coding\\\");\\n\\nconsole.log(original);\\n// 출력: { name: \\\"Bob\\\", info: { age: 50, date: [Date] }, hobbies: [\\\"reading\\\", \\\"gaming\\\"] }\\n\\nconsole.log(deepCopy);\\n// 출력: { name: \\\"David\\\", info: { age: 60, date: [Date] }, hobbies: [\\\"reading\\\", \\\"gaming\\\", \\\"coding\\\"] }\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"structuredClone()은 객체와 그 하위 구조를 완전히 독립적으로 복사합니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"원본 객체의 info.age나 hobbies 배열이 수정되지 않음을 확인할 수 있습니다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"Date 객체도 별도의 인스턴스로 복사되며, JSON 방식과 달리 손실 없이 복사됩니다.\"}}]]}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"children\":[\"📝 \",\"재귀 함수를 사용한 깊은 복사\"]}]],[\"$\",\"div\",\"29\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"직접 깊은 복사를 구현하는 방법으로, 객체와 배열을 재귀적으로 순회하며 복사합니다. 이 방법은 커스터마이징이 가능하고, 특정 데이터 타입을 추가로 처리할 수 있습니다.\"}}],[\"$\",\"$L8\",\"30\",{\"code\":\"// 깊은 복사 함수\\nfunction deepCopy(obj) {\\n  // 원시값이거나 null인 경우 그대로 반환\\n  if (obj === null || typeof obj !== \\\"object\\\") {\\n    return obj;\\n  }\\n\\n  // 배열인 경우\\n  if (Array.isArray(obj)) {\\n    return obj.map(item =\u003e deepCopy(item));\\n  }\\n\\n  // 객체인 경우\\n  const copy = {};\\n  for (const key in obj) {\\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\\n      copy[key] = deepCopy(obj[key]);\\n    }\\n  }\\n  return copy;\\n}\"}],[\"$\",\"$L8\",\"31\",{\"code\":\"\\n// 원본 객체\\nlet original = {\\n  name: \\\"Bob\\\",\\n  info: { age: 50 },\\n  hobbies: [\\\"reading\\\", \\\"gaming\\\"]\\n};\\n\\n// 깊은 복사\\nlet deepCopy = deepCopy(original);\\n\\n// 복사본 수정\\ndeepCopy.name = \\\"David\\\";\\ndeepCopy.info.age = 60;\\ndeepCopy.hobbies.push(\\\"coding\\\");\\n\\nconsole.log(original);\\n// 출력: { name: \\\"Bob\\\", info: { age: 50 }, hobbies: [\\\"reading\\\", \\\"gaming\\\"] }\\n\\nconsole.log(deepCopy);\\n// 출력: { name: \\\"David\\\", info: { age: 60 }, hobbies: [\\\"reading\\\", \\\"gaming\\\", \\\"coding\\\"] }\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"deepCopy 함수는 재귀적으로 객체의 모든 프로퍼티를 복사합니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"배열과 객체를 구분하여 처리하며, 원시값은 그대로 반환합니다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"이 방식은 JSON 방식의 한계를 극복하고, 함수나 undefined 같은 값도 커스터마이징하여 처리할 수 있습니다(필요 시 추가 로직 구현 가능).\"}}]]}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"children\":[\"📝 \",\"Lodash 라이브러리의 _.cloneDeep\"]}]],[\"$\",\"div\",\"34\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"실제 프로젝트에서는 Lodash 같은 라이브러리를 사용하는 경우가 많습니다. Lodash의 _.cloneDeep 메서드는 깊은 복사를 간편하게 수행하며, 다양한 데이터 타입을 안전하게 처리합니다.\"}}],[\"$\",\"$L8\",\"35\",{\"code\":\"// Lodash를 사용하기 위해 필요 (HTML에서는 CDN 또는 모듈로 임포트)\\n// 예: \u003cscript src=\\\"https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js\\\"\u003e\u003c/script\u003e\\n\\n// 원본 객체\\nlet original = {\\n  name: \\\"Bob\\\",\\n  info: { age: 50 },\\n  hobbies: [\\\"reading\\\", \\\"gaming\\\"]\\n};\\n\\n// 깊은 복사 (Lodash 사용)\\nlet deepCopy = _.cloneDeep(original);\\n\\n// 복사본 수정\\ndeepCopy.name = \\\"David\\\";\\ndeepCopy.info.age = 60;\\ndeepCopy.hobbies.push(\\\"coding\\\");\\n\\nconsole.log(original);\\n// 출력: { name: \\\"Bob\\\", info: { age: 50 }, hobbies: [\\\"reading\\\", \\\"gaming\\\"] }\\n\\nconsole.log(deepCopy);\\n// 출력: { name: \\\"David\\\", info: { age: 60 }, hobbies: [\\\"reading\\\", \\\"gaming\\\", \\\"coding\\\"] }\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"_.cloneDeep은 Lodash 라이브러리의 깊은 복사 메서드로, 복잡한 객체 구조를 안전하게 복사합니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"JSON 방식보다 다양한 데이터 타입(예: 함수, RegExp, Map)을 지원하며, 성능도 최적화되어 있습니다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"실제 프로젝트에서 신뢰할 수 있는 방법 중 하나입니다.\"}}]]}],[\"$\",\"$L9\",\"37\",{\"header\":[{\"accessorKey\":\"method\",\"header\":\"방법\"},{\"accessorKey\":\"advantage\",\"header\":\"장점\"},{\"accessorKey\":\"disadvantage\",\"header\":\"단점\"}],\"contents\":[{\"method\":\"JSON.parse(JSON.stringify())\",\"advantage\":\"간단하고 별도 라이브러리 불필요\",\"disadvantage\":\"undefined, 함수, Date 등 일부 데이터 타입 손실 가능\"},{\"method\":\"structuredClone()\",\"advantage\":\"네이티브 API, 다양한 데이터 타입 지원, 손실 없음\",\"disadvantage\":\"브라우저/Node.js 버전 의존성 (구형 환경에서 동작하지 않을 수 있음)\"},{\"method\":\"재귀 함수 (deepCopy)\",\"advantage\":\"커스터마이징 가능, 모든 데이터 타입 처리 가능\",\"disadvantage\":\"직접 구현해야 하며, 복잡한 객체에서 성능 고려 필요\"},{\"method\":\"Lodash _.cloneDeep\",\"advantage\":\"신뢰성 높음, 다양한 데이터 타입 지원, 테스트 완료된 라이브러리\",\"disadvantage\":\"외부 라이브러리 의존성 추가 필요\"}]}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"children\":[\"📝 \",\"복잡한 객체(중첩 객체, 배열, Date, Map 포함)를 사용한 예제\"]}]],[\"$\",\"$L8\",\"39\",{\"code\":\"$a\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"중첩 객체(address), 배열 내 객체(hobbies[1]), Date, Map 등 다양한 데이터 타입이 포함된 복잡한 객체를 복사했습니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"structuredClone은 모든 수준에서 독립적인 복사본을 생성하여 원본이 수정되지 않음을 보여줍니다.\"}}]]}]],[\"$\",\"$Lb\",null,{\"postid\":63,\"prePostTitle\":\"$undefined\",\"nextPostTile\":{\"id\":62,\"title\":\"[TECH-QA] 리액트 리렌더링\",\"date\":\"2025-04-12 15:34:33\",\"folder\":\"Javascript\",\"tag\":[\"JavaScript\",\"TECH-QA\",\"react\",\"리렌더링\"],\"preview\":\"리액트에서 리렌더링(re-rendering)은 컴포넌트가 다시 그려지는 과정입니다. 즉, 어떤 변화가 발생했을 때, 리액트가 해당 컴포넌트(혹은 그 자식들 포함)를 다시 실행해서 UI를 업데이트하는 걸 말합니다.\",\"post\":[{\"type\":\"normal\",\"value\":\"리액트에서 리렌더링(re-rendering)은 컴포넌트가 다시 그려지는 과정입니다. 즉, 어떤 변화가 발생했을 때, 리액트가 해당 컴포넌트(혹은 그 자식들 포함)를 다시 실행해서 UI를 업데이트하는 걸 말합니다. 리렌더링이 너무 많이 발생하면 성능에 부정적인 영향을 줄 수 있습니다. 특히 대규모 애플리케이션이나 자주 렌더링되는 컴포넌트에서는 주의가 필요합니다. 그래서 이번 글에서는 리액트 리렌더링에 대해 이야기 해보려고 합니다.\"},{\"type\":\"H3\",\"value\":\"언제 리렌더링이 발생할까요?\"},{\"type\":\"stringlist\",\"value\":\"state가 변경될 때\\n\\t\\t\\t\\tprops가 변경될 때\\n\\t\\t\\t\\tcontext 값이 변경될 때\\n\\t\\t\\t\\t부모 컴포넌트가 리렌더링되면 자식도 리렌더링\"},{\"type\":\"normal\",\"value\":\"위와 같은 경우에 리액트 컴포넌트에서는 리렌더링이 발생합니다. 한 컴포넌트에 여러가지 스테이트들이 존재하고 UI에서는 여러 인터렉션(버튼 클릭, 입력, 체크박스 등)이 발생하며 스테이드 값들이 변경될때 컴포넌트는 리렌더링 되고 있다고 생각하면 됩니다.\"},{\"type\":\"emphasis\",\"value\":\"리렌더링된다고 해서 DOM 전체를 다시 그리는 건 아닙니다. 리액트는 \\\"Virtual DOM\\\"을 이용해서 변경된 부분만 최소한으로 UI를 업데이트 하며 컴포넌트에 있는 함수들은 새로 생성됩니다. 예를 들면 아래 코드를 보시면 이해 하실 수 있습니다.\"},{\"type\":\"code\",\"value\":\"const MyComponent = () =\u003e {\\n  const [count, setCount] = useState(0);\\n\\n  const handleClick = () =\u003e setCount(count + 1);\\n\\n  return \u003cbutton onClick={handleClick}\u003e{count}\u003c/button\u003e;\\n};\\n\"},{\"type\":\"normal\",\"value\":\"위 함수가 리렌더링이 일어나면 \"},{\"type\":\"stringlist\",\"value\":\"버튼 클릭 → setCount 호출 → count 값 변경\\n\\n변경된 state로 인해 MyComponent() 함수 전체가 다시 실행됨\\n\\ncount, handleClick, JSX 등이 다시 계산됨\\n\\nVirtual DOM에서 변화 비교 후, 실제 DOM은 필요한 부분만 업데이트됨\"},{\"type\":\"normal\",\"value\":\"위와 같은 일이 이루어 집니다. 여기에서 UI는 최소한으로 부분 업데이트 되며 handleClick 함수는 새로 생성됩니다. 새로 생성된다 함은 함수 객체 자체가 메모리에 새로 만들어지는 것입니다. \"},{\"type\":\"code\",\"value\":\"const handleClick = () =\u003e setCount(count + 1);\"},{\"type\":\"normal\",\"value\":\"위 코드는 함수 표현식(= 함수 리터럴)이기 때문에 이 줄이 실행될 때마다 새로운 함수 객체가 메모리에 만들어집니다. \u003c/br\u003e 코드로 확인해 보겠습니다.\"},{\"type\":\"code\",\"value\":\"const MyComponent = () =\u003e {\\n  const [count, setCount] = useState(0);\\n\\n  const handleClick = () =\u003e setCount(count + 1);\\n\\n  useEffect(() =\u003e {\\n    console.log(\\\"handleClick 함수가 새로 만들어졌어요!\\\");\\n  }, [handleClick]);\\n\\n  return \u003cbutton onClick={handleClick}\u003e{count}\u003c/button\u003e;\\n};\\n\"},{\"type\":\"stringlist\",\"value\":\"버튼을 누르면 setCount로 상태가 바뀌고,\\n\\n컴포넌트가 다시 렌더링됨,\\n\\n그러면 handleClick도 새로 생성됨,\\n\\n따라서 useEffect가 실행됨 → 콘솔에 로그 출력!\"},{\"type\":\"H3\",\"value\":\"그럼 왜 리렌더링 때마다 새로 생성될까요?\"},{\"type\":\"normal\",\"value\":\"리액트 함수형 컴포넌트는 결국 함수이자, 매번 실행되는 실행 단위입니다. 여기서 컴포넌트가 호출되면, 그 내부의 handleClick = () =\u003e { ... }도 다시 실행되는 것입니다.\\n그래서 이 때마다 새로운 함수 객체가 생성되는 것이라고 볼 수 있습니다. 그럼 조금 더 들어가서 리액트 컴포넌트가 리렌더링이 덜 되도록 하는 방법에 대해 생각해 보도록 하겠습니다.\"},{\"type\":\"normal\",\"value\":\"한 컴포넌트에서 여러 기능을 가지고 여러 스테이트들을 관리하던 것을 훅에서 스테이트 값이나 상태 값을 관리하고, 컴포넌트는 순수하게 인터렉션만 처리하도록 설계된 경우, 해당 컴포넌트는 스테이트 변경에 따른 리렌더링을 피할 수 있습니다. 하지만 이게 보장되려면 몇 가지 조건과 주의점이 필요합니다. 아래에서 이 상황을 자세히 분석하고, 왜 리렌더링이 일어나지 않을 수 있는지, 그리고 어떤 경우에 주의해야 하는지 설명하겠습니다. 코드를 통해 살펴 보겠습니다.\"},{\"type\":\"h4\",\"value\":\"[커스텀 훅] usePdfController.js\"},{\"type\":\"code\",\"value\":\"const usePdfController = () =\u003e {\\n  const [file, setFile] = useState(null);\\n  const pdfInputRef = useRef(null);\\n\\n  const handlePDFChange = (event) =\u003e {\\n    const selectedFile = event.target.files[0];\\n    setFile(selectedFile);\\n  };\\n\\n  return { file, pdfInputRef, handlePDFChange };\\n};\"},{\"type\":\"h4\",\"value\":\"[자식 컴포넌트] FileUpload.jsx (인터랙션만 처리)\"},{\"type\":\"code\",\"value\":\"const FileUpload = ({ onChange, InputRef, children }) =\u003e {\\n  return (\\n    \u0026lt;label\u003e\\n      {children}\\n      \u0026lt;input type=\\\"file\\\" ref={InputRef} onChange={onChange} style={{ display: 'none' }} /\u003e\\n    \u0026lt;/label\u003e\\n  );\\n};\\n\"},{\"type\":\"h4\",\"value\":\"[부모 컴포넌트] StampController.jsx\"},{\"type\":\"code\",\"value\":\"const StampController = () =\u003e {\\n  const { file, pdfInputRef, handlePDFChange } = usePdfController();\\n\\n  return (\\n    \u0026lt;div\u003e\\n      \u0026lt;FileUpload InputRef={pdfInputRef} onChange={handlePDFChange}\u003e\\n        PDF 업로드\\n      \u0026lt;/FileUpload\u003e\\n      {file?.name \u0026\u0026 \u0026lt;div\u003e{file.name}\u0026lt;/div\u003e}\\n    \u0026lt;/div\u003e\\n  );\\n};\"},{\"type\":\"stringlist\",\"value\":\"\u003cb\u003e스테이트 관리\u003c/b\u003e: 스테이트는 커스텀 훅(예: usePdfController) 또는 스토어(예: useCanvasStore)에서 관리.\\n\u003cb\u003e인터랙션 컴포넌트\u003c/b\u003e: 특정 컴포넌트(예: FileUpload, Button)는 사용자 인터랙션(클릭, 파일 선택 등)만 처리하고, 스테이트나 상태 값을 직접 소유하지 않음.\\n\u003cb\u003e인터랙션 처리\u003c/b\u003e: 인터랙션은 훅이나 스토어에서 제공하는 함수(예: handlePDFChange, handleDownload)를 호출.\"},{\"type\":\"H3\",\"value\":\"자식 컴포넌트 \u003cFileUpload/\u003e 리렌더링\"},{\"type\":\"h4\",\"value\":\"스테이트 소유 여부\"},{\"type\":\"stringlist\",\"value\":\"자식 컴포넌트 FileUpload은 자체 스테이트를 가지지 않습니다. 따라서 FileUpload 내부에서 useState나 useReducer로 인해 리렌더링이 발생할 가능성이 없습니다.\\n스테이트는 usePdfController에서 관리되며, file 변경은 StampController 같은 부모 컴포넌트에 영향을 줍니다.\"},{\"type\":\"h4\",\"value\":\"Props 안정성\"},{\"type\":\"stringlist\",\"value\":\"자식 컴포넌트 FileUpload가 받는 props(예: onChange, InputRef)가 변경되지 않는 한, React는 이 컴포넌트를 리렌더링하지 않습니다.\\nFileUpload가 props로 받는 handlePDFChange가 메모이제이션되지 않으면, StampController가 리렌더링될 때마다 handlePDFChange는 \u003cb\u003e새로운 함수 참조가 생성\u003c/b\u003e되어 FileUpload의 props가 변경된 것으로 간주되어 자식 컴포넌트 FileUpload는 리렌더링 됩니다. 이를 피하기 위해 \u003cu\u003e커스텀 훅 usePdfController에서 handlePDFChange를 메모이제이션(useCallback)하여, 함수가 매 렌더링마다 동일한 참조를 유지\u003c/u\u003e하도록 합니다.\\n\"},{\"type\":\"code\",\"value\":\"// usePdfController.js\\n// ★★★커스텀 훅 내부에서 useCallback 사용\\n  const handlePDFChange = useCallback((event) =\u003e {\\n  const selectedFile = event.target.files[0];\\n  setFile(selectedFile);\\n}, []);\"},{\"type\":\"stringlist\",\"value\":\"InputRef는 useRef로 생성된 참조로, 렌더링 간에 변경되지 않습니다.\"},{\"type\":\"h4\",\"value\":\"부모 컴포넌트의 리렌더링 영향 \"},{\"type\":\"stringlist\",\"value\":\"부모 컴포넌트 StampController가 자주 리렌더링되면, 자식 컴포넌트 FileUpload도 기본적으로 리렌더링됩니다. \\n\\t\\t\\t\\tReact는 부모가 리렌더링되면 자식도 렌더링 시도\\n\\t\\t\\t\\t이를 피하기 위해서는 자식 컴포넌트인 FileUpload을 React.memo로 감싸줍니다.\"},{\"type\":\"code\",\"value\":\"const FileUpload = ({ onChange, InputRef, children }) =\u003e {\\n  console.log('FileUpload rendered');\\n  return (\\n    \u0026lt;label\u003e\\n      {children}\\n      \u0026lt;input type=\\\"file\\\" ref={InputRef} onChange={onChange} style={{ display: 'none' }} /\u003e\\n    \u0026lt;/label\u003e\\n  );\\n};\\nexport default React.memo(FileUpload);\"},{\"type\":\"stringlist\",\"value\":\"이렇게 하면 onChange, InputRef, children이 변경되지 않는 한 FileUpload은 리렌더링되지 않습니다. 부모컴포넌트 StampController가 file 상태 변경으로 리렌더링되더라도, 자식 컴포넌트 FileUpload가 React.memo로 감싸져 있다면 props가 변경되지 않는 한 리렌더링을 건너뜁니다\"},{\"type\":\"stringlist\",\"value\":\"React.memo는 props의 얕은 비교(shallow comparison)를 수행해 props가 변경되지 않는 한 컴포넌트의 리렌더링을 방지합니다.\"},{\"type\":\"stringlist\",\"value\":\"인터랙션의 경우 (예: 파일 선택)은 handlePDFChange를 호출하고, 이는 usePdfController의 file 상태를 변경합니다. 하지만 이 변경은 StampController의 렌더링에만 직접 영향을 주고, FileUpload은 스테이트를 소유하지 않으므로 간접적인 리렌더링을 피할 수 있습니다.\"},{\"type\":\"h4\",\"value\":\"\u003cFileUpload/\u003e Children Props 변경\"},{\"type\":\"normal\",\"value\":\"FileUpload의 children(예: \\\"PDF 업로드\\\")이 동적으로 생성되거나 매번 새로운 참조를 가지면, React.memo를 사용하더라도 리렌더링될 수 있습니다. children이 정적이거나 메모이제이션된 값을 사용하도록 합니다.\"},{\"type\":\"code\",\"value\":\"\u0026lt;FileUpload InputRef={pdfInputRef} onChange={handlePDFChange}\u003e\\n  PDF 업로드\\n\u0026lt;/FileUpload\u003e\"},{\"type\":\"h4\",\"value\":\"\u003cFileUpload/\u003e 같은 자식 컴포넌트가 스토어 상태를 직접 구독하지 않도록 하여 리렌더링을 방지 한다.\"},{\"type\":\"code\",\"value\":\"// 잘못된 예\\nconst FileUpload = ({ onChange, InputRef, children }) =\u003e {\\n  const { file } = useCanvasStore(); // 스토어 구독\\n  return \u0026lt;input type=\\\"file\\\" ref={InputRef} onChange={onChange} /\u003e;\\n};\\n\\n// 올바른 예\\nconst FileUpload = ({ onChange, InputRef, children }) =\u003e {\\n  return \u0026lt;input type=\\\"file\\\" ref={InputRef} onChange={onChange} /\u003e;\\n};\"},{\"type\":\"H3\",\"value\":\"리렌더링이 되지 않는 조건을 지켜는 방법\"},{\"type\":\"stringlist\",\"value\":\"컴포넌트가 자체 스테이트를 소유하지 않고 커스텀 훅으로 관리.\\n\\t\\t\\t\\t컴포넌트가 스토어나 Context를 직접 구독하지 않고 커스텀 훅으로 관리하도록 함.\\n전달된 props(함수, 참조, 값)가 메모이제이션되어 전달 받도록 하기.\\n컴포넌트가 React.memo로 감싸져 있어 부모 리렌더링의 영향을 받지 않음.\"}]},\"segment\":\"posts\"}],[\"$\",\"div\",null,{\"className\":\"footer_footer_container__MsSvO\",\"children\":[\"$\",\"footer\",null,{\"className\":\"footer_footer__AwYty\",\"children\":[[\"$\",\"p\",null,{\"className\":\"footer_copylight___J5l0\",\"children\":[\"© 2024 \",\"베짱이가 되고싶은 개미。\",\" Some rights reserved.\"]}],[\"$\",\"p\",null,{\"className\":\"footer_theme__bwXbg\",\"children\":\"portfolio v1.0.0-alpha.3\"}]]}]}]],null]]},[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"tags\",\"children\",\"$d\",\"children\",\"$e\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/9149e1f00c2ba43a.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]]},[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"tags\",\"children\",\"$d\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"tags\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]],\"search\":[\"__DEFAULT__\",{},[\"$10\",\"$L12\",null]]},[null,[\"$\",\"$L13\",null,{\"children\":[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}],\"search\":[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"search\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"search\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$14\",\"styles\":null}],\"params\":{}}],null]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"className\":\"\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css\",\"as\":\"style\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.googleapis.com\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.gstatic.com\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR\u0026display=swap\",\"as\":\"style\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":\"$15\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":\"$16\",\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":\"$17\",\"children\":[\"$\",\"h2\",null,{\"style\":\"$18\",\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/04d20c09b3119d43.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]}]]}],null]],\"initialHead\":[false,\"$L19\"],\"globalErrorComponent\":\"$1a\"}]]\n"])</script><script>self.__next_f.push([1,"12:E{\"digest\":\"NEXT_NOT_FOUND\"}\n"])</script><script>self.__next_f.push([1,"19:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"be come 💡\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"App for an Ant Who Wants to Become a Bejjangyi\"}]]\n6:null\n11:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>