<!DOCTYPE html><html lang="en" class=""><head><meta charSet="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/5048045ff4a95083.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0c496b0e03d530ba.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/19d2a4a42355ad75.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-f6066d3237490a83.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-0e492acdb34e0e7d.js" async="" crossorigin=""></script><script src="/_next/static/chunks/938-073485517c55f951.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-d3c7d898fafbc3cf.js" async="" crossorigin=""></script><script src="/_next/static/chunks/250-8b90be581650ff9d.js" async=""></script><script src="/_next/static/chunks/399-caf055eb211349e2.js" async=""></script><script src="/_next/static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-82d05226373f742d.js" async=""></script><script src="/_next/static/chunks/46-f5c36f830a2ce4c4.js" async=""></script><script src="/_next/static/chunks/730-f56ebe909f1c8bdb.js" async=""></script><script src="/_next/static/chunks/35-86206131b00fc69c.js" async=""></script><script src="/_next/static/chunks/app/(layoutCase)/layout-8ff98cce509a96df.js" async=""></script><title>be come 💡</title><meta name="description" content="App for an Ant Who Wants to Become a Bejjangyi"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" as="style"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR&amp;display=swap" as="style"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><aside id="sidebar" class="sidemenu_sidebar__EmvJl"><header class="sidemenu_profile_wrapper__R57aU"><div class="sidemenu_profile__R1Mv0"><a href="/posts"><div class="imageLoader_imgloaderContainer__d3Tsu"><img alt="프로필이미지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" style="color:transparent;border-radius:50%;width:100%;height:auto" srcSet="https://nam-yeun-hwa.github.io/image/profile1.jpg?w=128&amp;q=75 1x, https://nam-yeun-hwa.github.io/image/profile1.jpg?w=256&amp;q=75 2x" src="https://nam-yeun-hwa.github.io/image/profile1.jpg?w=256&amp;q=75"/></div></a></div><h1 class="sidemenu_blog_name_txt__AfWhD">my blog</h1><p class="sidemenu_site_subtitle__eLcN7">You can only earn as much as an ant does by working like an ant.</p></header><nav><ul class="sidemenu_nav__6C5tz"><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/posts"><i class="fa-fw fas fa-home sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">HOME</span></a></li><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/categories"><i class="fa-fw fas fa-stream sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">CATEGORIES</span></a></li><li class="sidemenu_nav_item__tt_B1 sidemenu_active__fflT6"><a class="sidemenu_nav_link__WTCmf" href="/tags"><i class="fa-fw fas fa-tags sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">TAGS</span></a></li><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/archives"><i class="fa-fw fas fa-archive sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">ARCHIVES</span></a></li></ul></nav><div class="sidebar-bottom"></div></aside><div class="layout_main_wrapper__1M1Uy"><div class="contents_container__AfHAx"><header class="breadCrumb_topbar_wrapper__dGN_V"><div class="breadCrumb_top_bar__b_rV9"><nav class="breadCrumb_breadcrumb__l7WLX"><span><a class="breadCrumb_topbar_txt__ExrWf" href="/">Home</a><a class="breadCrumb_topbar_txt__ExrWf" href="">브라우저 렌더링 중 스크립트 태그를 만날 때 파싱이 중단되는 문제와 해결</a></span></nav><search class="searchBar_search__Ftlhc"><i class="fas fa-search fa-fw searchBar_search_ico__STStc"></i><input id="search" class="searchBar_search_input__1XpQF" placeholder="Search..." autoComplete="off" value=""/></search></div><div class="breadCrumb_mobile_topbar__N1Azi"><button class="breadCrumb_sidebar_trigger__APgD8"><i class="fas fa-bars fa-fw breadCrumb_sidebar_trigger_ico__K9DdV"></i></button><div class="breadCrumb_mobile_topbar_title__oCVBS">be come 💡</div><button class="breadCrumb_search_trigger__PxWyf"><i class="fas fa-search fa-fw breadCrumb_search_trigger_ico__yqqpz"></i></button></div></header><div class="contents_contents__Hpf57"><main class="contents_inner_content__wyt37"><article><header><h1 class="postUserInfo_h1__uhAqy">브라우저 렌더링 중 스크립트 태그를 만날 때 파싱이 중단되는 문제와 해결</h1></header></article><div class="postUserInfo_post_meta__ABvuC"><span>Posted<!-- --> <time class="postUserInfo_time__2exyR">a year<!-- --> </time></span><span class="postUserInfo_update__f345P">Updated<!-- --> <time class="postUserInfo_time__2exyR">a year</time></span></div><div><span class="postUserInfo_post_meta__ABvuC">By<!-- --> <em><a class="postUserInfo_author__fVGYM" href="https://nam-yeun-hwa.github.io/">베짱이가 되고싶은 개미。</a></em></span></div><div class="postDetail_content__OTeO2">렌더링 엔진은 HTML 한 줄씩 순차적으로 파싱하며 DOM을 생성해 나가다가 JavaScript를 만나면 DOM 생성을 임시 중단합니다.
        DOM 생성을 임시 중단하고, 자바스크립트 코드를 파싱하기 위해 자바스크립트 엔진에 제어권을 넘기게 되는데, 파싱이 끝나면 다시 렌더링 엔진에 제어권을 넘겨 중단된 부분부터 HTML 파싱을 재개하며 DOM 트리를 생성합니다.
        </div><div class="postDetail_content__OTeO2">DOM을 생성해 나가다가 스크립트 태그를 만날 때 파싱이 중단되는 문제를 해결하는 몇 가지 방법 중 비동기적으로 스크립트 로드하는 방법을 설명하려 합니다.
         async나 defer 속성을 사용하여 스크립트를 비동기적으로 로드할 수 있습니다. 이를 통해 스크립트 로드가 병렬적으로 이루어지므로 페이지 파싱이 중단되지 않습니다.</div><h4 class="heading_h4__ZTbA0" style="font-weight:NORMAL">📝 <!-- -->HTML 코드</h4><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Async vs Defer&lt;/title&gt;
&lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Async vs Defer 예제&gt;/h1&gt;
    &lt;script src=&quot;script.js&quot; async&gt;/script&gt;
    &lt;script src=&quot;script.js&quot; defer&gt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></div><h4 class="heading_h4__ZTbA0" style="font-weight:NORMAL">📝 <!-- -->script.js</h4><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">console.log(&quot;이 부분은 스크립트가 실행되어야 하는 내용입니다.&quot;);</pre></div></div><div class="postDetail_content__OTeO2">여기서 async와 defer 속성을 가진 </div><h4 class="heading_h4__ZTbA0" style="font-weight:NORMAL">📝 <!-- -->async 속성</h4><div class="postDetail_content__OTeO2">브라우저는 async 속성을 가진 스크립트를 만나면 HTML 파싱과 함께 스크립트 파일의 다운로드를 동시에 시작합니다.
              스크립트 파일이 다운로드되고 실행될 준비가 되면, HTML 파싱은 멈추고 스크립트가 실행됩니다.
              따라서 console.log가 실행될 때까지 HTML 파싱은 멈추게 됩니다.</div><h4 class="heading_h4__ZTbA0" style="font-weight:NORMAL">📝 <!-- -->defer 속성</h4><div class="postDetail_content__OTeO2">브라우저는 defer 속성을 가진 스크립트를 만나면 HTML 파싱을 계속하면서 스크립트 파일의 다운로드를 시작합니다.
              스크립트 파일은 DOM 생성이 완료된 직후에 실행됩니다. 즉, DOMContentLoaded 이벤트가 발생한 후에 실행됩니다.
              따라서 console.log가 실행될 때까지 HTML 파싱은 멈추지 않습니다.</div><div class="postDetail_content__OTeO2">이러한 방법 중에서 적합한 방법을 선택하여 사용하면 됩니다. 일반적으로 비동기 로드나 스크립트 위치 이동이 가장 효과적인 해결책일 수 있습니다.</div><div class="row"><nav class="postNavigation_post_navigation__Zbcpm"><a class="postNavigation_post_navgation_common__q8_Hl postNavigation_post_navigation_pre__SPHh_" aria-label="Older" href="/posts/26"><p class="postNavigation_post_navigation_text__3cjma">테스트 주도 개발(Test driven devlopment, TDD)</p></a><a class="postNavigation_post_navgation_common__q8_Hl postNavigation_post_navigation_next__yVEzg" aria-label="Newer" href="/posts/24"><p class="postNavigation_post_navigation_text__3cjma">Function.prototype.bind()</p></a></nav></div><div class="footer_footer_container__MsSvO"><footer class="footer_footer__AwYty"><p class="footer_copylight___J5l0">© 2024 <!-- -->베짱이가 되고싶은 개미。<!-- --> Some rights reserved.</p><p class="footer_theme__bwXbg">portfolio v1.0.0-alpha.3</p></footer></div></main><aside class="panel_panel_wrapper__bjPKT"><div class="panel_access__NiFhF"><section class="panel_access_lastmod__v6pgX"><h2 class="panel_panel_heading__n9W6w">Recently Updated</h2><ul class="panel_panel_recently__U0_Zp"><li class="panel_text_truncate__SFfHf"><a href="/posts/68">[TECH-QA] 애니메이션 분석 (Reflow와 Repaint 이론)</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/67">[TECH-QA] 리플로우(Reflow)와 리페인트(Repaint)는 브라우저의 렌더링 과정</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/66">[TECH-QA] 브라우저 렌더링 과정</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/65">[TECH-QA] 리액트에서 XSS 방어</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/64">[TECH-QA] CSRF와 XSS</a></li></ul></section><section class="panel_panel_tag_contain__h_Bwi"><h2 class="panel_panel_heading__n9W6w">Trending Tags</h2><div class="panel_panel_tag__eNz5c"><a class="panel_tag__3AiMO" href="/tags/브라우저">브라우저</a><a class="panel_tag__3AiMO" href="/tags/TECH-QA">TECH-QA</a><a class="panel_tag__3AiMO" href="/tags/Reflow">Reflow</a><a class="panel_tag__3AiMO" href="/tags/Repaint">Repaint</a><a class="panel_tag__3AiMO" href="/tags/리플로우">리플로우</a><a class="panel_tag__3AiMO" href="/tags/리페인트">리페인트</a><a class="panel_tag__3AiMO" href="/tags/웹성능 최적화">웹성능 최적화</a><a class="panel_tag__3AiMO" href="/tags/react">react</a><a class="panel_tag__3AiMO" href="/tags/XSS">XSS</a><a class="panel_tag__3AiMO" href="/tags/JavaScript">JavaScript</a><a class="panel_tag__3AiMO" href="/tags/CSRF">CSRF</a><a class="panel_tag__3AiMO" href="/tags/리렌더링">리렌더링</a><a class="panel_tag__3AiMO" href="/tags/Prototype">Prototype</a><a class="panel_tag__3AiMO" href="/tags/JWT">JWT</a><a class="panel_tag__3AiMO" href="/tags/React">React</a><a class="panel_tag__3AiMO" href="/tags/English">English</a><a class="panel_tag__3AiMO" href="/tags/midjourney">midjourney</a><a class="panel_tag__3AiMO" href="/tags/스키너의 심리상자 열기">스키너의 심리상자 열기</a><a class="panel_tag__3AiMO" href="/tags/독서">독서</a><a class="panel_tag__3AiMO" href="/tags/next">next</a><a class="panel_tag__3AiMO" href="/tags/지연로딩">지연로딩</a><a class="panel_tag__3AiMO" href="/tags/Lazy-loading">Lazy-loading</a><a class="panel_tag__3AiMO" href="/tags/CSS">CSS</a><a class="panel_tag__3AiMO" href="/tags/Tailwind">Tailwind</a><a class="panel_tag__3AiMO" href="/tags/mysql">mysql</a><a class="panel_tag__3AiMO" href="/tags/database">database</a><a class="panel_tag__3AiMO" href="/tags/TDD">TDD</a><a class="panel_tag__3AiMO" href="/tags/콜백함수">콜백함수</a><a class="panel_tag__3AiMO" href="/tags/browser">browser</a><a class="panel_tag__3AiMO" href="/tags/HTTP-Protocol">HTTP-Protocol</a><a class="panel_tag__3AiMO" href="/tags/git">git</a><a class="panel_tag__3AiMO" href="/tags/FrontEnd">FrontEnd</a><a class="panel_tag__3AiMO" href="/tags/Vue">Vue</a></div></section></div></aside></div></div></div><script src="/_next/static/chunks/webpack-f6066d3237490a83.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/5048045ff4a95083.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/css/0c496b0e03d530ba.css\",\"style\",{\"crossOrigin\":\"\"}]\n4:HL[\"/_next/static/css/19d2a4a42355ad75.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"5:I[7690,[],\"\"]\n7:I[5250,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"399\",\"static/chunks/399-caf055eb211349e2.js\",\"216\",\"static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-82d05226373f742d.js\"],\"\"]\n8:I[8843,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"399\",\"static/chunks/399-caf055eb211349e2.js\",\"216\",\"static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-82d05226373f742d.js\"],\"\"]\n9:I[777,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"399\",\"static/chunks/399-caf055eb21"])</script><script>self.__next_f.push([1,"1349e2.js\",\"216\",\"static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-82d05226373f742d.js\"],\"\"]\na:I[5613,[],\"\"]\nd:I[1778,[],\"\"]\n11:I[3866,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"399\",\"static/chunks/399-caf055eb211349e2.js\",\"46\",\"static/chunks/46-f5c36f830a2ce4c4.js\",\"730\",\"static/chunks/730-f56ebe909f1c8bdb.js\",\"35\",\"static/chunks/35-86206131b00fc69c.js\",\"464\",\"static/chunks/app/(layoutCase)/layout-8ff98cce509a96df.js\"],\"\"]\n18:I[8955,[],\"\"]\nb:[\"tagname\",\"XSS\",\"d\"]\nc:[\"postid\",\"25\",\"d"])</script><script>self.__next_f.push([1,"\"]\ne:\"$Lf\"\n12:[]\n13:{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"}\n14:{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"}\n15:{\"display\":\"inline-block\"}\n16:{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0}\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/5048045ff4a95083.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"5UwSy2AQa_DT7-uifvmO-\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/tags/XSS/25\",\"initialTree\":[\"\",{\"children\":[\"(layoutCase)\",{\"children\":[\"tags\",{\"children\":[[\"tagname\",\"XSS\",\"d\"],{\"children\":[[\"postid\",\"25\",\"d\"],{\"children\":[\"__PAGE__?{\\\"tagname\\\":\\\"XSS\\\",\\\"postid\\\":\\\"25\\\"}\",{}]}]}]}],\"search\":[\"__DEFAULT__\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"(layoutCase)\",{\"children\":[\"tags\",{\"children\":[[\"tagname\",\"XSS\",\"d\"],{\"children\":[[\"postid\",\"25\",\"d\"],{\"children\":[\"__PAGE__\",{},[\"$L6\",[[[\"$\",\"article\",null,{\"className\":\"$undefined\",\"children\":[\"$\",\"header\",null,{\"children\":[\"$\",\"h1\",null,{\"className\":\"postUserInfo_h1__uhAqy\",\"children\":\"브라우저 렌더링 중 스크립트 태그를 만날 때 파싱이 중단되는 문제와 해결\"}]}]}],[\"$\",\"div\",null,{\"className\":\"postUserInfo_post_meta__ABvuC\",\"children\":[[\"$\",\"span\",null,{\"children\":[\"Posted\",\" \",[\"$\",\"time\",null,{\"className\":\"postUserInfo_time__2exyR\",\"children\":[\"a year\",\" \"]}]]}],[\"$\",\"span\",null,{\"className\":\"postUserInfo_update__f345P\",\"children\":[\"Updated\",\" \",[\"$\",\"time\",null,{\"className\":\"postUserInfo_time__2exyR\",\"children\":\"a year\"}]]}]]}],[\"$\",\"div\",null,{\"children\":[\"$\",\"span\",null,{\"className\":\"postUserInfo_post_meta__ABvuC\",\"children\":[\"By\",\" \",[\"$\",\"em\",null,{\"children\":[\"$\",\"$L7\",null,{\"href\":\"https://nam-yeun-hwa.github.io/\",\"className\":\"postUserInfo_author__fVGYM\",\"children\":\"베짱이가 되고싶은 개미。\"}]}]]}]}]],[[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"렌더링 엔진은 HTML 한 줄씩 순차적으로 파싱하며 DOM을 생성해 나가다가 JavaScript를 만나면 DOM 생성을 임시 중단합니다.\\n        DOM 생성을 임시 중단하고, 자바스크립트 코드를 파싱하기 위해 자바스크립트 엔진에 제어권을 넘기게 되는데, 파싱이 끝나면 다시 렌더링 엔진에 제어권을 넘겨 중단된 부분부터 HTML 파싱을 재개하며 DOM 트리를 생성합니다.\\n        \"}}],[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"DOM을 생성해 나가다가 스크립트 태그를 만날 때 파싱이 중단되는 문제를 해결하는 몇 가지 방법 중 비동기적으로 스크립트 로드하는 방법을 설명하려 합니다.\\n         async나 defer 속성을 사용하여 스크립트를 비동기적으로 로드할 수 있습니다. 이를 통해 스크립트 로드가 병렬적으로 이루어지므로 페이지 파싱이 중단되지 않습니다.\"}}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"style\":{\"fontWeight\":\"NORMAL\"},\"children\":[\"📝 \",\"HTML 코드\"]}]],[\"$\",\"$L8\",null,{\"code\":\"\u003c!DOCTYPE html\u003e\\n\u003chtml lang=\\\"en\\\"\u003e\\n\u003chead\u003e\\n\u003cmeta charset=\\\"UTF-8\\\"\u003e\\n\u003cmeta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"\u003e\\n  \u003ctitle\u003eAsync vs Defer\u003c/title\u003e\\n\u003c/head\u003e\\n  \u003cbody\u003e\\n    \u003ch1\u003eAsync vs Defer 예제\u003e/h1\u003e\\n    \u003cscript src=\\\"script.js\\\" async\u003e/script\u003e\\n    \u003cscript src=\\\"script.js\\\" defer\u003e/script\u003e\\n  \u003c/body\u003e\\n\u003c/html\u003e\",\"children\":\"$undefined\"}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"style\":{\"fontWeight\":\"NORMAL\"},\"children\":[\"📝 \",\"script.js\"]}]],[\"$\",\"$L8\",null,{\"code\":\"console.log(\\\"이 부분은 스크립트가 실행되어야 하는 내용입니다.\\\");\",\"children\":\"$undefined\"}],[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"여기서 async와 defer 속성을 가진 \"}}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"style\":{\"fontWeight\":\"NORMAL\"},\"children\":[\"📝 \",\"async 속성\"]}]],[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"브라우저는 async 속성을 가진 스크립트를 만나면 HTML 파싱과 함께 스크립트 파일의 다운로드를 동시에 시작합니다.\\n              스크립트 파일이 다운로드되고 실행될 준비가 되면, HTML 파싱은 멈추고 스크립트가 실행됩니다.\\n              따라서 console.log가 실행될 때까지 HTML 파싱은 멈추게 됩니다.\"}}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"style\":{\"fontWeight\":\"NORMAL\"},\"children\":[\"📝 \",\"defer 속성\"]}]],[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"브라우저는 defer 속성을 가진 스크립트를 만나면 HTML 파싱을 계속하면서 스크립트 파일의 다운로드를 시작합니다.\\n              스크립트 파일은 DOM 생성이 완료된 직후에 실행됩니다. 즉, DOMContentLoaded 이벤트가 발생한 후에 실행됩니다.\\n              따라서 console.log가 실행될 때까지 HTML 파싱은 멈추지 않습니다.\"}}],[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"이러한 방법 중에서 적합한 방법을 선택하여 사용하면 됩니다. 일반적으로 비동기 로드나 스크립트 위치 이동이 가장 효과적인 해결책일 수 있습니다.\"}}]],[\"$\",\"$L9\",null,{\"postid\":25,\"prePostTitle\":{\"id\":26,\"title\":\"테스트 주도 개발(Test driven devlopment, TDD)\",\"date\":\"2024-07-08 22:13:16\",\"folder\":\"tdd\",\"tag\":[\"TDD\"],\"preview\":\"테스트 코드를 먼저 작성하는 테스트 주도 개발 방벙론은 테스트 프레임워크를 사용하여 자동화된 테스트 시스템에서 미리 정의된 사양을 바탕으로 실패하는 테스트 명새를 작성하고\",\"post\":[{\"type\":\"normal\",\"value\":\"소프트웨어를 전문적으로 개발하는 기업들은 서비스의 안정적인 운영과 서비스의 품질을 확보하기 위해 테스트 코드를 작성하고 관리하고 있다. 다시 말하면 서비스의 품질을 확보하기 위해서는 테스트 코드 작성이 필수라는 것이다.\"},{\"type\":\"normal\",\"value\":\"테스트 주도 개발이라는 개념이 나오기 전에는 우리가 지금까지 해온 것과 같이 움직이는 소프트웨어를 개발한 후 해당 소프트 웨어에 대한 테스트 코드를 작성하는 방식을 사용해 왔다. 이 방식을 사용하면 다음과 같은 문제점들이 있다.\"},{\"type\":\"stringlist\",\"value\":\"다른 사람이 작성한 소스 코드 또는 내가 예전에 작성한 코드에 대해 테스트 코드를 작성해야 하는데 이 코드가 어떻게 동작하는지 알 수 없거나 기억할 수 없음으로 코드를 다시 분석하고 테스트 코드를 작성해야 한다.\\n        작성된 코드가 테스트하기 쉽게 작성되어 있지 않다. 따라서 테스트 코드를 작성하기가 불가능 하거나 테스트 코드를 작성하기 위해 이미 작성된 코드를 수정해야 할 경우가 발생한다. 이때 기존 코드의 수정으로 인해 예기치 않은 문제가 발생할 수 있다.\"},{\"type\":\"normal\",\"value\":\"이런 문제를 해결하기 위해 켄트백(Kent Beck)은 테스트 코드를 먼저 작성하는 테스트 주도 개발론을 제안하게 되었다. 테스트 줃 개발 방벙론은 테스트 프레임워크 등을 사용하여 자동화된 테스트 시스템에서 미리 정의된 사양을 바탕으로\"},{\"type\":\"GuideMessage\",\"value\":\"실패하는 테스트 명세를 작성하고 그 테스트 명세를 통과하기 위한 최소한의 코드를 작성한다. 마지막으로 해당 코드를 리팩토링 하는 것으로 개발을 마치는 프로세스이다.\"},{\"type\":\"Heading\",\"headingType\":\"h2\",\"value\":\"Jest 테스트 프레임워크로 테스트 코드 작성하기\"},{\"type\":\"normal\",\"value\":\"Jest는 주로 JavaScript 및 TypeScript 애플리케이션을 테스트하기 위해 사용되는 JavaScript 테스팅 프레임워크로 특히 React 애플리케이션 테스트에 최적화되어 있다. 페이스북(현 메타)에서 개발했으며,  React 외에도 다른 JavaScript 프레임워크나 라이브러리와도 잘 작동한다.\"},{\"type\":\"Heading\",\"headingType\":\"h2\",\"value\":\"Jest의 주요 쿼리 함수\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"describe 함수 \"},{\"type\":\"normal\",\"value\":\"describe함수는 jest가 제공하는 함수로써 여러 테스트를 한 그룹으로 묶고 설명을 붙이기 위해 사용한다.\"},{\"type\":\"stringlist\",\"value\":\"첫번째 매개변수는 명령 프롬프트에 표시할 설명\\n        두번째 매개변수는 여러 테스트를 그룹으로 묶을 콜백 함수\"},{\"type\":\"code\",\"value\":\"describe('test index.js file', () =\u003e {\\n\\n});\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"it 함수\"},{\"type\":\"normal\",\"value\":\"it함수는 실제 테스트가 실행되는 테스트 명세를 작성할 때 사용한다.\"},{\"type\":\"stringlist\",\"value\":\"첫번째 매개변수는 테스트 명세의 설명\\n        두 번째 매개변수에는 실제로 테스트를 실행하는 테스트 코드를 작성\"},{\"type\":\"code\",\"value\":\"it('sum 1+2 to equal 3', () =\u003e {\\n      \\n});\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"expect 함수\"},{\"type\":\"normal\",\"value\":\"expect 함수는 주로 테스트 프레임워크에서 테스트 결과를 확인하기 위해 사용되는 메서드나 함수이다. expect 함수는 테스트 대상이 특정 조건을 만족하는지, 즉 예상된 동작을 수행하는지를 검증하는 역할이다.\"},{\"type\":\"code\",\"value\":\"it('sum 1+2 to equal 3', () =\u003e {\\n      expect(sum(1,2)).toBe(3);\\n});\"},{\"type\":\"stringlist\",\"value\":\"여기서 sum(1,2)는 테스트 대상이 실제로 생성한 값이고, 3는 기대하는 값이며 toBe는 일치 여부를 확인하는 메서드이다.\"},{\"type\":\"normal\",\"value\":\"expect는 단순한 값 비교 외에도 다양한 일치 조건을 제공한다. 예를 들어, 두 객체가 동일한지, 배열이 특정 요소를 포함하는지, 함수가 특정 예외를 던지는지 등을 확인할 수 있다.\"},{\"type\":\"code\",\"value\":\"// 객체나 배열의 동등성 비교\\nexpect(actualValue).toEqual(expectedValue); \\n\\n// 배열이 특정 아이템을 포함하는지\\nexpect(array).toContain(item); \\n\\n// 함수가 특정 오류를 던지는지\\nexpect(() =\u003e functionCall()).toThrow(ErrorType); \\n        \"},{\"type\":\"Heading\",\"headingType\":\"h2\",\"value\":\"@testing-library로 리액트 컴포넌트 테스트 코드 작성 하기\"},{\"type\":\"normal\",\"value\":\"@testing-library는 DOM 테스팅 라이브러리(DOM Testing Library)이다. @testing-library는 사용자 중심 방식으로 UI 컴포넌트를 테스트하는데 도움을 주는 라이브러리이며\\n        리액트 컴포넌트의 테스트 코드 작성을 도와준다. \u003c/br\u003e\u003c/br\u003e\\n        \\n        테스트 코드를 작성할 때 컴포넌트 세부 구현사항을 포함하지 않으면서도 신뢰할 수 있는 테스트 코드 작성에 도움을 준다. 이렇게 컴포넌트의 세부 구현 사항을 포함하지 않은 테스트 코드를 작성하면 컴포넌트의 세부 구현 부분을 리팩토링 하여도 테스트 코드를 수정할 필요가 없다, 이로 인해 한번 작성한 테스트 코드는 긴 시간 유지할 수 있으며 오랜 기간 유지 가능하여 테스트 코드를 자주 수정하지 않아도 되므로 개발 생산성을 향상 시켜 준다.\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"App.js 컴포넌트 - 렌더링 테스트\"},{\"type\":\"code\",\"value\":\"import { render, screen } from 'testing-library/react';\\nimport App from './App.js';\\n        \\ntest('renders learn react link', ()=\u003e{\\n  render(\u003cApp /\u003e);\\n  const linkElement = screen.getByText(/learn react/i);\\n  expect(linkElement).toBeInTheDocument();\\n})\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"test\"},{\"type\":\"normal\",\"value\":\"test 함수(it 함수와 같은 역할을 하는 함수)를 사용하여 테스트 명세를 작성한 테스트 코드이다.\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"render\"},{\"type\":\"normal\",\"value\":\"리액트 컴포넌트를 화면에 표시하기 위함\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"screen\"},{\"type\":\"normal\",\"value\":\"리액트 컴포넌트가 표시된 화면을 의미한다.\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"GetByText\"},{\"type\":\"normal\",\"value\":\"getByText 함수는 주어진 텍스트를 포함하는 DOM 요소를 찾는 데 사용된다. 렌더링된 컴포넌트에서 screen.GetByText를 통해 화면에서 'learn react'라는 글자를 가지고 있는 돔 요소를 찾는다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('renders Hello World text', () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const textElement = screen.getByText('Hello World');\\n  expect(textElement).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"toBeInTheDocument\"},{\"type\":\"normal\",\"value\":\"요소를 찾아 jest expect().toBeInTheDocument()를 사용하여 돔에 표시되어 있는지 확인 한다. \u003c/br\u003e\\n\\n        render 함수는 메모리상에 돔을 만들고 screen을 통해 해당 돔에 접근 하는 것을 의미한다.\\n        react-testing-library의 render 함수를 사용하여 App이라는 컴포넌트를 렌더링 하였다.\"},{\"type\":\"Heading\",\"headingType\":\"h2\",\"value\":\"React Testing Library의 주요 쿼리 함수\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"getByText\"},{\"type\":\"normal\",\"value\":\"주어진 텍스트를 포함하는 요소를 찾습니다.\u003c/br\u003e\\n        ex) screen.getByText(/learn react/i)는 대소문자를 구분하지 않고 \\\"learn react\\\"라는 텍스트를 포함하는 요소를 찾습니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('renders learn react link', () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const linkElement = screen.getByText(/learn react/i);\\n  expect(linkElement).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"getByRole\"},{\"type\":\"normal\",\"value\":\"특정 역할(예: 버튼, 링크)을 가진 요소를 찾습니다.\u003c/br\u003e\\n        screen.getByRole('button', { name: /submit/i })은 \\\"submit\\\" 텍스트를 가진 버튼을 찾습니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('renders submit button', () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const buttonElement = screen.getByRole('button', { name: /submit/i });\\n  expect(buttonElement).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"getByLabelText\"},{\"type\":\"normal\",\"value\":\"특정 라벨 텍스트와 연결된 요소(주로 폼 필드)를 찾습니다.\u003c/br\u003e\\n        screen.getByLabelText('Username')은 \\\"Username\\\" 라벨을 가진 입력 필드를 찾습니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport LoginForm from './LoginForm';\\n        \\ntest('finds the username input', () =\u003e {\\n  render(\u003cLoginForm /\u003e);\\n  const inputElement = screen.getByLabelText('Username');\\n  expect(inputElement).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"getByPlaceholderText\"},{\"type\":\"normal\",\"value\":\"특정 플레이스홀더 텍스트를 가진 입력 요소를 찾습니다. \u003c/br\u003e\\n        screen.getByPlaceholderText('Enter your username')은 \\\"Enter your username\\\" 플레이스홀더를 가진 입력 필드를 찾습니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport LoginForm from './LoginForm';\\n        \\ntest('finds the input by placeholder', () =\u003e {\\n  render(\u003cLoginForm /\u003e);\\n  const inputElement = screen.getByPlaceholderText('Enter your username');\\n  expect(inputElement).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"getByAltText\"},{\"type\":\"normal\",\"value\":\"주어진 alt 텍스트를 가진 이미지를 찾습니다.\u003c/br\u003e\\n        screen.getByAltText('Profile Picture')은 \\\"Profile Picture\\\" alt 텍스트를 가진 이미지를 찾습니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport Profile from './Profile';\\n        \\ntest('finds the profile picture', () =\u003e {\\n  render(\u003cProfile /\u003e);\\n  const imageElement = screen.getByAltText('Profile Picture');\\n  expect(imageElement).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"getByTestId\"},{\"type\":\"normal\",\"value\":\"data-testid 속성을 사용하여 요소를 찾습니다. \u003c/br\u003e\\n        screen.getByTestId('custom-element')은 data-testid=\\\"custom-element\\\" 속성을 가진 요소를 찾습니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport Component from './Component';\\n        \\ntest('finds element by test id', () =\u003e {\\n  render(\u003cComponent /\u003e);\\n  const element = screen.getByTestId('custom-element');\\n  expect(element).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"queryByText\"},{\"type\":\"normal\",\"value\":\"요소가 존재하지 않거나, 하나만 존재할 때 사용합니다. 존재하지 않으면 null을 반환합니다. \u003c/br\u003e\\n        getByText는 요소가 없으면 에러를 던집니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('does not find non-existing text', () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const textElement = screen.queryByText('Non-existing Text');\\n  expect(textElement).toBeNull();\\n});\\n        \"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"findByText\"},{\"type\":\"normal\",\"value\":\"비동기적으로 요소를 찾을 때 사용합니다. 주로 요소가 나중에 렌더링될 경우에 사용합니다. 반환 값은 Promise입니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('renders welcome message', async () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const messageElement = await screen.findByText(/welcome/i);\\n  expect(messageElement).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"Heading\",\"headingType\":\"h2\",\"value\":\"참고할만한 예제들\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"예제 [1] - 컴포넌트가 올바르게 렌더링되는지를 확인하는 테스트 케이스\"},{\"type\":\"normal\",\"value\":\"\u003cApp /\u003e에 대한 Jest 테스트 스위트를 작성한 것으로 \u003cApp /\u003e 컴포넌트가 올바르게 렌더링되는지를 확인하는 하나의 테스트 케이스를 포함하고 있다.\"},{\"type\":\"keyword\",\"value\":\"render,getElementByClassName,toHaveLength,toHaveAttribute\"},{\"type\":\"code\",\"value\":\"describe('\u003cApp /\u003e', ()=\u003e{\\nit('renders component correctly', ()=\u003e{      \\n      ① const { container } = render(\u003cApp /\u003e);              \\n      ② expect(container.getElementByClassName('App-logo')).toHaveLength(1);       \\n      ③ expect(container.getElementByClassName('App-logo')[0]).toHaveAttribute('src','logo.svg');\\n    })\\n})\"},{\"type\":\"normal\",\"value\":\"① 이 줄은 \u003cApp /\u003e 컴포넌트를 렌더링한다. render 함수는 컴포넌트를 가상 DOM에 렌더링하고, 반환된 객체에서 container를 구조 분해 할당하여 가져오며 container는 렌더링된 DOM 트리를 포함한다.\\n        ② 이 줄은 container 안에 'App-logo' 클래스를 가진 요소가 하나 있는지 확인한다. expect 함수는 기대값을 설정하는 데 사용되고, toHaveLength(1)는 요소의 길이가 1인지 확인한다.\\n        ③ 이 줄은 'App-logo' 클래스를 가진 첫 번째 요소가 'src' 속성을 가지고 있으며, 그 값이 'logo.svg'인지 확인한다. toHaveAttribute('src', 'logo.svg')는 요소의 src 속성이 'logo.svg'인지를 확인한다.\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"예제 [2] - \u003cimg /\u003e 테스트 코드\"},{\"type\":\"keyword\",\"value\":\"render,getElementsByTagName,toHaveLength,toHaveTextContext\"},{\"type\":\"code\",\"value\":\"describe('\u003cApp /\u003e', ()=\u003e{\\nit('renders component correctly', ()=\u003e{\\n      ①const { container } = render(\u003cApp /\u003e);  \\n      ② expect(container.getElementsByTagName('p')).toHaveLength(1);\\n      ③ expect(container.getElementsByTagName('p')[0]).toHaveTextContext('Edit src/App.js and save to reload.')\\n   })\\n})\"},{\"type\":\"normal\",\"value\":\"① 이 줄은 \u003cApp /\u003e 컴포넌트를 렌더링한다. render 함수는 컴포넌트를 가상 DOM에 렌더링하고, 반환된 객체에서 container를 구조 분해 할당하여 가져오며 container는 렌더링된 DOM 트리를 포함한다.\\n        ② 이 줄은 container 안에 \u003cp\u003e 태그를 가진 요소가 하나 있는지 확인한다. expect 함수는 기대값을 설정하는 데 사용되고, toHaveLength(1)는 해당 요소의 길이가 1인지 확인한다.\\n        ③ 이 줄은 \u003cp\u003e 태그를 가진 첫 번째 요소가 'Edit src/App.js and save to reload.'라는 텍스트 내용을 가지고 있는지 확인한다. expect 함수는 기대값을 설정하는 데 사용되고, toHaveTextContent('Edit src/App.js and save to reload.')는 해당 요소의 텍스트 내용이 정확히 일치하는지를 확인한다.\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"예제 [3] - \u003cp/\u003e 테스트\"},{\"type\":\"code\",\"value\":\"describe('\u003cApp /\u003e', ()=\u003e{\\n  it('renders component correctly', ()=\u003e{\\n      const { container } = render(\u003cApp /\u003e);    \\n      expect(container).toMatchSnapshot();\\n    })\\n})\"},{\"type\":\"normal\",\"value\":\"toMatchSnapshot가 실행되면 src/snapshots/App.test.js.snap이라는 파일이 생성된 것을 확인 할 수 있다. 파일을 열어 내용을 확인해 보면 App 컴포넌트가 화면에 렌더링될 때 표시되는 HTML 내용이 저장된 것을 확인 할 수 있다.\u003c/br\u003e\\n        저장된 스냅샷은 App 컴포넌트가 수정되어 화면에 표시되는 HTML 구조가 변경되면 에러를 표시하게 된다. 이렇게 스냅샷은 화면에 표시되는 컴포넌트가 변경되었는지 감지하기 위한 테스트로 많이 사용된다.\"},{\"type\":\"GuideMessage\",\"value\":\"만약 컴포넌트를 수정하여 화면 표시가 변경된 것이 의도된 수정이었다면 스냅샷 테스트로 저장된 파일을 업데이트해 주어야 한다. 명령프롬프트에 에러가 표시된 상태에서 키보드 'u'키를 누르면 스냅샷으로 생성된 파일이 업데이트 된다. 그러면 새롭게 업데이트된 스냅샷 파일이 다시 기준이 되어 변경을 감지하고 에러를 표시하게 된다.\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"예제 [4] - 스냅샷 (화면에 표시되는 내용이 변경 되었는지 체크)\"},{\"type\":\"keyword\",\"value\":\"getByText,parentElement,toHaveStyleRule\"},{\"type\":\"normal\",\"value\":\"Button 컴포넌트는 Props만을 가지는 단순 컴포넌트이다.\\n        Button 컴포넌트가 화면에 잘 표시 되는지, Props가 잘 적용되는지를 확인하도록 한다.\"},{\"type\":\"code\",\"value\":\"import React from 'react';\\nimport { render, screen } from 'testing-library/react';\\nimport 'jest-styled-components';\\nimport {Button} from './index';\\n\\ndescribe('\u003cButton /\u003e', ()=\u003e{\\n  it('renders component correctly', ()=\u003e{\\n        ① const { container } = render(\u003cButton label=\\\"Button Test\\\" /\u003e);\\n\\n        ② const label = screen.getByText(\\\"button Test\\\");\\n           expect(label).toBeInTheDocument();\\n\\n        ③ const parent = label.parentElement;\\n        ④ expect(parent).toHaveStyleRule('background-color', '#304FFE');\\n          expect(parent).toHaveStyleRule('background-color', '#1E40FF', { modifier:'hover'});\\n        \\n        ⑤ expect(container).toMatchSnapshot();\\n    })\\n})\"},{\"type\":\"normal\",\"value\":\"\\n        ① render 함수는 \u003cButton label=\\\"Button Test\\\" /\u003e를 가상 DOM에 렌더링하고, 반환된 객체에서 container를 구조 분해 할당한다. \u003c/br\u003e\u003c/br\u003e\\n② screen.getByText를 사용하여 \\\"Button Test\\\"라는 텍스트를 가진 요소를 찾는다. \\nexpect로 해당 요소가 문서에 존재하는지 확인한다.\u003c/br\u003e\u003c/br\u003e\\n③ label 요소의 부모 요소(parentElement)를 가져온다.\u003c/br\u003e\u003c/br\u003e\\n\\n④ expect를 사용하여 부모 요소가 특정 스타일 규칙을 가지고 있는지 확인한다. jest-styled-components의 toHaveStyleRule을 사용하여 다음 두 가지 스타일 규칙을 확인한다.\u003c/br\u003e\"},{\"type\":\"stringlist\",\"value\":\"기본 배경색이 #304FFE인지\\n        hover 상태에서 배경색이 #1E40FF인지\"},{\"type\":\"normal\",\"value\":\"backgroundColor과 hoverColor은 우리가 screen.getByText로 찾은 Label 컴포넌트가 아닌 Label 컴포넌트의 부모 요소인 Container 컴포넌트에 설정이 된다. 따라서 label.parentElement를 사용해 Label 컴포넌트의 부모 요소(Container 컴포넌트)에 접근하여 값이 잘 설정 되었는지 확인 한다.\u003c/br\u003e\u003c/br\u003e\\n\\n        Button 컴포넌트는 Props로 BackgroundClolor과 hoverColor이 설정되어 있지 않으면 기본값이 설정되도록 개발 되었다. backgroundColor과 hoverColor가 설정되어 있지 않은 상황에서 기본값이 잘 설정되는지 확인하기 위해 jest-styled-components의 새로운 Matcher인 toHaveStyleRule를 사용하여 확인 하도록 한다.\"},{\"type\":\"normal\",\"value\":\"⑤ 마지막으로, container의 현재 상태를 스냅샷으로 저장하여 이후 테스트 실행 시 컴포넌트의 출력이 변하지 않았는지 확인합니다.\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"예제 [4] - onClick 함수 테스트\"},{\"type\":\"normal\",\"value\":\"Button 컴포넌트의 onClick 함수를 테스트 하기 위한 테스트 명세이다.\"},{\"type\":\"code\",\"value\":\"it('clicks the button', () =\u003e {\\n    ① const handlerClick = jest.fn(); \\n    ② render(\u003cButton label=\\\"Button Test\\\" onClick={handlerClick} /\u003e); \\n    ③ const label = screen.getByText('Button Test'); \\n    ④ expect(handleClick).toHaveBeenCalledTimes(0); \\n    ⑤ fireEvent.click(label); \\n    ⑥ expect(handlerClick).toHaveBeenCalledTimes(1); \\n});\"},{\"type\":\"normal\",\"value\":\"\\n        ① 클릭 핸들러 함수로 jest.fn()을 사용하여 mock 함수 생성 \u003c/br\u003e\\n        ② Button 컴포넌트를 렌더링하고, onClick props에 mock 함수 전달\u003c/br\u003e\\n        ③ 화면에서 \\\"Button Test\\\" 라는 텍스트를 가진 요소를 찾음\u003c/br\u003e\\n        ④ 클릭 이벤트가 발생하지 않았는지 확인\u003c/br\u003e\\n        ⑤ 찾은 요소에 클릭 이벤트를 발생시킴\u003c/br\u003e\\n        ⑥ 클릭 이벤트 핸들러가 한 번 호출되었는지 확인\u003c/br\u003e\\n        \"},{\"type\":\"normal\",\"value\":\"그다음 화면에 표시된 버튼 컴포넌트를 찾아서 아직 해당 컴포넌트를 클릭하지 않았음을 확인하기 위해 toHaveBeenCalledTimes 함수를 사용하여 우리가 만든 모의함수가 잘 호출되었는지 확인해준다.\"},{\"type\":\"GuideMessage\",\"value\":\"\u003cb\u003e모의 함수(Mocking functions)\u003c/b\u003e\u003c/br\u003e\\n        onClick 이벤트에는 사실 어떤 함수가 연결될지 알 수가 없다. jest에서는 이처럼 어떤 이벤트를 통해 함수가 호출되는지를 확인하기 위해 모의 함수(Mocking functions)를 사용한다. 모의 함수를 사용하여 onClick 이벤트를 테스트 한다.\u003c/br\u003e\u003c/br\u003e\\n\\njest의 모의함수(jest.fn)을 사용하여 handlerClick 변수를 선언하고 Button 컴포넌트의 Props로 onClick을 통해 전달 해준다.\\n        \"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"예제 [5] - \u003cInput /\u003e 입력된 값이 일치 체크\"},{\"type\":\"keyword\",\"value\":\"getByDisplayValue,getByPlaceholderText,fireEvent,fireEvent.change\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"getByDisplayValue를 이용하여 input을 찾아 렌더링 하는 예제\"},{\"type\":\"code\",\"value\":\"import React from 'react';\\nimport { render, screen, fireEvent } from 'testing-library/react';\\nimport 'jest-styled-components';\\nimport {Input} from './index';\\n\\ndescribe('\u003cInput /\u003e', ()=\u003e{\\n\\tit('renders component correctly', ()=\u003e{\\n      ① const { container } = render(\u003cInput value=\\\"default value\\\" /\u003e);\\n      ② const label = screen.getByDisplayValue(\\\"default value\\\");\\n      ③ expect(label).toBeInTheDocument();\\n      ④ expect(container).toMatchSnapshot();\\n   })\\n})\"},{\"type\":\"normal\",\"value\":\"이 코드는 React 컴포넌트 \u003cInput /\u003e를 테스트하기 위해 작성된 Jest 테스트 파일이다. react-testing-library와 jest-styled-components를 사용하여 \u003cInput /\u003e 컴포넌트의 렌더링 및 동작을 한다.\"},{\"type\":\"normal\",\"value\":\"① render 함수는 \u003cInput /\u003e 컴포넌트를 렌더링합니다. 여기서 value prop으로 \\\"default value\\\"를 설정합니다.\u003c/br\u003e\\n② screen.getByDisplayValue 함수는 주어진 값(\\\"default value\\\")을 표시하는 요소를 검색합니다.\u003c/br\u003e\\n　여기서는 \u003cInput /\u003e 컴포넌트가 \\\"default value\\\"라는 값을 가진 입력 필드를 렌더링하는지 확인합니다.\u003c/br\u003e\\n③ expect 함수는 단언(assertion)을 정의합니다. 여기서는 label 요소가 문서 내에 존재하는지 확인합니다.\\n　toBeInTheDocument 매처는 요소가 실제로 DOM에 존재하는지 확인합니다.\"},{\"type\":\"normal\",\"value\":\"Input 컴포넌트는 Button 컴포넌트와 다르게 필수 Props가 존재하지 않는다. 따라서 화면에 표시되었는지를 알기 위해 검색(Query)할 방법이 없다. \u003c/br\u003e\\n\\n그래서 Input 컴포넌트의 필수가 아닌 Props인 value값을 설정하고 react-testing-library의 screen.getByDisplayValue를 사용하여 input 컴포넌트를 찾는다.\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"getByPlaceholderText를 이용하여 input을 찾아 렌더링 하는 예제\"},{\"type\":\"code\",\"value\":\"it('renders placeholder correctly', ()=\u003e{\\n    render(\u003cInput placeholder=\\\"default placeholder\\\" /\u003e);\\n\\n    const input = screen.getByPlaceholderText(\\\"default placeholder\\\");\\n    expect(input).toBeInTheDocument();        \\n})\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"fireEvent를 이용하여 이벤트 테스트 하는 예제\"},{\"type\":\"code\",\"value\":\"import { render, screen, fireEvent } from 'testing-library/react';\\n\\nit('renders placeholder correctly', ()=\u003e{\\n    render(\u003cInput placeholder=\\\"default placeholder\\\" /\u003e);\\n        \\n    const input = screen.getByPlaceholderText(\\\"default placeholder\\\") as HTMLInputElement;\\n        \\n    fireEvent.change(input, {target:{ value:'study react'}})\\n    expect(input.value).toBe('study react')\\n})\"},{\"type\":\"normal\",\"value\":\"Input 컴포넌트의 placeholder를 사용하여 Input 컴포넌트를 화면에 표시하고 해당컴포넌트를 getByPlaceholderText를 통해 찾았다. 이렇게 찾은 컴포넌트는 기본적으로 HTMLElement타입이다. 하지만 HTML의 input 태그를 사용하고 있으므로, 타입스크립트의 as를 사용하여 HTMLInputElement로 타입변환을 해준다.\"},{\"type\":\"normal\",\"value\":\"fireEvent의 change함수로 실제 사용자가 데이터를 입력하는 테스트 코드를 작성 해준다.\\n앞에서 찾은 Input 컴포넌트에 데이터를 입력해주고 입력된 데이터가 실제로 화면에 잘 표시 되고 있는지를 확인하기 위해 toBe를 사용하여 input, value값이 우리가 fireEvent를 사용하여 입력한 값과 같은지 확인 하였다.\"}]},\"nextPostTile\":{\"id\":24,\"title\":\"Function.prototype.bind()\",\"date\":\"2024-03-22 10:43:02\",\"folder\":\"Javascript\",\"tag\":[\"JavaScript\"],\"preview\":\"HTML(하이퍼텍스트 마크업 언어)에서 속성(Attribute)과 프로퍼티(Property)는 특정 요소에 대한 정보를 지정하는 데 사용되는 용어입니다. 그러나 두 용어 간에는 몇 가지 차이가 있습니다.\",\"post\":[{\"type\":\"normal\",\"value\":\"Function.prototype.bind는 자바스크립트에서 함수를 생성하고 호출할 때 this 키워드의 값을 고정시키는 메소드이다. \u003c/br\u003e 이 메소드를 사용하면 함수를 호출할 때 함수 내부에서 사용되는 this가 특정한 객체로 고정된다.\\n        \u003c/br\u003e함수 메소드 call, apply, bind가 공통적으로 첫번째 매개 변수를 this 값으로 지정할 수 있다.\\n\\n      \"},{\"type\":\"code\",\"value\":\"function greet() {\\n    console.log(`Hello, ${this.name}!`);\\n}\\n\\nconst person = {\\n    name: 'Alice'\\n};\\n\\ngreet.call(person); // \\\"Hello, Alice!\\\"\\ngreet.apply(person); // \\\"Hello, Alice!\\\"\\n  \"},{\"type\":\"normal\",\"value\":\"위 코드에서 call과 apply를 사용하여 greet 함수를 호출할 때, this는 person 객체를 가리켜 this값을 명시적으로 지정해 주었다. 단, bind는 call, apply와 달리 새로운 함수를 반환한다는 특징이 있다. 아래는 bind를 사용한 예제이다.\"},{\"type\":\"code\",\"value\":\"const module = {\\n  x: 42,\\n  getX: function() {\\n    return this.x;\\n  }\\n};\\n\\nconst unboundGetX = module.getX;\\nconsole.log(unboundGetX()); // undefined\\n\"},{\"type\":\"normal\",\"value\":\"코드에서 module 객체에는 x라는 속성과 getX라는 메서드가 있다.\\n      unboundGetX는 getX 메서드를 가리키는데 이때 this는 호출 시점에 따라 결정된다. 그러므로 unboundGetX()를 호출하면 this는 전역객체를 가리키므로 x는 정의되지 않은 것으로 취급되어 undefined를 반환한다.\\n     \"},{\"type\":\"normal\",\"value\":\"이번에는 bind 메서드를 사용한 예제를 보도록 하자. \"},{\"type\":\"code\",\"value\":\"const module = {\\n  x: 42,\\n  getX: function() {\\n    return this.x;\\n  }\\n};\\n\\nconst unboundGetX = module.getX;\\nconst boundGetX = unboundGetX.bind(module);\\nconsole.log(boundGetX()); // 42\"},{\"type\":\"normal\",\"value\":\"위에서 unboundGetX 함수를 module 객체에 바인딩하여 boundGetX를 생성한다.\\n      이제 boundGetX()를 호출하면 this는 module 객체를 가리키므로 x의 값인 42를 반환한다.\\n      \"},{\"type\":\"normal\",\"value\":\"bind를 사용하면 함수의 this를 명시적으로 지정할 수 있어서, 함수를 다른 컨텍스트에서 호출할 때 유용하다. 또한 매개변수를 미리 지정하여 부분적으로 함수를 실행하는 것도 가능하다.\"}]},\"segment\":\"posts\"}],[\"$\",\"div\",null,{\"className\":\"footer_footer_container__MsSvO\",\"children\":[\"$\",\"footer\",null,{\"className\":\"footer_footer__AwYty\",\"children\":[[\"$\",\"p\",null,{\"className\":\"footer_copylight___J5l0\",\"children\":[\"© 2024 \",\"베짱이가 되고싶은 개미。\",\" Some rights reserved.\"]}],[\"$\",\"p\",null,{\"className\":\"footer_theme__bwXbg\",\"children\":\"portfolio v1.0.0-alpha.3\"}]]}]}]],null]]},[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"tags\",\"children\",\"$b\",\"children\",\"$c\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Ld\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/19d2a4a42355ad75.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]]},[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"tags\",\"children\",\"$b\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Ld\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"tags\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Ld\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]],\"search\":[\"__DEFAULT__\",{},[\"$e\",\"$L10\",null]]},[null,[\"$\",\"$L11\",null,{\"children\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Ld\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}],\"search\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"search\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"search\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Ld\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$12\",\"styles\":null}],\"params\":{}}],null]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"className\":\"\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css\",\"as\":\"style\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.googleapis.com\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.gstatic.com\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR\u0026display=swap\",\"as\":\"style\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Ld\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":\"$13\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":\"$14\",\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":\"$15\",\"children\":[\"$\",\"h2\",null,{\"style\":\"$16\",\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0c496b0e03d530ba.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]}]]}],null]],\"initialHead\":[false,\"$L17\"],\"globalErrorComponent\":\"$18\"}]]\n"])</script><script>self.__next_f.push([1,"10:E{\"digest\":\"NEXT_NOT_FOUND\"}\n"])</script><script>self.__next_f.push([1,"17:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"be come 💡\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"App for an Ant Who Wants to Become a Bejjangyi\"}]]\n6:null\nf:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>