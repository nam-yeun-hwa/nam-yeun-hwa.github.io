2:I[5250,["250","static/chunks/250-8b90be581650ff9d.js","399","static/chunks/399-caf055eb211349e2.js","216","static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-de099b9b992ac994.js"],""]
3:I[8843,["250","static/chunks/250-8b90be581650ff9d.js","399","static/chunks/399-caf055eb211349e2.js","216","static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-de099b9b992ac994.js"],""]
4:I[777,["250","static/chunks/250-8b90be581650ff9d.js","399","static/chunks/399-caf055eb211349e2.js","216","static/chunks/app/(layoutCase)/tags/%5Btagname%5D/%5Bpostid%5D/page-de099b9b992ac994.js"],""]
5:I[5613,[],""]
8:I[1778,[],""]
c:I[3866,["250","static/chunks/250-8b90be581650ff9d.js","399","static/chunks/399-caf055eb211349e2.js","46","static/chunks/46-f5c36f830a2ce4c4.js","730","static/chunks/730-f56ebe909f1c8bdb.js","35","static/chunks/35-3694012f9af267d1.js","464","static/chunks/app/(layoutCase)/layout-7db96f987c2804cf.js"],""]
6:["tagname","JWT","d"]
7:["postid","67","d"]
9:"$La"
d:[]
e:{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"}
f:{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"}
10:{"display":"inline-block"}
11:{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0}
0:["6_0NjRtXpaN2yIfU-USlT",[[["",{"children":["(layoutCase)",{"children":["tags",{"children":[["tagname","JWT","d"],{"children":[["postid","67","d"],{"children":["__PAGE__?{\"tagname\":\"JWT\",\"postid\":\"67\"}",{}]}]}]}],"search":["__DEFAULT__",{}]}]},"$undefined","$undefined",true],["",{"children":["(layoutCase)",{"children":["tags",{"children":[["tagname","JWT","d"],{"children":[["postid","67","d"],{"children":["__PAGE__",{},["$L1",[[["$","article",null,{"className":"$undefined","children":["$","header",null,{"children":["$","h1",null,{"className":"postUserInfo_h1__uhAqy","children":"[TECH-QA] 리플로우(Reflow)와 리페인트(Repaint)는 브라우저의 렌더링 과정"}]}]}],["$","div",null,{"className":"postUserInfo_post_meta__ABvuC","children":[["$","span",null,{"children":["Posted"," ",["$","time",null,{"className":"postUserInfo_time__2exyR","children":["11 days"," "]}]]}],["$","span",null,{"className":"postUserInfo_update__f345P","children":["Updated"," ",["$","time",null,{"className":"postUserInfo_time__2exyR","children":"11 days"}]]}]]}],["$","div",null,{"children":["$","span",null,{"className":"postUserInfo_post_meta__ABvuC","children":["By"," ",["$","em",null,{"children":["$","$L2",null,{"href":"https://nam-yeun-hwa.github.io/","className":"postUserInfo_author__fVGYM","children":"베짱이가 되고싶은 개미。"}]}]]}]}]],[["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"리플로우(Reflow)와 리페인트(Repaint)는 브라우저의 렌더링 과정에서 발생하는 두 가지 중요한 단계로, 웹 페이지의 시각적 업데이트와 관련이 있습니다. 이들은 DOM이나 CSS의 변경으로 인해 요소의 레이아웃이나 스타일이 수정될 때 브라우저가 화면을 다시 그리는 과정에서 발생합니다. 먼저 브라우저의 렌더링 과정을 설명하겠습니다. 브라우저 렌더링은 웹 페이지를 화면에 표시하기 위해 여러 단계를 거칩니다. 아래는 주요 단계를 간단히 설명한 내용입니다."}}],[false,["$","h2",null,{"className":"heading_h2__fsXMw","style":{"fontWeight":"NORMAL"},"children":"브라우저 렌더링 과정"}],false,false],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","DOM 및 CSSOM 생성"]}]],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"HTML을 파싱하여 DOM(Document Object Model) 트리를 생성합니다."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"CSS를 파싱하여 CSSOM(CSS Object Model) 트리를 생성합니다."}}]]}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","렌더 트리(Render Tree) 생성"]}]],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"DOM과 CSSOM을 결합하여 실제 화면에 표시할 요소들로 구성된 렌더 트리를 만듭니다. 표시되지 않는 요소(예: display: none)는 포함되지 않습니다."}}]]}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","레이아웃(Layout, Reflow)"]}]],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"렌더 트리의 각 요소의 위치와 크기를 계산합니다. 이 과정에서 뷰포트 크기, 요소의 스타일 등이 반영됩니다."}}]]}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","페인트(Paint, Repaint)"]}]],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"계산된 렌더 트리를 기반으로 픽셀 단위로 화면에 그리는 과정을 수행합니다. 색상, 이미지, 텍스트 등이 포함됩니다."}}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","컴포지팅(Compositing)"]}]],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"페인트된 레이어를 합성하여 최종 화면을 렌더링합니다. GPU를 활용하여 레이어 이동, 변형(예: transform: translateX(100px)) 등을 효율적으로 처리합니다."}}],[false,["$","h2",null,{"className":"heading_h2__fsXMw","style":{"fontWeight":"NORMAL"},"children":"리플로우(Reflow)란?"}],false,false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"리플로우는 브라우저가 요소의 <b>레이아웃(크기, 위치 등)</b>을 다시 계산하는 과정입니다. 이는 렌더 트리의 구조나 요소의 기하학적 속성(예: 너비, 높이, 위치)이 변경될 때 발생합니다. 리플로우는 레이아웃 단계에서 수행되며, 변경된 요소뿐만 아니라 그에 영향을 받는 다른 요소(예: 부모, 자식, 형제 요소)의 레이아웃도 재계산할 수 있습니다."}}],[false,false,["$","h3",null,{"className":"heading_h3__UisKt","style":{"fontWeight":"NORMAL"},"children":"리플로우의 비용"}],false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"리플로우는 계산량이 많아 성능에 큰 영향을 미칩니다. 특히, 변경된 요소가 다른 요소(예: 부모나 자식)에 영향을 미치면 전체 렌더 트리 또는 큰 부분을 재계산해야 할 수 있습니다.\n페이지가 복잡하거나 요소가 많을수록 리플로우 비용이 증가합니다."}}],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"기하학적 속성 변경: width, height, margin, padding, border, top, left, position 등."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"박스 모델 관련 속성 변경: box-sizing, display (예: block → none)."}}]]}],[false,["$","h2",null,{"className":"heading_h2__fsXMw","style":{"fontWeight":"NORMAL"},"children":"리페인트(Repaint)란?"}],false,false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"리페인트는 요소의 시각적 스타일(예: 색상, 배경, 그림자 등)이 변경되었을 때, 브라우저가 해당 요소를 화면에 다시 그리는 과정입니다. 리페인트는 페인팅 단계에서 수행되며, 레이아웃(예: 크기나 위치) 변경 없이 스타일만 업데이트합니다."}}],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"color, background-color, box-shadow, border-color, visibility 등."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"opacity 변경 (단, GPU 가속이 적용되면 리페인트를 피할 수 있음)."}}]]}],[false,false,["$","h3",null,{"className":"heading_h3__UisKt","style":{"fontWeight":"NORMAL"},"children":"리페인트의 비용"}],false],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"리페인트는 리플로우보다 계산 비용이 적습니다. 레이아웃을 재계산하지 않고 픽셀만 다시 그리기 때문입니다."}}]]}],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"그러나 페이지에 많은 요소가 있거나 복잡한 스타일(예: 그림자, 그라디언트)이 적용된 경우 리페인트도 성능에 영향을 줄 수 있습니다."}}],[false,["$","h2",null,{"className":"heading_h2__fsXMw","style":{"fontWeight":"NORMAL"},"children":"리플로우와 리페인트의 관계"}],false,false],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"<b>리플로우 → 리페인트</b>: 리플로우는 레이아웃을 변경하므로, 레이아웃이 바뀐 요소는 다시 그려져야 하므로 리페인트가 발생합니다."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"<b>리페인트만 발생</b>: 레이아웃에 영향을 주지 않는 스타일 변경(예: color, background)은 리페인트만 유발합니다."}}],["$","li","2",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"<b>컴포지팅</b>: <span class=\"point\">현대 브라우저에서는 transform이나 opacity 같은 속성 변경은 레이아웃이나 페인팅 없이 컴포지팅 단계에서 처리됩니다. 이는 리플로우와 리페인트를 모두 피할 수 있어 성능이 뛰어납니다.</span> "}}]]}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","리플로우와 리페인트의 예시"]}]],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"다음은 React 컴포넌트에서 버튼 클릭 시 박스의 스타일을 변경하여 리플로우와 리페인트를 유발하는 예제입니다."}}],["$","$L3",null,{"code":"// src/App.jsx\n\t\t\t\t\nimport { useState } from 'react';\n\nfunction App() {\n  const [boxStyle, setBoxStyle] = useState({\n    width: '200px',\n    height: '100px',\n    margin: '20px',\n    backgroundColor: 'lightblue',\n  });\n\n  const changeStyle = () => {\n    setBoxStyle({\n      width: '300px', // 리플로우 유발 (레이아웃 변경)\n      height: '150px', // 리플로우 유발\n      margin: '30px', // 리플로우 유발\n      backgroundColor: 'lightgreen', // 리페인트 유발\n    });\n  };\n\n  return (\n    <div>\n      <h1>리플로우와 리페인트 예제</h1>\n      <div style={boxStyle}>\n        테스트 박스\n      </div>\n      <button onClick={changeStyle}>스타일 변경</button>\n    </div>\n  );\n}\n\nexport default App;","children":"$undefined"}],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"<b>리플로우 유발</b> : width, height, margin 변경은 요소의 레이아웃을 수정하므로 리플로우가 발생합니다. 이는 박스 모델의 크기와 위치를 재계산합니다."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"<b>리페인트 유발</b> : backgroundColor 변경은 레이아웃에 영향을 주지 않으므로 리페인트만 발생합니다. 하지만 위에서 리플로우가 발생했으므로 리페인트는 포함됩니다."}}],["$","li","2",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"<b>문제점</b> </br> - 여러 스타일 변경이 개별적으로 적용되면 React의 상태 업데이트로 인해 불필요한 리렌더링이 발생할 수 있습니다. </br> - 레이아웃 변경은 성능 비용이 크므로 빈번한 변경 시 사용자 경험이 저하될 수 있습니다."}}]]}],[false,["$","h2",null,{"className":"heading_h2__fsXMw","style":{"fontWeight":"NORMAL"},"children":"컴포지팅 활용 및 React 최적화"}],false,false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"이 예제는 리플로우와 리페인트를 최소화하기 위해 <b>transform과 같은 컴포지팅 속성을 사용</b> 하고, React의 렌더링 최적화 기법을 적용합니다."}}],["$","$L3",null,{"code":"// src/App.jsx\n\nimport { useState, useCallback } from 'react';\nimport './App.css';\n\nfunction App() {\n  const [isTransformed, setIsTransformed] = useState(false);\n  const [isColorChanged, setIsColorChanged] = useState(false);\n\n  const toggleTransform = useCallback(() => {\n    setIsTransformed((prev) => !prev);\n  }, []);\n\n  const toggleColor = useCallback(() => {\n    setIsColorChanged((prev) => !prev);\n  }, []);\n\n  return (\n    <div>\n      <h1>최적화된 리플로우/리페인트 예제</h1>\n      <div\n        className={\"box ${isTransformed ? \"transformed\" : \"\"} ${\n          isColorChanged ? \"color-changed\" : \"\"\n        }\"}\n      >\n        테스트 박스\n      </div>\n      <button onClick={toggleTransform}>위치 이동 (Transform)</button>\n      <button onClick={toggleColor}>색상 변경</button>\n    </div>\n  );\n}\n\nexport default App;","children":"$undefined"}],["$","$L3",null,{"code":"/* src/App.css */\n.box {\n  width: 200px;\n  height: 100px;\n  margin: 20px;\n  background-color: lightblue;\n  transition: transform 0.3s ease, background-color 0.3s ease;\n}\n\n.transformed {\n  transform: translateX(100px); /* 컴포지팅만 유발 */\n}\n\n.color-changed {\n  background-color: lightgreen; /* 리페인트만 유발 */\n}","children":"$undefined"}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","컴포지팅 활용"]}]],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"transform: translateX(100px)는 레이아웃이나 픽셀을 다시 계산하지 않고 GPU를 활용해 컴포지팅 단계에서 처리됩니다. 이는 리플로우와 리페인트를 피합니다."}}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","리페인트만 유발"]}]],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"background-color 변경은 리페인트만 유발하며, 레이아웃에 영향을 주지 않습니다."}}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","React 최적화"]}]],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"<b>클래스 기반 스타일 변경</b>: style 객체를 직접 변경하는 대신 CSS 클래스를 토글하여 리렌더링 비용을 줄입니다."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"<b>CSS 애니메이션</b>: transition 속성을 사용해 부드러운 애니메이션을 구현하며, 브라우저의 최적화(GPU 가속)를 활용합니다."}}]]}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","브라우저 개발자 도구 활용"]}]],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"Chrome DevTools의 Performance 탭에서 리플로우와 리페인트를 기록하여 어떤 속성이 성능 병목을 일으키는지 확인."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"Rendering 탭에서 \"Paint Flashing\"을 활성화하면 리페인트 영역을 시각적으로 확인 가능."}}]]}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","Core Web Vitals 고려"]}]],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"<span class=\"point\">리플로우</span>는 <b>CLS(Cumulative Layout Shift)를 유발</b>할 수 있으므로, 레이아웃 이동을 최소화.\n<span class=\"point\">리페인트</span>는 <b>LCP(Largest Contentful Paint)에 영향</b>을 줄 수 있으므로, 중요한 콘텐츠의 렌더링을 최적화 하여 사용 하도록 합니다."}}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","라이브러리 사용"]}]],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"React에서 애니메이션을 위해 framer-motion이나 react-spring 같은 라이브러리를 사용하면 컴포지팅을 자동으로 활용 가능합니다."}}]],["$","$L4",null,{"postid":67,"prePostTitle":{"id":68,"title":"[TECH-QA] 애니메이션 분석 (Reflow와 Repaint 이론)","date":"2025-04-22 12:54:33","folder":"Javascript","tag":["브라우저","TECH-QA","Reflow","Repaint","리플로우","리페인트","웹성능 최적화"],"preview":"웹 애니메이션 이미지를 보고 전체적인 흐름에 따라 리플로우 리페인트 쟁크현상 병목현상등을 알아보고 이해하는 시간을 가지려고 합니다.","post":[{"type":"normal","value":"웹 애니메이션 이미지를 보고 전체적인 흐름에 따라 리플로우 리페인트 쟁크현상 병목현상등을 알아보고 이해하는 시간을 가지려고 합니다."},{"type":"ImageLoader","value":"리플로우(Reflow)란?","imageloader":{"imgPath":"ImageOptimizationSample1.jpg","alt":"이미지최적화 샘플1","width":"55%","round":"12px"}},{"type":"normal","value":"그래프를 클릭하거나 페이지에 들어서면 애니메이션이 실행되는 페이지이다."},{"type":"ImageLoader","value":"","imageloader":{"imgPath":"ImageOptimizationSample2.jpg","alt":"이미지최적화 샘플2","width":"80%","round":"12px"}},{"type":"normal","value":"위의 이미지에서 Timings는 그래프를 클릭 할때마다 리액트 함수가 실행되는 타이밍을 보여주고 있으며 그 타이밍에 맞춰 브라우저에 화면을 그리는 작업을 수행하는 내용을 아래 에서 확인 할 수 있다."},{"type":"ImageLoader","value":"","imageloader":{"imgPath":"ImageOptimizationSample3.jpg","alt":"이미지최적화 샘플3","width":"80%","round":"12px"}},{"type":"normal","value":"Timings 아래 부분을 확대해 보았다. 애니메이션을 변경될때마다 브라우저에 렌더링 하는 과정을 반복하는 것을 확인 할 수 있다."},{"type":"stringlist","value":"➀ 스타일을 다시 계산하고 (dom tree, cssom tree를 생성하고 렌더 트리를 새로 생성 과정)\n➁ 레이아웃 과정\n③ 페인트 과정\n③ 레이어 합성 과정"},{"type":"normal","value":"5번의 경우 점선이 그어져 있는데 이 점선은 브라우저 화면에 렌더링 화면이 노출되어야 하는 시점이다. 하지만 마지막 레이어 합성과정이 완료 되지 않은 상태로 보여 진다.\n\n위와 같은 현상이 일어나면 프레임이 드랍되거나 쟁크 현상이 일어나 애니메이션이 매끄럽지 않다.\n\n이럴때는 reflow을 일으키는 속성들 사용 보다는 repaint를 일으키는 속성이나 layout, paint 단계를 건너띌수 있는 transform 속성을 사용 하는 것이 좋다.\n"},{"type":"Heading","headingType":"h2","value":"Reflow, Repaint를 피하여 CSS 애니메이션 최적화하기"},{"type":"code","value":".style_ani{\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: ${({ width }) => width}%;\n    transition: width 1.5s ease;\n    height: 100%;\n    background: ${({ isSelected }) => isSelected ? 'rgba(126, 198, 81, 0.7)' : 'rgb(198, 198, 198)'};\n    z-index: 1;}"},{"type":"normal","value":"위 css는 width값을 이용하여 애니메이션을 적용하는 리액트의 스타일 컴포넌트이다. 이 내용을 scaleX 속성을 이용하여 변경하여 Reflow, Repaint 피하고 GPU 도움 받아 렌더링 하도록 변경한다."},{"type":"code","value":".style_ani{\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    transform: scaleX(${props => props.width / 100});\n    transform-origin: center left;\n    transition: width 1.5s ease;\n    height: 100%;\n    background: ${({ isSelected }) => isSelected ? 'rgba(126, 198, 81, 0.7)' : 'rgb(198, 198, 198)'};\n    z-index: 1;"},{"type":"normal","value":"scaleX의 축은 가운데를 기준으로 스케일이 변경되기 때문에 transform-origin 속성을 추가하여 세로는 가운데로 가로는 왼쪽으로 스케일이 변경 되도록 수정한다.\n\n또 애니메이션이 transform에 적용되도록 transition 속성의 값을 transform으로 변경하여 준다."},{"type":"Heading","headingType":"h2","value":"애니메이션 Reflow에서 GPU사용으로 변경 후"}]},"nextPostTile":{"id":66,"title":"[TECH-QA] 브라우저 렌더링 과정","date":"2025-04-17 12:06:33","folder":"Javascript","tag":["브라우저","TECH-QA"],"preview":"브라우저의 HTML 렌더링은 웹 페이지를 화면에 표시하기 위해 브라우저가 HTML, CSS, JavaScript 등의 리소스를 처리하고 시각적으로 표현하는 과정입니다. 이 과정은 브라우저의 렌더링 엔진(예: Chrome의 Blink, Firefox의 Gecko, Safari의 WebKit)에 의해 수행되며, 여러 단계로 나눌 수 있습니다. 아래에서 이 과정을 자세히 설명하겠습니다.","post":[{"type":"normal","value":"브라우저의 HTML 렌더링은 <b>웹 페이지를 화면에 표시</b>하기 위해 브라우저가 <b>HTML, CSS, JavaScript 등의 리소스를 처리하고 시각적으로 표현하는 과정</b>입니다. 이 과정은 브라우저의 렌더링 엔진(예: Chrome의 Blink, Firefox의 Gecko, Safari의 WebKit)에 의해 수행되며, 여러 단계로 나눌 수 있습니다. 아래에서 이 과정을 자세히 설명하겠습니다."},{"type":"Heading","headingType":"h2","value":"브라우저 렌더링 과정의 개요"},{"type":"normal","value":"브라우저는 HTML 문서를 받아 화면에 렌더링하기 위해 다음 주요 단계를 거칩니다."},{"type":"stringlist","value":"HTML 파싱 및 DOM 생성\nCSS 파싱 및 CSSOM 생성\n렌더 트리(Render Tree) 생성\n레이아웃(Layout, Reflow)\n페인팅(Painting)\n컴포지팅(Compositing, 선택적)"},{"type":"normal","value":"이 과정은 <b>Critical Rendering Path(CRP, 중요 렌더링 경로)</b>라고 불리며, 웹 페이지 로딩 속도와 사용자 경험에 직접적인 영향을 미칩니다."},{"type":"Heading","headingType":"h3","value":"HTML 파싱 및 DOM 생성"},{"type":"stringlist","value":"<b>HTML 파싱</b>: 브라우저는 서버로부터 받은 HTML 파일을 바이트 단위로 읽어 문자를 해석하고, 이를 토큰(예: 태그, 속성, 텍스트)으로 변환합니다. 이 토큰들은 트리 구조로 조직화됩니다.\n<b>DOM(Document Object Model) 생성</b>: 파싱된 HTML은 계층적 트리 구조인 DOM으로 변환됩니다. DOM은 HTML 요소와 그 관계를 나타내는 객체 모델로, 각 요소는 노드로 표현됩니다.</br> - 예) <span class=\"point\">&lt;div>&lt;p>Hello&lt;/p>&lt;/div>는 &lt;div>와 &lt;p>가 부모-자식 관계로 DOM 트리에 추가됩니다.</span> "},{"type":"stringlist","value":"비동기 리소스 처리: HTML 파싱 중 &lt;script>, &lt;img>, &lt;link> 등의 외부 리소스를 만나면 브라우저는 해당 리소스를 병렬적으로 요청합니다. 단, &lt;script> 태그는 기본적으로 파싱을 차단(blocking)할 수 있으므로 async 또는 defer 속성을 사용하는 것이 일반적입니다."},{"type":"Heading","headingType":"h3","value":"CSS 파싱 및 CSSOM 생성"},{"type":"stringlist","value":"<b>CSS 파싱</b>: HTML 파싱과 병렬적으로, 브라우저는 &lt;link> 태그나 &lt;style> 태그를 통해 CSS 파일 또는 스타일을 읽습니다. CSS도 토큰화되고 파싱되어 트리 구조로 변환됩니다.\n<b>CSSOM(CSS Object Model) 생성</b>: 파싱된 CSS는 CSSOM이라는 트리 구조로 저장됩니다. CSSOM은 각 요소에 적용될 스타일 규칙(예: color, margin)을 정의합니다.\nCSS는 계층적이며, 상속과 우선순위(예: !important, 선택자 특이성)에 따라 스타일이 결정됩니다.\n<b>렌더링 차단</b>: CSS는 렌더링을 차단하는 리소스입니다. CSSOM이 완성되기 전에는 화면 렌더링이 시작되지 않으므로, CSS 파일을 최적화(예: 최소화, 인라인 CSS 사용)하는 것이 중요합니다."},{"type":"Heading","headingType":"h3","value":"렌더 트리(Render Tree) 생성"},{"type":"stringlist","value":"<b>DOM과 CSSOM 결합</b>: 브라우저는 DOM과 CSSOM을 결합하여 <b>렌더 트리를 생성</b>합니다. 렌더 트리는 화면에 실제로 표시될 요소들만 포함합니다.</br> - 예) display: none이 적용된 요소나 <head> 내부의 메타데이터는 렌더 트리에 포함되지 않습니다.\n렌더 트리는 각 노드에 대해 스타일 정보(예: 색상, 크기)와 구조적 정보를 포함합니다.\n<b>렌더 트리의 역할</b>: <u>렌더 트리는 레이아웃 단계에서 요소의 크기와 위치를 계산</u>하는 데 사용됩니다."},{"type":"Heading","headingType":"h2","value":"레이아웃(Layout, Reflow)"},{"type":"stringlist","value":"<b>박스 모델 기반 계산</b>: 렌더 트리의 각 노드는 <b>CSS 박스 모델(콘텐츠, 패딩, 테두리, 마진)을 기반</b>으로 <u>크기와 위치를 계산</u>합니다.\n<b>뷰포트 기준 배치</b>: 브라우저는 뷰포트(화면 크기)를 기준으로 요소의 정확한 위치(x, y 좌표)와 크기(width, height)를 결정합니다.</br> - 예: position: absolute는 부모 요소를 기준으로, float는 주변 콘텐츠 흐름에 따라 배치됩니다.\n<b>리플로우(Reflow)</b>: 레이아웃 계산은 초기 렌더링뿐만 아니라 DOM이나 CSS 변경(예: JavaScript로 스타일 변경, 창 크기 조정) 시에도 발생할 수 있습니다. 리플로우는 성능에 큰 영향을 미치므로 최소화해야 합니다."},{"type":"Heading","headingType":"h2","value":"페인팅(Painting)"},{"type":"stringlist","value":"<b>픽셀 변환</b>: 레이아웃 단계에서 계산된 <b>렌더 트리를 기반으로, 브라우저는 각 요소를 화면의 픽셀로 변환</b>합니다.</br> - 색상, 그림자, 텍스트, 이미지 등 시각적 스타일이 적용됩니다.\n<b>레이어(Layer)</b>: 복잡한 페이지에서는 요소를 여러 레이어로 나누어 페인팅합니다. </br>예) transform이나 opacity를 사용하는 요소는 별도의 레이어로 처리될 수 있습니다.\n<b>GPU 가속</b>: 현대 브라우저는 <b>GPU를 활용해 페인팅을 가속화</b>합니다. <b>CSS 속성 중 will-change를 사용</b>하면 특정 요소의 렌더링을 최적화할 수 있습니다."},{"type":"Heading","headingType":"h4","value":"will-change를 사용한 CSS 애니메이션 최적화"},{"type":"code","value":"<!DOCTYPE html>\n<html lang=\"ko\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>will-change 예시</title>\n  <style>\n    .box {\n      width: 100px;\n      height: 100px;\n      background-color: #3498db;\n      position: relative;\n      transition: transform 0.3s ease;\n      /* 브라우저에 transform 변경을 미리 알림 */\n      will-change: transform;\n    }\n\n    .box:hover {\n      transform: translateX(200px); /* 마우스 호버 시 이동 */\n    }\n  </style>\n</head>\n<body>\n  <div class=\"box\"></div>\n</body>\n</html>","codePreviewProps":true},{"type":"stringlist","value":"<b>will-change</b>: transform;: 브라우저에 .box 요소의 transform 속성이 변경될 것임을 알려, 해당 요소를 GPU 레이어로 승격시켜 렌더링을 가속화합니다.\n<b>효과</b>: 마우스를 .box 위에 올리면 요소가 부드럽게 200px 오른쪽으로 이동합니다. will-change로 인해 브라우저는 이 변환을 미리 준비하여 렌더링 성능을 최적화합니다.\n<b>주의사항</b> </br> - will-change를 과도하게 사용하면 메모리 사용량이 증가할 수 있으므로, 실제로 애니메이션이나 변경이 빈번한 요소에만 적용하세요. </br> - 애니메이션이 끝난 후에는 will-change를 제거하는 것이 좋습니다(예: JavaScript로 동적으로 추가/제거)."},{"type":"Heading","headingType":"h4","value":"스크롤 애니메이션"},{"type":"code","value":".scroll-element {\n  position: fixed;\n  top: 0;\n  will-change: transform;\n  transition: transform 0.5s ease;\n}\n\n/* JavaScript로 스크롤 시 transform 변경 */\ndocument.addEventListener('scroll', () => {\n  document.querySelector('.scroll-element').style.transform = \"translateY(${window.scrollY}px)\";\n});"},{"type":"normal","value":"이 경우, will-change: transform은 스크롤에 따른 요소 이동을 GPU로 처리하여 부드러운 렌더링을 보장합니다. will-change는 GPU 가속을 활용해 애니메이션이나 전환 성능을 개선하지만, 적절히 사용해야 리소스 낭비를 피할 수 있습니다. 위 예시는 transform에 초점을 맞췄지만, opacity, scroll-position 등 다른 속성에도 적용 가능합니다."},{"type":"Heading","headingType":"h2","value":"컴포지팅(Compositing, 선택적)"},{"type":"stringlist","value":"<b>레이어 합성</b>: 페인팅된 레이어를 최종적으로 합쳐 화면에 표시합니다. 컴포지팅은 GPU를 활용해 빠르게 수행됩니다.\n<b>애니메이션 최적화</b>: transform이나 opacity 같은 속성은 레이아웃이나 페인팅을 유발하지 않고 컴포지팅 단계에서만 처리되므로 성능이 좋습니다.\n<b>성능 고려</b>: 컴포지팅은 리플로우나 리페인팅보다 비용이 적으므로, 애니메이션에 적합한 속성을 사용하는 것이 중요합니다."},{"type":"Heading","headingType":"h2","value":"박스 모델과의 연관성"},{"type":"normal","value":"CSS 박스 모델은 렌더링 과정, 특히 레이아웃 단계에서 핵심적인 역할을 합니다"},{"type":"stringlist","value":"각 HTML 요소는 박스 모델(콘텐츠, 패딩, 테두리, 마진)을 기반으로 사각형 박스로 계산됩니다.\n레이아웃 단계에서 브라우저는 박스 모델의 속성(width, height, margin, padding, border)을 사용해 요소의 크기와 위치를 결정합니다.\nbox-sizing 속성은 박스 크기 계산 방식(content-box vs border-box)을 정의하며, 레이아웃의 예측 가능성에 영향을 미칩니다."},{"type":"normal","value":"다음은 간단한 HTML과 CSS로 렌더링 과정을 보여주는 예제입니다:"},{"type":"code","value":"<!DOCTYPE html>\n<html>\n<head>\n  <style>\n    div {\n      width: 200px;\n      height: 100px;\n      margin: 20px;\n      padding: 10px;\n      border: 5px solid blue;\n      background-color: lightgray;\n    }\n  </style>\n</head>\n<body>\n  <div>Hello, World!</div>\n</body>\n</html>"},{"type":"stringlist","value":"<b>HTML 파싱</b>: &lt;div>와 텍스트가 DOM 트리로 변환됩니다.\n<b>CSS 파싱</b>: 스타일이 CSSOM으로 변환됩니다.\n<b>렌더 트리</b>: &lt;div>와 스타일이 결합된 렌더 트리가 생성됩니다.\n<b>레이아웃</b>: 박스 모델을 기반으로 &lt;div>의 크기(230px × 130px, content-box 기준)와 위치가 계산됩니다.\n<b>페인팅</b>: &lt;div>의 배경색, 테두리, 텍스트가 화면에 그려집니다."},{"type":"Heading","headingType":"h2","value":"추가 고려사항"},{"type":"stringlist","value":"<b>Progressive Rendering</b>: 브라우저는 모든 리소스가 로드되기 전에 부분적으로 렌더링을 시작할 수 있습니다. 이를 통해 사용자에게 더 빠르게 콘텐츠를 보여줄 수 있습니다.\n<b>Web Vitals</b>: Google의 Core Web Vitals(LCP, FID, CLS)는 렌더링 성능을 측정하는 지표로, 최적화 목표로 사용됩니다. </br></br> - <b>LCP(Largest Contentful Paint)</b>: 주요 콘텐츠 렌더링 시간. </br> - <b>FID(First Input Delay)</b>: 사용자 입력에 대한 응답성. </br> - <b>CLS(Cumulative Layout Shift)</b>: 레이아웃 이동의 안정성."}]},"segment":"posts"}],["$","div",null,{"className":"footer_footer_container__MsSvO","children":["$","footer",null,{"className":"footer_footer__AwYty","children":[["$","p",null,{"className":"footer_copylight___J5l0","children":["© 2024 ","베짱이가 되고싶은 개미。"," Some rights reserved."]}],["$","p",null,{"className":"footer_theme__bwXbg","children":"portfolio v1.0.0-alpha.3"}]]}]}]],null]]},["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","(layoutCase)","children","tags","children","$6","children","$7","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/19d2a4a42355ad75.css","precedence":"next","crossOrigin":""}]]}]]},["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","(layoutCase)","children","tags","children","$6","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","(layoutCase)","children","tags","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]],"search":["__DEFAULT__",{},["$9","$Lb",null]]},[null,["$","$Lc",null,{"children":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","(layoutCase)","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":null}],"search":["$","$L5",null,{"parallelRouterKey":"search","segmentPath":["children","(layoutCase)","search"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$d","styles":null}],"params":{}}],null]]},[null,["$","html",null,{"lang":"en","className":"","children":[["$","head",null,{"children":[["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css","as":"style"}],["$","link",null,{"rel":"preconnect","href":"https://fonts.googleapis.com"}],["$","link",null,{"rel":"preconnect","href":"https://fonts.gstatic.com"}],["$","link",null,{"rel":"stylesheet","href":"https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR&display=swap","as":"style"}]]}],["$","body",null,{"children":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":"$e","children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":"$f","children":"404"}],["$","div",null,{"style":"$10","children":["$","h2",null,{"style":"$11","children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/0c496b0e03d530ba.css","precedence":"next","crossOrigin":""}]]}]}]]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/5048045ff4a95083.css","precedence":"next","crossOrigin":""}]],"$L12"]]]]
b:E{"digest":"NEXT_NOT_FOUND"}
12:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"be come 💡"}],["$","meta","3",{"name":"description","content":"App for an Ant Who Wants to Become a Bejjangyi"}]]
1:null
a:null
