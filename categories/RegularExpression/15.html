<!DOCTYPE html><html lang="en" class=""><head><meta charSet="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/b61b62d196836ce7.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/04d20c09b3119d43.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/4be7aaf21dbfc26e.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-7cbbdf1c4fd681ae.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-0e492acdb34e0e7d.js" async="" crossorigin=""></script><script src="/_next/static/chunks/938-073485517c55f951.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-d3c7d898fafbc3cf.js" async="" crossorigin=""></script><script src="/_next/static/chunks/250-8b90be581650ff9d.js" async=""></script><script src="/_next/static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-9eb9aaf2756d2762.js" async=""></script><script src="/_next/static/chunks/304-f6bea3ededee4fbe.js" async=""></script><script src="/_next/static/chunks/730-7ade87634bab4187.js" async=""></script><script src="/_next/static/chunks/566-b141861ca793acbd.js" async=""></script><script src="/_next/static/chunks/35-428bf187f02277f1.js" async=""></script><script src="/_next/static/chunks/338-f2b637e42a7ca177.js" async=""></script><script src="/_next/static/chunks/app/(layoutCase)/layout-b528a91c526f504b.js" async=""></script><title>be come 💡</title><meta name="description" content="App for an Ant Who Wants to Become a Bejjangyi"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" as="style"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR&amp;display=swap" as="style"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><aside id="sidebar" class="sidemenu_sidebar__EmvJl"><header class="sidemenu_profile_wrapper__R57aU"><a href="/posts"><img alt="프로필 사진" loading="lazy" width="112" height="112" decoding="async" data-nimg="1" class="imageLoader_img__X4hab" style="color:transparent" srcSet="https://nam-yeun-hwa.github.io/image/profile1.jpg?w=128&amp;q=75 1x, https://nam-yeun-hwa.github.io/image/profile1.jpg?w=256&amp;q=75 2x" src="https://nam-yeun-hwa.github.io/image/profile1.jpg?w=256&amp;q=75"/></a><h1 class="sidemenu_blog_name_txt__AfWhD">my blog</h1><p class="sidemenu_site_subtitle__eLcN7">You can only earn as much as an ant does by working like an ant.</p></header><nav><ul class="sidemenu_nav__6C5tz"><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/posts"><i class="fa-fw fas fa-home sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">HOME</span></a></li><li class="sidemenu_nav_item__tt_B1 sidemenu_active__fflT6"><a class="sidemenu_nav_link__WTCmf" href="/categories"><i class="fa-fw fas fa-stream sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">CATEGORIES</span></a></li><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/tags"><i class="fa-fw fas fa-tags sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">TAGS</span></a></li><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/archives"><i class="fa-fw fas fa-archive sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">ARCHIVES</span></a></li><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/algorithm"><i class="fa-solid fa-mug-saucer sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">CODING</span></a></li></ul></nav><div class="sidebar-bottom"></div></aside><div class="layout_main_wrapper__1M1Uy"><div class="contents_container__AfHAx"><header class="breadCrumb_topbar_wrapper__dGN_V"><div class="breadCrumb_top_bar__b_rV9"><nav class="breadCrumb_breadcrumb__l7WLX"><span><a class="breadCrumb_topbar_txt__ExrWf" href="/">Home</a><a class="breadCrumb_topbar_txt__ExrWf" href="">리액트(React) vs 뷰(Vue)</a></span></nav><search class="searchBar_search__Ftlhc"><i class="fas fa-search fa-fw searchBar_search_ico__STStc"></i><input id="search" class="searchBar_search_input__1XpQF" placeholder="Search..." autoComplete="off" value=""/></search></div><div class="breadCrumb_mobile_topbar__N1Azi"><button class="breadCrumb_sidebar_trigger__APgD8"><i class="fas fa-bars fa-fw breadCrumb_sidebar_trigger_ico__K9DdV"></i></button><div class="breadCrumb_mobile_topbar_title__oCVBS">be come 💡</div><button class="breadCrumb_search_trigger__PxWyf"><i class="fas fa-search fa-fw breadCrumb_search_trigger_ico__yqqpz"></i></button></div></header><div class="contents_contents__Hpf57"><main class="contents_inner_content__wyt37"><article><header><h1 class="postUserInfo_h1__uhAqy">리액트(React) vs 뷰(Vue)</h1></header></article><div class="postUserInfo_post_meta__ABvuC"><span>Posted<!-- --> <time class="postUserInfo_time__2exyR">2 years<!-- --> </time></span><span class="postUserInfo_update__f345P">Updated<!-- --> <time class="postUserInfo_time__2exyR">2 years</time></span></div><div><span class="postUserInfo_post_meta__ABvuC">By<!-- --> <em><a class="postUserInfo_author__fVGYM" href="https://nam-yeun-hwa.github.io/">베짱이가 되고싶은 개미。</a></em></span></div><div class="postDetail_content__OTeO2">
        리액트(React)와 뷰(Vue.js)는 모두 현대적인 프론트엔드 JavaScript 라이브러리 및 프레임워크로, 웹 애플리케이션의 사용자 인터페이스(UI)를 개발하기 위해 사용된다. 이 두 기술의 각각 고유한 특징과 장단점에 대해 이야기 해보고자 한다. </br></br>

        react는 UI 라이브러리이며 JSX(Javascript XML)형태로 코드를 작성하여 UI로직과 DOM을 구현한다. 자바스크립트를 사용하기 때문에 자바스크립트 문법에 능숙해야 하며 커스터마이징 및 자유도가 높은편이다. 또한 커뮤니티 형성이 잘 되어있고 큰 프로젝트에 용이하다.</br></br>

        Vue는 제공되는 html 기반의 템플릿이 있어 쉽고 빠르게 제작이 가능하여 진입장벽이 낮고 개발
        자간 코드 통일성이 있으며 소규모 프로젝트에 용이하다.</br></br></div><div>
      <table>
        <thead>
          <tr>
            <th></th>
            <th>데이터 바인딩</th>
            <th>코딩 문법</th>
            <th>UI 구성 아키텍쳐</th>
            <th>공통</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>리액트</td>
            <td>단방향 데이터바인딩</td>
            <td>UI 라이브러리로 JSX(Javascript XML)문법을 사용</br> 자바스크립트를 사용하기 때문에 커스터 마이징 및 자유도가 높은 편</td>
            <td>컴포넌트 기반 아키텍처를 사용하여 UI를 구성</td>
            <td>가상돔 사용</td>
          </tr>
          <tr>
            <td>뷰</td>
            <td>양방향 데이터바인딩</td>
            <td>프레임워크가 지원해주는 문법에 따라 작성하기 때문에 개발자간 코드 통일성이 있다.</td>
            <td>HTML 기반의 템플릿 문법을 사용하여 UI를 정의</td>
            <td>가상돔 사용</td>
          </tr>
        </tbody>
      </table>
      </div><h2 class="heading_h2__fsXMw">단방향 데이터 바인딩(React)</h2><div class="postDetail_content__OTeO2">리액트는 단방향 데이터 바인딩을 사용한다. 리액트는 데이터의 흐름이 상위 컴포넌트에서 하위 컴포넌트로 한 방향으로만 흐르기 때문에 데이터의 변화를 추적하기가 쉽고, 디버깅이 용이하다. 또한, 리액트는 Virtual DOM을 활용하여 성능을 향상시키고, 변경된 부분만을 업데이트하여 성능 저하를 최소화한다. 하지만 화면을 업데이트하기 위해 변화를 감지하고 화면을 업데이트하는 관련 코드를 매번 작성해야 하는 불편함이 있다.</br></br>
        리액트에서 상태(State)와 생명주기(Lifecycle) 관리를 위해 사용되는 메서드들이 호출되어야 한다는 의미이다. 예를 들어, 상태가 변경될 때마다 setState 메서드를 호출하여 컴포넌트를 다시 렌더링하거나, 생명주기 메서드 중에서 변화가 감지되는 경우에 관련 코드를 작성해주어야 한다. 이러한 작업은 번거로울 수 있지만, 리액트의 성능 최적화를 위해서는 필수적이다.</div><blockquote class="Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_warning__ZYPQt"><p class="Prompts_detail__nD6Io"><b>리액트 장단점</b></br>
        - 데이터 변화에 따른 성능 저하 없이 DOM 객체 갱신 가능</br>
        - 데이터 흐름이 단방향(부모->하위 컴포넌트)이라, 코드를 이해하기 쉽고 데이터 추적과 디버깅이 쉽다.</br>
        - 커뮤니티와 생태계가 크고 활발하여 문제 해결 및 지원이 용이하다.</br>
        - 변화를 감지하고 화면을 업데이트 하는 코드를 매번 작성해 줘야 하는 번거로움이 있다.</p></blockquote><h2 class="heading_h2__fsXMw">양방향 데이터 바인딩(Vue)</h2><div class="postDetail_content__OTeO2">뷰는 양방향 데이터 바인딩을 지원한다. 이는 프레임워크가 데이터의 변경을 감지하고 자동으로 DOM 객체에 렌더링하여 사용자 인터페이스를 업데이트 한다. 이러한 방식은 사용자가 입력한 값이나 데이터가 변경될 때마다 화면이 즉시 반영되므로 개발자가 따로 체크하거나 업데이트 코드를 작성할 필요가 없어 편리하다. 그러나 데이터가 많거나 복잡한 애플리케이션의 경우 성능 저하를 초래할 수 있다. 
      </div><blockquote class="Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_warning__ZYPQt"><p class="Prompts_detail__nD6Io">
        <b>장단점</b></br>
        - 진입 장벽이 낮고, 간단한 프로젝트부터 복잡한 애플리케이션까지 다양한 범위의 프로젝트에 적합하다.</br>
        - 데이터의 변화에 따라 DOM 객체 전체를 렌더링해주거나 데이터를 바꿔주므로, 성능이 감소되는 경우가 있다.
        </p></blockquote><h2 class="heading_h2__fsXMw">가상돔(Virtual DOM)</h2><div class="postDetail_content__OTeO2">실제 돔에는 브라우저가 화면을 그리는데 필요한 모든 정보가 들어 있어 실제 돔을 조작하는 작업은 무겁기 때문에 가상돔을 만들어 메모리에 저장하고 이전 가상돔에 있던 내용과 현재 가상 돔을 비교하여 바뀐 부분만 실제 돔에 적용한다.
      </div><div class="row"><nav class="postNavigation_post_navigation__Zbcpm"><a class="postNavigation_post_navgation_common__q8_Hl postNavigation_post_navigation_pre__SPHh_" aria-label="Older" href="/posts/16"><p class="postNavigation_post_navigation_text__3cjma">브라우저의 JavaScript 코드 실행 과정 - 콜스택과 이벤트 루프</p></a><a class="postNavigation_post_navgation_common__q8_Hl postNavigation_post_navigation_next__yVEzg" aria-label="Newer" href="/posts/14"><p class="postNavigation_post_navigation_text__3cjma">테스트 주도 개발(Test driven devlopment, TDD)</p></a></nav></div><div class="footer_footer_container__MsSvO"><footer class="footer_footer__AwYty"><p class="footer_copylight___J5l0">© 2024 <!-- -->베짱이가 되고싶은 개미。<!-- --> Some rights reserved.</p><p class="footer_theme__bwXbg">portfolio v1.0.0-alpha.3</p></footer></div></main><aside class="panel_panel_wrapper__bjPKT"><div class="panel_access__NiFhF"><section class="panel_access_lastmod__v6pgX"><h2 class="panel_panel_heading__n9W6w">Recently Updated</h2><ul class="panel_panel_recently__U0_Zp"><li class="panel_text_truncate__SFfHf"><a href="/posts/14">테스트 주도 개발(Test driven devlopment, TDD)</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/25">브라우저 렌더링 중 스크립트 태그를 만날 때 파싱이 중단되는 문제와 해결</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/24">Function.prototype.bind()</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/23">HTML(하이퍼텍스트 마크업 언어)에서 속성(Attribute)과 프로퍼티(Property)</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/22">화살표 함수와 일반함수의 차이점</a></li></ul></section><section class="panel_panel_tag_contain__h_Bwi"><h2 class="panel_panel_heading__n9W6w">Trending Tags</h2><div class="panel_panel_tag__eNz5c"><a class="panel_tag__3AiMO" href="/tags/테스트 주도 개발">테스트 주도 개발</a><a class="panel_tag__3AiMO" href="/tags/Javascript">Javascript</a><a class="panel_tag__3AiMO" href="/tags/콜백함수">콜백함수</a><a class="panel_tag__3AiMO" href="/tags/browser">browser</a><a class="panel_tag__3AiMO" href="/tags/HTTP-Protocol">HTTP-Protocol</a><a class="panel_tag__3AiMO" href="/tags/git">git</a><a class="panel_tag__3AiMO" href="/tags/React">React</a><a class="panel_tag__3AiMO" href="/tags/Vue">Vue</a><a class="panel_tag__3AiMO" href="/tags/JWT">JWT</a><a class="panel_tag__3AiMO" href="/tags/Token">Token</a></div></section></div></aside></div></div></div><script src="/_next/static/chunks/webpack-7cbbdf1c4fd681ae.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/b61b62d196836ce7.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/css/04d20c09b3119d43.css\",\"style\",{\"crossOrigin\":\"\"}]\n4:HL[\"/_next/static/css/4be7aaf21dbfc26e.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"5:I[7690,[],\"\"]\n7:I[5250,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"862\",\"static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-9eb9aaf2756d2762.js\"],\"\"]\n8:I[777,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"862\",\"static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-9eb9aaf2756d2762.js\"],\"\"]\n9:I[5613,[],\"\"]\nc:I[1778,[],\"\"]\n10:I[5210,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"304\",\"static/chunks/304-f6bea3ededee4fbe.js\",\"730\",\"static/chunks/730-7"])</script><script>self.__next_f.push([1,"ade87634bab4187.js\",\"566\",\"static/chunks/566-b141861ca793acbd.js\",\"35\",\"static/chunks/35-428bf187f02277f1.js\",\"338\",\"static/chunks/338-f2b637e42a7ca177.js\",\"464\",\"static/chunks/app/(layoutCase)/layout-b528a91c526f504b.js\"],\"\"]\n17:I[8955,[],\"\"]\na:[\"categoryname\",\"RegularExpression\",\"d\"]\nb:[\"postid\",\"15\",\"d\"]\nd:\"$Le\"\n11:[]\n12:{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\""])</script><script>self.__next_f.push([1,"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"}\n13:{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"}\n14:{\"display\":\"inline-block\"}\n15:{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0}\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/b61b62d196836ce7.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"f20neTUnWIe7OHbcT20zs\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/categories/RegularExpression/15\",\"initialTree\":[\"\",{\"children\":[\"(layoutCase)\",{\"children\":[\"categories\",{\"children\":[[\"categoryname\",\"RegularExpression\",\"d\"],{\"children\":[[\"postid\",\"15\",\"d\"],{\"children\":[\"__PAGE__?{\\\"categoryname\\\":\\\"RegularExpression\\\",\\\"postid\\\":\\\"15\\\"}\",{}]}]}]}],\"search\":[\"__DEFAULT__\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"(layoutCase)\",{\"children\":[\"categories\",{\"children\":[[\"categoryname\",\"RegularExpression\",\"d\"],{\"children\":[[\"postid\",\"15\",\"d\"],{\"children\":[\"__PAGE__\",{},[\"$L6\",[[[\"$\",\"article\",null,{\"className\":\"$undefined\",\"children\":[\"$\",\"header\",null,{\"children\":[\"$\",\"h1\",null,{\"className\":\"postUserInfo_h1__uhAqy\",\"children\":\"리액트(React) vs 뷰(Vue)\"}]}]}],[\"$\",\"div\",null,{\"className\":\"postUserInfo_post_meta__ABvuC\",\"children\":[[\"$\",\"span\",null,{\"children\":[\"Posted\",\" \",[\"$\",\"time\",null,{\"className\":\"postUserInfo_time__2exyR\",\"children\":[\"2 years\",\" \"]}]]}],[\"$\",\"span\",null,{\"className\":\"postUserInfo_update__f345P\",\"children\":[\"Updated\",\" \",[\"$\",\"time\",null,{\"className\":\"postUserInfo_time__2exyR\",\"children\":\"2 years\"}]]}]]}],[\"$\",\"div\",null,{\"children\":[\"$\",\"span\",null,{\"className\":\"postUserInfo_post_meta__ABvuC\",\"children\":[\"By\",\" \",[\"$\",\"em\",null,{\"children\":[\"$\",\"$L7\",null,{\"href\":\"https://nam-yeun-hwa.github.io/\",\"className\":\"postUserInfo_author__fVGYM\",\"children\":\"베짱이가 되고싶은 개미。\"}]}]]}]}]],[[\"$\",\"div\",\"0\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"\\n        리액트(React)와 뷰(Vue.js)는 모두 현대적인 프론트엔드 JavaScript 라이브러리 및 프레임워크로, 웹 애플리케이션의 사용자 인터페이스(UI)를 개발하기 위해 사용된다. 이 두 기술의 각각 고유한 특징과 장단점에 대해 이야기 해보고자 한다. \u003c/br\u003e\u003c/br\u003e\\n\\n        react는 UI 라이브러리이며 JSX(Javascript XML)형태로 코드를 작성하여 UI로직과 DOM을 구현한다. 자바스크립트를 사용하기 때문에 자바스크립트 문법에 능숙해야 하며 커스터마이징 및 자유도가 높은편이다. 또한 커뮤니티 형성이 잘 되어있고 큰 프로젝트에 용이하다.\u003c/br\u003e\u003c/br\u003e\\n\\n        Vue는 제공되는 html 기반의 템플릿이 있어 쉽고 빠르게 제작이 가능하여 진입장벽이 낮고 개발\\n        자간 코드 통일성이 있으며 소규모 프로젝트에 용이하다.\u003c/br\u003e\u003c/br\u003e\"}}],[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n      \u003ctable\u003e\\n        \u003cthead\u003e\\n          \u003ctr\u003e\\n            \u003cth\u003e\u003c/th\u003e\\n            \u003cth\u003e데이터 바인딩\u003c/th\u003e\\n            \u003cth\u003e코딩 문법\u003c/th\u003e\\n            \u003cth\u003eUI 구성 아키텍쳐\u003c/th\u003e\\n            \u003cth\u003e공통\u003c/th\u003e\\n          \u003c/tr\u003e\\n        \u003c/thead\u003e\\n        \u003ctbody\u003e\\n          \u003ctr\u003e\\n            \u003ctd\u003e리액트\u003c/td\u003e\\n            \u003ctd\u003e단방향 데이터바인딩\u003c/td\u003e\\n            \u003ctd\u003eUI 라이브러리로 JSX(Javascript XML)문법을 사용\u003c/br\u003e 자바스크립트를 사용하기 때문에 커스터 마이징 및 자유도가 높은 편\u003c/td\u003e\\n            \u003ctd\u003e컴포넌트 기반 아키텍처를 사용하여 UI를 구성\u003c/td\u003e\\n            \u003ctd\u003e가상돔 사용\u003c/td\u003e\\n          \u003c/tr\u003e\\n          \u003ctr\u003e\\n            \u003ctd\u003e뷰\u003c/td\u003e\\n            \u003ctd\u003e양방향 데이터바인딩\u003c/td\u003e\\n            \u003ctd\u003e프레임워크가 지원해주는 문법에 따라 작성하기 때문에 개발자간 코드 통일성이 있다.\u003c/td\u003e\\n            \u003ctd\u003eHTML 기반의 템플릿 문법을 사용하여 UI를 정의\u003c/td\u003e\\n            \u003ctd\u003e가상돔 사용\u003c/td\u003e\\n          \u003c/tr\u003e\\n        \u003c/tbody\u003e\\n      \u003c/table\u003e\\n      \"}}],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"children\":\"단방향 데이터 바인딩(React)\"}],false,false],[\"$\",\"div\",\"3\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"리액트는 단방향 데이터 바인딩을 사용한다. 리액트는 데이터의 흐름이 상위 컴포넌트에서 하위 컴포넌트로 한 방향으로만 흐르기 때문에 데이터의 변화를 추적하기가 쉽고, 디버깅이 용이하다. 또한, 리액트는 Virtual DOM을 활용하여 성능을 향상시키고, 변경된 부분만을 업데이트하여 성능 저하를 최소화한다. 하지만 화면을 업데이트하기 위해 변화를 감지하고 화면을 업데이트하는 관련 코드를 매번 작성해야 하는 불편함이 있다.\u003c/br\u003e\u003c/br\u003e\\n        리액트에서 상태(State)와 생명주기(Lifecycle) 관리를 위해 사용되는 메서드들이 호출되어야 한다는 의미이다. 예를 들어, 상태가 변경될 때마다 setState 메서드를 호출하여 컴포넌트를 다시 렌더링하거나, 생명주기 메서드 중에서 변화가 감지되는 경우에 관련 코드를 작성해주어야 한다. 이러한 작업은 번거로울 수 있지만, 리액트의 성능 최적화를 위해서는 필수적이다.\"}}],[false,false,[\"$\",\"blockquote\",null,{\"className\":\"Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_warning__ZYPQt\",\"children\":[\"$\",\"p\",null,{\"className\":\"Prompts_detail__nD6Io\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e리액트 장단점\u003c/b\u003e\u003c/br\u003e\\n        - 데이터 변화에 따른 성능 저하 없이 DOM 객체 갱신 가능\u003c/br\u003e\\n        - 데이터 흐름이 단방향(부모-\u003e하위 컴포넌트)이라, 코드를 이해하기 쉽고 데이터 추적과 디버깅이 쉽다.\u003c/br\u003e\\n        - 커뮤니티와 생태계가 크고 활발하여 문제 해결 및 지원이 용이하다.\u003c/br\u003e\\n        - 변화를 감지하고 화면을 업데이트 하는 코드를 매번 작성해 줘야 하는 번거로움이 있다.\"}}]}],false],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"children\":\"양방향 데이터 바인딩(Vue)\"}],false,false],[\"$\",\"div\",\"6\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"뷰는 양방향 데이터 바인딩을 지원한다. 이는 프레임워크가 데이터의 변경을 감지하고 자동으로 DOM 객체에 렌더링하여 사용자 인터페이스를 업데이트 한다. 이러한 방식은 사용자가 입력한 값이나 데이터가 변경될 때마다 화면이 즉시 반영되므로 개발자가 따로 체크하거나 업데이트 코드를 작성할 필요가 없어 편리하다. 그러나 데이터가 많거나 복잡한 애플리케이션의 경우 성능 저하를 초래할 수 있다. \\n      \"}}],[false,false,[\"$\",\"blockquote\",null,{\"className\":\"Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_warning__ZYPQt\",\"children\":[\"$\",\"p\",null,{\"className\":\"Prompts_detail__nD6Io\",\"dangerouslySetInnerHTML\":{\"__html\":\"\\n        \u003cb\u003e장단점\u003c/b\u003e\u003c/br\u003e\\n        - 진입 장벽이 낮고, 간단한 프로젝트부터 복잡한 애플리케이션까지 다양한 범위의 프로젝트에 적합하다.\u003c/br\u003e\\n        - 데이터의 변화에 따라 DOM 객체 전체를 렌더링해주거나 데이터를 바꿔주므로, 성능이 감소되는 경우가 있다.\\n        \"}}]}],false],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"children\":\"가상돔(Virtual DOM)\"}],false,false],[\"$\",\"div\",\"9\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"실제 돔에는 브라우저가 화면을 그리는데 필요한 모든 정보가 들어 있어 실제 돔을 조작하는 작업은 무겁기 때문에 가상돔을 만들어 메모리에 저장하고 이전 가상돔에 있던 내용과 현재 가상 돔을 비교하여 바뀐 부분만 실제 돔에 적용한다.\\n      \"}}]],[\"$\",\"$L8\",null,{\"postid\":15,\"prePostTitle\":{\"id\":16,\"title\":\"브라우저의 JavaScript 코드 실행 과정 - 콜스택과 이벤트 루프\",\"date\":\"2024-02-28 01:20:33\",\"folder\":\"Javascript\",\"tag\":[\"Javascript\",\"browser\"],\"preview\":\"콜스택은 현재 실행 중인 함수의 호출을 기록하는 자료 구조입니다. 함수가 호출되면 해당 함수의 정보가 스택에 추가되고, 함수의 실행이 완료되면 스택에서 제거됩니다. 따라서 콜스택은 함수의 호출 순서를 추적하고, 실행 중인 함수의 컨텍스트를 관리합니다.\",\"post\":[{\"type\":\"h2\",\"value\":\"콜스택 (Call Stack)\"},{\"type\":\"normal\",\"value\":\"콜스택은 현재 실행 중인 함수의 호출을 기록하는 자료 구조입니다. 함수가 호출되면 해당 함수의 정보가 스택에 추가되고, 함수의 실행이 완료되면 스택에서 제거됩니다. 따라서 콜스택은 함수의 호출 순서를 추적하고, 실행 중인 함수의 컨텍스트를 관리합니다.\"},{\"type\":\"h4\",\"value\":\"실행 컨텍스트가 생성되고 콜스택에 쌓이는 과정\"},{\"type\":\"code\",\"value\":\"function greet(name) {\\n  let greeting = \\\"Hello, \\\" + name + \\\"!\\\";\\n  console.log(greeting);\\n}\\n\\nfunction sayHello() {\\n  greet(\\\"Alice\\\");\\n}\\n\\nsayHello();\"},{\"type\":\"numlist\",\"value\":\"\\n        1. sayHello() 함수가 호출되면서 새로운 실행 컨텍스트가 생성되고 호출 스택에 추가됩니다.\"},{\"type\":\"normal\",\"value\":\"　호출 스택: [sayHello()]\"},{\"type\":\"numlist\",\"value\":\"\\n        2. sayHello() 함수 내에서 greet(\\\"Alice\\\")가 호출되면서 또 다른 실행 컨텍스트가 생성되고 호출 스택에 추가됩니다.\"},{\"type\":\"normal\",\"value\":\"　호출 스택: [sayHello(), greet(\\\"Alice\\\")]\"},{\"type\":\"numlist\",\"value\":\"\\n        3. greet(\\\"Alice\\\") 함수 내에서 변수 greeting이 생성되고 값이 할당됩니다.\"},{\"type\":\"normal\",\"value\":\"　호출 스택: [sayHello(), greet(\\\"Alice\\\")]\"},{\"type\":\"numlist\",\"value\":\"\\n        4. console.log(greeting)이 실행되고 호출 스택에서 greet(\\\"Alice\\\") 실행 컨텍스트가 제거됩니다.\"},{\"type\":\"normal\",\"value\":\"　호출 스택: [sayHello()]\"},{\"type\":\"numlist\",\"value\":\"\\n        5. sayHello() 함수 내의 모든 코드가 실행되고 호출 스택에서 해당 실행 컨텍스트가 제거됩니다.\"},{\"type\":\"normal\",\"value\":\"　호출 스택: []\"},{\"type\":\"h2\",\"value\":\"이벤트 루프 큐 (Event Loop Queue)\"},{\"type\":\"normal\",\"value\":\"이벤트 루프 큐는 비동기 작업의 완료 또는 이벤트 발생을 기다리는 대기열입니다. 비동기 함수의 콜백 함수나 이벤트 처리기는 이벤트 루프 큐에 추가되어 대기하다가 콜스택이 비어있을 때 실행됩니다. 이벤트 루프는 콜스택이 비어있을 때마다 큐에서 작업을 꺼내어 콜스택에 추가하여 실행될 수 있도록 합니다.\"},{\"type\":\"h4\",\"value\":\"이벤트 루프와 호출 스택 1\"},{\"type\":\"code\",\"value\":\"setTimeout(() =\u003e {\\n  console.log('hello');\\n}, 0); // 작업 큐에 콜백이 추가됨\\n\\nconsole.log('world');\\n\\n// 출력 결과:\\n// world\\n// hello\\n\"},{\"type\":\"normal\",\"value\":\"1. setTimeout(() =\u003e { console.log('hello'); }, 0); 코드가 실행됩니다.\"},{\"type\":\"stringlist\",\"value\":\"\\n        setTimeout 함수가 호출되어 타이머가 설정됩니다. 이때 콜백 함수는 태스크 큐에 추가됩니다.\\n        현재 호출 스택: [setTimeout()]\"},{\"type\":\"normal\",\"value\":\"2. console.log('world'); 코드가 실행됩니다.\"},{\"type\":\"stringlist\",\"value\":\"\\n        \\\"world\\\"가 콘솔에 출력됩니다.\\n        현재 호출 스택: [setTimeout()]\"},{\"type\":\"normal\",\"value\":\"3. 호출 스택에서는 더 이상 실행할 코드가 없으므로 이벤트 루프가 작동합니다.\"},{\"type\":\"normal\",\"value\":\"4. 이벤트 루프는 호출 스택이 비어있는지 확인하고, 비어있다면 작업 큐에 있는 콜백 함수를 호출 스택에 추가하여 실행합니다.\"},{\"type\":\"normal\",\"value\":\"5. 작업 큐에 있는 콜백 함수가 호출 스택에 추가되어 실행됩니다.\"},{\"type\":\"stringlist\",\"value\":\"\\n        \\\"hello\\\"가 콘솔에 출력됩니다.\\n        현재 호출 스택: []\"},{\"type\":\"normal\",\"value\":\"이렇게 되면 \\\"world\\\"가 먼저 출력되고, 그 후 \\\"hello\\\"가 출력됩니다. 이는 setTimeout의 시간 지연이 0ms로 설정되었더라도, 해당 콜백 함수가 작업 큐에 추가되고 이벤트 루프를 통해 호출 스택에 올라가기 때문입니다. 따라서 JavaScript의 비동기성에 의해 콜백 함수의 실행이 이루어집니다.\"},{\"type\":\"h4\",\"value\":\"이벤트 루프와 호출 스택 2\"},{\"type\":\"code\",\"value\":\"function greet(name) {\\n  let greeting = \\\"Hello, \\\" + name + \\\"!\\\";\\n  console.log(greeting);\\n}\\n\\nfunction sayHello() {\\n  greet(\\\"Alice\\\");\\n  setTimeout(function() {\\n    console.log(\\\"비동기 함수 실행 완료\\\");\\n  }, 1000); // 1초 후에 실행됨\\n}\\n\\nsayHello();\"},{\"type\":\"numlist\",\"value\":\"\\n        1. sayHello() 함수가 호출되면서 새로운 실행 컨텍스트가 생성되고 호출 스택에 추가됩니다.\"},{\"type\":\"normal\",\"value\":\"　호출 스택: [sayHello()]\"},{\"type\":\"numlist\",\"value\":\"\\n        2. sayHello() 함수 내에서 greet(\\\"Alice\\\")가 호출되면서 또 다른 실행 컨텍스트가 생성되고 호출 스택에 추가됩니다.\"},{\"type\":\"normal\",\"value\":\"　호출 스택: [sayHello(), greet(\\\"Alice\\\")]\"},{\"type\":\"numlist\",\"value\":\"\\n        3. greet(\\\"Alice\\\") 함수 내에서 변수 greeting이 생성되고 값이 할당됩니다.\"},{\"type\":\"normal\",\"value\":\"　호출 스택: [sayHello(), greet(\\\"Alice\\\")]\"},{\"type\":\"numlist\",\"value\":\"\\n        4. console.log(greeting)이 실행되고 호출 스택에서 greet(\\\"Alice\\\") 실행 컨텍스트가 제거됩니다.\"},{\"type\":\"normal\",\"value\":\"　호출 스택: [sayHello()]\"},{\"type\":\"numlist\",\"value\":\"\\n        5. setTimeout 함수가 호출되어 타이머가 설정됩니다. 이때 비동기적으로 실행되므로 호출 스택에는 추가되지 않습니다.\"},{\"type\":\"normal\",\"value\":\"　호출 스택:[sayHello()]\"},{\"type\":\"numlist\",\"value\":\"\\n        6. sayHello() 함수 내의 모든 코드가 실행되었지만, 아직 타이머가 만료되지 않았으므로 이벤트 루프에서 대기합니다.\"},{\"type\":\"numlist\",\"value\":\"\\n        7. 1초 후, 타이머가 만료되면 설정된 콜백 함수가 이벤트 루프 큐에 추가됩니다.\"},{\"type\":\"numlist\",\"value\":\"\\n        8. 이벤트 루프는 호출 스택이 비어있는지 확인하고, 비어있다면 이벤트 루프 큐에서 콜백 함수를 꺼내와 호출 스택에 추가하여 실행합니다.\"},{\"type\":\"numlist\",\"value\":\"\\n        9. 비동기 함수 실행 완료\\\" 메시지가 출력되고 호출 스택에서 해당 실행 컨텍스트가 제거됩니다.\"},{\"type\":\"normal\",\"value\":\"　호출 스택: []\"},{\"type\":\"normal\",\"value\":\"이렇게 비동기 함수가 추가되면, 해당 비동기 함수의 콜백 함수가 이벤트 루프를 통해 적절한 시점에 호출되어 실행됩니다.\"},{\"type\":\"h2\",\"value\":\"JavaScript 코드 실행이 브라우저의 성능과 사용자 경험에 미치는 영향\"},{\"type\":\"normal\",\"value\":\"웹 브라우저는 콜 스택에 실행 컨텍스트가 존재하는 동안, 즉 실행 중인 함수가 존재하는 동안에는 먹통이 되어 버립니다. 브라우저는 대개 60fps로 동작하기 때문에, 대략 16ms 안에 코드의 실행을 완료하지 못하면 브라우저의 애니메이션이 뚝뚝 끊기는 현상이 나타납니다. 이는 사용자 경험에 악영향을 미칠 수 있습니다. \"},{\"type\":\"code\",\"value\":\"\\n// 동기적인 처리 예제\\nfunction syncExample() {\\n  console.log(\\\"시작\\\");\\n  for (let i = 0; i \u003c 1000000000; i++) {\\n    // 매우 오랜 시간이 걸리는 작업\\n  }\\n  console.log(\\\"종료\\\");\\n}\\n\\n// 비동기적인 처리 예제\\nfunction asyncExample() {\\n  console.log(\\\"시작\\\");\\n  setTimeout(function() {\\n    console.log(\\\"비동기 처리 완료\\\");\\n  }, 2000); // 2초 후에 콜백 함수 실행\\n  console.log(\\\"종료\\\");\\n}\\n\\n// 동기적인 처리 실행\\nsyncExample();\\n\\n// 비동기적인 처리 실행\\nasyncExample();\\n\\n        \"},{\"type\":\"normal\",\"value\":\"위 코드에서 syncExample 함수는 매우 오랜 시간이 걸리는 반복문을 포함하고 있어, 실행 중에는 다른 작업이 불가능합니다. 이 함수가 실행 중일 때는 브라우저가 먹통이 되어 버리고, 애니메이션이 끊겨 보일 수 있습니다. \u003c/br\u003e\u003c/br\u003e\\n\\n        asyncExample 함수는 비동기적으로 처리됩니다. setTimeout 함수를 사용하여 비동기적으로 콜백 함수를 실행하도록 하였기 때문에, 이 함수가 실행되는 동안에도 다른 작업이 가능합니다. 이는 브라우저가 뚝뚝 끊기는 현상을 방지하는 데 도움이 됩니다.\u003c/br\u003e\u003c/br\u003e\\n        \\n        따라서, 비동기적인 처리를 통해 브라우저가 먹통이 되는 현상을 방지할 수 있으며, 사용자 경험을 향상시킬 수 있습니다.\"}]},\"nextPostTile\":{\"id\":14,\"title\":\"테스트 주도 개발(Test driven devlopment, TDD)\",\"date\":\"2024-07-08 22:13:16\",\"folder\":\"tdd\",\"tag\":[\"테스트 주도 개발\"],\"preview\":\"테스트 코드를 먼저 작성하는 테스트 주도 개발 방벙론은 테스트 프레임워크를 사용하여 자동화된 테스트 시스템에서 미리 정의된 사양을 바탕으로 실패하는 테스트 명새를 작성하고\",\"post\":[{\"type\":\"normal\",\"value\":\"소프트웨어를 전문적으로 개발하는 기업들은 서비스의 안정적인 운영과 서비스의 품질을 확보하기 위해 테스트 코드를 작성하고 관리하고 있다. 다시 말하면 서비스의 품질을 확보하기 위해서는 테스트 코드 작성이 필수라는 것이다.\"},{\"type\":\"normal\",\"value\":\"테스트 주도 개발이라는 개념이 나오기 전에는 우리가 지금까지 해온 것과 같이 움직이는 소프트웨어를 개발한 후 해당 소프트 웨어에 대한 테스트 코드를 작성하는 방식을 사용해 왔다. 이 방식을 사용하면 다음과 같은 문제점들이 있다.\"},{\"type\":\"stringlist\",\"value\":\"다른 사람이 작성한 소스 코드 또는 내가 예전에 작성한 코드에 대해 테스트 코드를 작성해야 하는데 이 코드가 어떻게 동작하는지 알 수 없거나 기억할 수 없음으로 코드를 다시 분석하고 테스트 코드를 작성해야 한다.\\n        작성된 코드가 테스트하기 쉽게 작성되어 있지 않다. 따라서 테스트 코드를 작성하기가 불가능 하거나 테스트 코드를 작성하기 위해 이미 작성된 코드를 수정해야 할 경우가 발생한다. 이때 기존 코드의 수정으로 인해 예기치 않은 문제가 발생할 수 있다.\"},{\"type\":\"normal\",\"value\":\"이런 문제를 해결하기 위해 켄트백(Kent Beck)은 테스트 코드를 먼저 작성하는 테스트 주도 개발론을 제안하게 되었다. 테스트 줃 개발 방벙론은 테스트 프레임워크 등을 사용하여 자동화된 테스트 시스템에서 미리 정의된 사양을 바탕으로\"},{\"type\":\"emphasis\",\"value\":\"실패하는 테스트 명세를 작성하고 그 테스트 명세를 통과하기 위한 최소한의 코드를 작성한다. 마지막으로 해당 코드를 리팩토링 하는 것으로 개발을 마치는 프로세스이다.\"},{\"type\":\"h2\",\"value\":\"Jest 테스트 프레임워크로 테스트 코드 작성하기\"},{\"type\":\"normal\",\"value\":\"Jest는 주로 JavaScript 및 TypeScript 애플리케이션을 테스트하기 위해 사용되는 JavaScript 테스팅 프레임워크로 특히 React 애플리케이션 테스트에 최적화되어 있다. 페이스북(현 메타)에서 개발했으며,  React 외에도 다른 JavaScript 프레임워크나 라이브러리와도 잘 작동한다.\"},{\"type\":\"h2\",\"value\":\"Jest의 주요 쿼리 함수\"},{\"type\":\"H3\",\"value\":\"describe 함수 \"},{\"type\":\"normal\",\"value\":\"describe함수는 jest가 제공하는 함수로써 여러 테스트를 한 그룹으로 묶고 설명을 붙이기 위해 사용한다.\"},{\"type\":\"stringlist\",\"value\":\"첫번째 매개변수는 명령 프롬프트에 표시할 설명\\n        두번째 매개변수는 여러 테스트를 그룹으로 묶을 콜백 함수\"},{\"type\":\"code\",\"value\":\"describe('test index.js file', () =\u003e {\\n\\n});\"},{\"type\":\"H3\",\"value\":\"it 함수\"},{\"type\":\"normal\",\"value\":\"it함수는 실제 테스트가 실행되는 테스트 명세를 작성할 때 사용한다.\"},{\"type\":\"stringlist\",\"value\":\"첫번째 매개변수는 테스트 명세의 설명\\n        두 번째 매개변수에는 실제로 테스트를 실행하는 테스트 코드를 작성\"},{\"type\":\"code\",\"value\":\"it('sum 1+2 to equal 3', () =\u003e {\\n      \\n});\"},{\"type\":\"H3\",\"value\":\"expect 함수\"},{\"type\":\"normal\",\"value\":\"expect 함수는 주로 테스트 프레임워크에서 테스트 결과를 확인하기 위해 사용되는 메서드나 함수이다. expect 함수는 테스트 대상이 특정 조건을 만족하는지, 즉 예상된 동작을 수행하는지를 검증하는 역할이다.\"},{\"type\":\"code\",\"value\":\"it('sum 1+2 to equal 3', () =\u003e {\\n      expect(sum(1,2)).toBe(3);\\n});\"},{\"type\":\"stringlist\",\"value\":\"여기서 sum(1,2)는 테스트 대상이 실제로 생성한 값이고, 3는 기대하는 값이며 toBe는 일치 여부를 확인하는 메서드이다.\"},{\"type\":\"normal\",\"value\":\"expect는 단순한 값 비교 외에도 다양한 일치 조건을 제공한다. 예를 들어, 두 객체가 동일한지, 배열이 특정 요소를 포함하는지, 함수가 특정 예외를 던지는지 등을 확인할 수 있다.\"},{\"type\":\"code\",\"value\":\"// 객체나 배열의 동등성 비교\\nexpect(actualValue).toEqual(expectedValue); \\n\\n// 배열이 특정 아이템을 포함하는지\\nexpect(array).toContain(item); \\n\\n// 함수가 특정 오류를 던지는지\\nexpect(() =\u003e functionCall()).toThrow(ErrorType); \\n        \"},{\"type\":\"h2\",\"value\":\"@testing-library로 리액트 컴포넌트 테스트 코드 작성 하기\"},{\"type\":\"normal\",\"value\":\"@testing-library는 DOM 테스팅 라이브러리(DOM Testing Library)이다. @testing-library는 사용자 중심 방식으로 UI 컴포넌트를 테스트하는데 도움을 주는 라이브러리이며\\n        리액트 컴포넌트의 테스트 코드 작성을 도와준다. \u003c/br\u003e\u003c/br\u003e\\n        \\n        테스트 코드를 작성할 때 컴포넌트 세부 구현사항을 포함하지 않으면서도 신뢰할 수 있는 테스트 코드 작성에 도움을 준다. 이렇게 컴포넌트의 세부 구현 사항을 포함하지 않은 테스트 코드를 작성하면 컴포넌트의 세부 구현 부분을 리팩토링 하여도 테스트 코드를 수정할 필요가 없다, 이로 인해 한번 작성한 테스트 코드는 긴 시간 유지할 수 있으며 오랜 기간 유지 가능하여 테스트 코드를 자주 수정하지 않아도 되므로 개발 생산성을 향상 시켜 준다.\"},{\"type\":\"H3\",\"value\":\"App.js 컴포넌트 - 렌더링 테스트\"},{\"type\":\"code\",\"value\":\"import { render, screen } from 'testing-library/react';\\nimport App from './App.js';\\n        \\ntest('renders learn react link', ()=\u003e{\\n  render(\u003cApp /\u003e);\\n  const linkElement = screen.getByText(/learn react/i);\\n  expect(linkElement).toBeInTheDocument();\\n})\"},{\"type\":\"H3\",\"value\":\"test\"},{\"type\":\"normal\",\"value\":\"test 함수(it 함수와 같은 역할을 하는 함수)를 사용하여 테스트 명세를 작성한 테스트 코드이다.\"},{\"type\":\"H3\",\"value\":\"render\"},{\"type\":\"normal\",\"value\":\"리액트 컴포넌트를 화면에 표시하기 위함\"},{\"type\":\"H3\",\"value\":\"screen\"},{\"type\":\"normal\",\"value\":\"리액트 컴포넌트가 표시된 화면을 의미한다.\"},{\"type\":\"H3\",\"value\":\"GetByText\"},{\"type\":\"normal\",\"value\":\"getByText 함수는 주어진 텍스트를 포함하는 DOM 요소를 찾는 데 사용된다. 렌더링된 컴포넌트에서 screen.GetByText를 통해 화면에서 'learn react'라는 글자를 가지고 있는 돔 요소를 찾는다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('renders Hello World text', () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const textElement = screen.getByText('Hello World');\\n  expect(textElement).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"H3\",\"value\":\"toBeInTheDocument\"},{\"type\":\"normal\",\"value\":\"요소를 찾아 jest expect().toBeInTheDocument()를 사용하여 돔에 표시되어 있는지 확인 한다. \u003c/br\u003e\\n\\n        render 함수는 메모리상에 돔을 만들고 screen을 통해 해당 돔에 접근 하는 것을 의미한다.\\n        react-testing-library의 render 함수를 사용하여 App이라는 컴포넌트를 렌더링 하였다.\"},{\"type\":\"h2\",\"value\":\"React Testing Library의 주요 쿼리 함수\"},{\"type\":\"H3\",\"value\":\"getByText\"},{\"type\":\"normal\",\"value\":\"주어진 텍스트를 포함하는 요소를 찾습니다.\u003c/br\u003e\\n        ex) screen.getByText(/learn react/i)는 대소문자를 구분하지 않고 \\\"learn react\\\"라는 텍스트를 포함하는 요소를 찾습니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('renders learn react link', () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const linkElement = screen.getByText(/learn react/i);\\n  expect(linkElement).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"H3\",\"value\":\"getByRole\"},{\"type\":\"normal\",\"value\":\"특정 역할(예: 버튼, 링크)을 가진 요소를 찾습니다.\u003c/br\u003e\\n        screen.getByRole('button', { name: /submit/i })은 \\\"submit\\\" 텍스트를 가진 버튼을 찾습니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('renders submit button', () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const buttonElement = screen.getByRole('button', { name: /submit/i });\\n  expect(buttonElement).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"H3\",\"value\":\"getByLabelText\"},{\"type\":\"normal\",\"value\":\"특정 라벨 텍스트와 연결된 요소(주로 폼 필드)를 찾습니다.\u003c/br\u003e\\n        screen.getByLabelText('Username')은 \\\"Username\\\" 라벨을 가진 입력 필드를 찾습니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport LoginForm from './LoginForm';\\n        \\ntest('finds the username input', () =\u003e {\\n  render(\u003cLoginForm /\u003e);\\n  const inputElement = screen.getByLabelText('Username');\\n  expect(inputElement).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"H3\",\"value\":\"getByPlaceholderText\"},{\"type\":\"normal\",\"value\":\"특정 플레이스홀더 텍스트를 가진 입력 요소를 찾습니다. \u003c/br\u003e\\n        screen.getByPlaceholderText('Enter your username')은 \\\"Enter your username\\\" 플레이스홀더를 가진 입력 필드를 찾습니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport LoginForm from './LoginForm';\\n        \\ntest('finds the input by placeholder', () =\u003e {\\n  render(\u003cLoginForm /\u003e);\\n  const inputElement = screen.getByPlaceholderText('Enter your username');\\n  expect(inputElement).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"H3\",\"value\":\"getByAltText\"},{\"type\":\"normal\",\"value\":\"주어진 alt 텍스트를 가진 이미지를 찾습니다.\u003c/br\u003e\\n        screen.getByAltText('Profile Picture')은 \\\"Profile Picture\\\" alt 텍스트를 가진 이미지를 찾습니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport Profile from './Profile';\\n        \\ntest('finds the profile picture', () =\u003e {\\n  render(\u003cProfile /\u003e);\\n  const imageElement = screen.getByAltText('Profile Picture');\\n  expect(imageElement).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"H3\",\"value\":\"getByTestId\"},{\"type\":\"normal\",\"value\":\"data-testid 속성을 사용하여 요소를 찾습니다. \u003c/br\u003e\\n        screen.getByTestId('custom-element')은 data-testid=\\\"custom-element\\\" 속성을 가진 요소를 찾습니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport Component from './Component';\\n        \\ntest('finds element by test id', () =\u003e {\\n  render(\u003cComponent /\u003e);\\n  const element = screen.getByTestId('custom-element');\\n  expect(element).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"H3\",\"value\":\"queryByText\"},{\"type\":\"normal\",\"value\":\"요소가 존재하지 않거나, 하나만 존재할 때 사용합니다. 존재하지 않으면 null을 반환합니다. \u003c/br\u003e\\n        getByText는 요소가 없으면 에러를 던집니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('does not find non-existing text', () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const textElement = screen.queryByText('Non-existing Text');\\n  expect(textElement).toBeNull();\\n});\\n        \"},{\"type\":\"H3\",\"value\":\"findByText\"},{\"type\":\"normal\",\"value\":\"비동기적으로 요소를 찾을 때 사용합니다. 주로 요소가 나중에 렌더링될 경우에 사용합니다. 반환 값은 Promise입니다.\"},{\"type\":\"code\",\"value\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('renders welcome message', async () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const messageElement = await screen.findByText(/welcome/i);\\n  expect(messageElement).toBeInTheDocument();\\n});\\n        \"},{\"type\":\"h2\",\"value\":\"참고할만한 예제들\"},{\"type\":\"H3\",\"value\":\"예제 [1] - 컴포넌트가 올바르게 렌더링되는지를 확인하는 테스트 케이스\"},{\"type\":\"normal\",\"value\":\"\u0026lt;App /\u003e에 대한 Jest 테스트 스위트를 작성한 것으로 \u003cApp /\u003e 컴포넌트가 올바르게 렌더링되는지를 확인하는 하나의 테스트 케이스를 포함하고 있다.\"},{\"type\":\"keyword\",\"value\":\"render,getElementByClassName,toHaveLength,toHaveAttribute\"},{\"type\":\"code\",\"value\":\"describe('\u0026lt;App /\u003e', ()=\u003e{\\nit('renders component correctly', ()=\u003e{      \\n      ① const { container } = render(\u003cApp /\u003e);              \\n      ② expect(container.getElementByClassName('App-logo')).toHaveLength(1);       \\n      ③ expect(container.getElementByClassName('App-logo')[0]).toHaveAttribute('src','logo.svg');\\n    })\\n})\"},{\"type\":\"normal\",\"value\":\"① 이 줄은 \u0026lt;App /\u003e 컴포넌트를 렌더링한다. render 함수는 컴포넌트를 가상 DOM에 렌더링하고, 반환된 객체에서 container를 구조 분해 할당하여 가져오며 container는 렌더링된 DOM 트리를 포함한다.\\n        ② 이 줄은 container 안에 'App-logo' 클래스를 가진 요소가 하나 있는지 확인한다. expect 함수는 기대값을 설정하는 데 사용되고, toHaveLength(1)는 요소의 길이가 1인지 확인한다.\\n        ③ 이 줄은 'App-logo' 클래스를 가진 첫 번째 요소가 'src' 속성을 가지고 있으며, 그 값이 'logo.svg'인지 확인한다. toHaveAttribute('src', 'logo.svg')는 요소의 src 속성이 'logo.svg'인지를 확인한다.\"},{\"type\":\"H3\",\"value\":\"예제 [2] - \u003cimg /\u003e 테스트 코드\"},{\"type\":\"keyword\",\"value\":\"render,getElementsByTagName,toHaveLength,toHaveTextContext\"},{\"type\":\"code\",\"value\":\"describe('\u0026lt;App /\u003e', ()=\u003e{\\nit('renders component correctly', ()=\u003e{\\n      ①const { container } = render(\u003cApp /\u003e);  \\n      ② expect(container.getElementsByTagName('p')).toHaveLength(1);\\n      ③ expect(container.getElementsByTagName('p')[0]).toHaveTextContext('Edit src/App.js and save to reload.')\\n   })\\n})\"},{\"type\":\"normal\",\"value\":\"① 이 줄은 \u0026lt;App /\u003e 컴포넌트를 렌더링한다. render 함수는 컴포넌트를 가상 DOM에 렌더링하고, 반환된 객체에서 container를 구조 분해 할당하여 가져오며 container는 렌더링된 DOM 트리를 포함한다.\\n        ② 이 줄은 container 안에 \u003cp\u003e 태그를 가진 요소가 하나 있는지 확인한다. expect 함수는 기대값을 설정하는 데 사용되고, toHaveLength(1)는 해당 요소의 길이가 1인지 확인한다.\\n        ③ 이 줄은 \u0026lt;p\u003e 태그를 가진 첫 번째 요소가 'Edit src/App.js and save to reload.'라는 텍스트 내용을 가지고 있는지 확인한다. expect 함수는 기대값을 설정하는 데 사용되고, toHaveTextContent('Edit src/App.js and save to reload.')는 해당 요소의 텍스트 내용이 정확히 일치하는지를 확인한다.\"},{\"type\":\"H3\",\"value\":\"예제 [3] - \u003cp/\u003e 테스트\"},{\"type\":\"code\",\"value\":\"describe('\u0026lt;App /\u003e', ()=\u003e{\\n  it('renders component correctly', ()=\u003e{\\n      const { container } = render(\u003cApp /\u003e);    \\n      expect(container).toMatchSnapshot();\\n    })\\n})\"},{\"type\":\"normal\",\"value\":\"toMatchSnapshot가 실행되면 src/snapshots/App.test.js.snap이라는 파일이 생성된 것을 확인 할 수 있다. 파일을 열어 내용을 확인해 보면 App 컴포넌트가 화면에 렌더링될 때 표시되는 HTML 내용이 저장된 것을 확인 할 수 있다.\u003c/br\u003e\\n        저장된 스냅샷은 App 컴포넌트가 수정되어 화면에 표시되는 HTML 구조가 변경되면 에러를 표시하게 된다. 이렇게 스냅샷은 화면에 표시되는 컴포넌트가 변경되었는지 감지하기 위한 테스트로 많이 사용된다.\"},{\"type\":\"emphasis\",\"value\":\"만약 컴포넌트를 수정하여 화면 표시가 변경된 것이 의도된 수정이었다면 스냅샷 테스트로 저장된 파일을 업데이트해 주어야 한다. 명령프롬프트에 에러가 표시된 상태에서 키보드 'u'키를 누르면 스냅샷으로 생성된 파일이 업데이트 된다. 그러면 새롭게 업데이트된 스냅샷 파일이 다시 기준이 되어 변경을 감지하고 에러를 표시하게 된다.\"},{\"type\":\"H3\",\"value\":\"예제 [4] - 스냅샷 (화면에 표시되는 내용이 변경 되었는지 체크)\"},{\"type\":\"keyword\",\"value\":\"getByText,parentElement,toHaveStyleRule\"},{\"type\":\"normal\",\"value\":\"Button 컴포넌트는 Props만을 가지는 단순 컴포넌트이다.\\n        Button 컴포넌트가 화면에 잘 표시 되는지, Props가 잘 적용되는지를 확인하도록 한다.\"},{\"type\":\"code\",\"value\":\"import React from 'react';\\nimport { render, screen } from 'testing-library/react';\\nimport 'jest-styled-components';\\nimport {Button} from './index';\\n\\ndescribe('\u0026lt;Button /\u003e', ()=\u003e{\\n  it('renders component correctly', ()=\u003e{\\n        ① const { container } = render(\u0026lt;Button label=\\\"Button Test\\\" /\u003e);\\n\\n        ② const label = screen.getByText(\\\"button Test\\\");\\n           expect(label).toBeInTheDocument();\\n\\n        ③ const parent = label.parentElement;\\n        ④ expect(parent).toHaveStyleRule('background-color', '#304FFE');\\n          expect(parent).toHaveStyleRule('background-color', '#1E40FF', { modifier:'hover'});\\n        \\n        ⑤ expect(container).toMatchSnapshot();\\n    })\\n})\"},{\"type\":\"normal\",\"value\":\"\\n        ① render 함수는 \u0026lt;Button label=\\\"Button Test\\\" /\u003e를 가상 DOM에 렌더링하고, 반환된 객체에서 container를 구조 분해 할당한다. \u003c/br\u003e\u003c/br\u003e\\n② screen.getByText를 사용하여 \\\"Button Test\\\"라는 텍스트를 가진 요소를 찾는다. \\nexpect로 해당 요소가 문서에 존재하는지 확인한다.\u003c/br\u003e\u003c/br\u003e\\n③ label 요소의 부모 요소(parentElement)를 가져온다.\u003c/br\u003e\u003c/br\u003e\\n\\n④ expect를 사용하여 부모 요소가 특정 스타일 규칙을 가지고 있는지 확인한다. jest-styled-components의 toHaveStyleRule을 사용하여 다음 두 가지 스타일 규칙을 확인한다.\u003c/br\u003e\"},{\"type\":\"stringlist\",\"value\":\"기본 배경색이 #304FFE인지\\n        hover 상태에서 배경색이 #1E40FF인지\"},{\"type\":\"normal\",\"value\":\"backgroundColor과 hoverColor은 우리가 screen.getByText로 찾은 Label 컴포넌트가 아닌 Label 컴포넌트의 부모 요소인 Container 컴포넌트에 설정이 된다. 따라서 label.parentElement를 사용해 Label 컴포넌트의 부모 요소(Container 컴포넌트)에 접근하여 값이 잘 설정 되었는지 확인 한다.\u003c/br\u003e\u003c/br\u003e\\n\\n        Button 컴포넌트는 Props로 BackgroundClolor과 hoverColor이 설정되어 있지 않으면 기본값이 설정되도록 개발 되었다. backgroundColor과 hoverColor가 설정되어 있지 않은 상황에서 기본값이 잘 설정되는지 확인하기 위해 jest-styled-components의 새로운 Matcher인 toHaveStyleRule를 사용하여 확인 하도록 한다.\"},{\"type\":\"normal\",\"value\":\"⑤ 마지막으로, container의 현재 상태를 스냅샷으로 저장하여 이후 테스트 실행 시 컴포넌트의 출력이 변하지 않았는지 확인합니다.\"},{\"type\":\"H3\",\"value\":\"예제 [4] - onClick 함수 테스트\"},{\"type\":\"normal\",\"value\":\"Button 컴포넌트의 onClick 함수를 테스트 하기 위한 테스트 명세이다.\"},{\"type\":\"code\",\"value\":\"it('clicks the button', () =\u003e {\\n    ① const handlerClick = jest.fn(); \\n    ② render(\u0026lt;Button label=\\\"Button Test\\\" onClick={handlerClick} /\u003e); \\n    ③ const label = screen.getByText('Button Test'); \\n    ④ expect(handleClick).toHaveBeenCalledTimes(0); \\n    ⑤ fireEvent.click(label); \\n    ⑥ expect(handlerClick).toHaveBeenCalledTimes(1); \\n});\"},{\"type\":\"normal\",\"value\":\"\\n        ① 클릭 핸들러 함수로 jest.fn()을 사용하여 mock 함수 생성 \u003c/br\u003e\\n        ② Button 컴포넌트를 렌더링하고, onClick props에 mock 함수 전달\u003c/br\u003e\\n        ③ 화면에서 \\\"Button Test\\\" 라는 텍스트를 가진 요소를 찾음\u003c/br\u003e\\n        ④ 클릭 이벤트가 발생하지 않았는지 확인\u003c/br\u003e\\n        ⑤ 찾은 요소에 클릭 이벤트를 발생시킴\u003c/br\u003e\\n        ⑥ 클릭 이벤트 핸들러가 한 번 호출되었는지 확인\u003c/br\u003e\\n        \"},{\"type\":\"normal\",\"value\":\"그다음 화면에 표시된 버튼 컴포넌트를 찾아서 아직 해당 컴포넌트를 클릭하지 않았음을 확인하기 위해 toHaveBeenCalledTimes 함수를 사용하여 우리가 만든 모의함수가 잘 호출되었는지 확인해준다.\"},{\"type\":\"emphasis\",\"value\":\"\u003cb\u003e모의 함수(Mocking functions)\u003c/b\u003e\u003c/br\u003e\\n        onClick 이벤트에는 사실 어떤 함수가 연결될지 알 수가 없다. jest에서는 이처럼 어떤 이벤트를 통해 함수가 호출되는지를 확인하기 위해 모의 함수(Mocking functions)를 사용한다. 모의 함수를 사용하여 onClick 이벤트를 테스트 한다.\u003c/br\u003e\u003c/br\u003e\\n\\njest의 모의함수(jest.fn)을 사용하여 handlerClick 변수를 선언하고 Button 컴포넌트의 Props로 onClick을 통해 전달 해준다.\\n        \"},{\"type\":\"H3\",\"value\":\"예제 [5] - \u003cInput /\u003e 입력된 값이 일치 체크\"},{\"type\":\"keyword\",\"value\":\"getByDisplayValue,getByPlaceholderText,fireEvent,fireEvent.change\"},{\"type\":\"h4\",\"value\":\"getByDisplayValue를 이용하여 input을 찾아 렌더링 하는 예제\"},{\"type\":\"code\",\"value\":\"import React from 'react';\\nimport { render, screen, fireEvent } from 'testing-library/react';\\nimport 'jest-styled-components';\\nimport {Input} from './index';\\n\\ndescribe('\u0026lt;Input /\u003e', ()=\u003e{\\n\\tit('renders component correctly', ()=\u003e{\\n      ① const { container } = render(\u0026lt;Input value=\\\"default value\\\" /\u003e);\\n      ② const label = screen.getByDisplayValue(\\\"default value\\\");\\n      ③ expect(label).toBeInTheDocument();\\n      ④ expect(container).toMatchSnapshot();\\n   })\\n})\"},{\"type\":\"normal\",\"value\":\"이 코드는 React 컴포넌트 \u0026lt;Input /\u003e를 테스트하기 위해 작성된 Jest 테스트 파일이다. react-testing-library와 jest-styled-components를 사용하여 \u0026lt;Input /\u003e 컴포넌트의 렌더링 및 동작을 한다.\"},{\"type\":\"normal\",\"value\":\"① render 함수는 \u0026lt;Input /\u003e 컴포넌트를 렌더링합니다. 여기서 value prop으로 \\\"default value\\\"를 설정합니다.\u003c/br\u003e\\n② screen.getByDisplayValue 함수는 주어진 값(\\\"default value\\\")을 표시하는 요소를 검색합니다.\u003c/br\u003e\\n　여기서는 \u0026lt;Input /\u003e 컴포넌트가 \\\"default value\\\"라는 값을 가진 입력 필드를 렌더링하는지 확인합니다.\u003c/br\u003e\\n③ expect 함수는 단언(assertion)을 정의합니다. 여기서는 label 요소가 문서 내에 존재하는지 확인합니다.\\n　toBeInTheDocument 매처는 요소가 실제로 DOM에 존재하는지 확인합니다.\"},{\"type\":\"normal\",\"value\":\"Input 컴포넌트는 Button 컴포넌트와 다르게 필수 Props가 존재하지 않는다. 따라서 화면에 표시되었는지를 알기 위해 검색(Query)할 방법이 없다. \u003c/br\u003e\\n\\n그래서 Input 컴포넌트의 필수가 아닌 Props인 value값을 설정하고 react-testing-library의 screen.getByDisplayValue를 사용하여 input 컴포넌트를 찾는다.\"},{\"type\":\"h4\",\"value\":\"getByPlaceholderText를 이용하여 input을 찾아 렌더링 하는 예제\"},{\"type\":\"code\",\"value\":\"it('renders placeholder correctly', ()=\u003e{\\n    render(\u0026lt;Input placeholder=\\\"default placeholder\\\" /\u003e);\\n\\n    const input = screen.getByPlaceholderText(\\\"default placeholder\\\");\\n    expect(input).toBeInTheDocument();        \\n})\"},{\"type\":\"h4\",\"value\":\"fireEvent를 이용하여 이벤트 테스트 하는 예제\"},{\"type\":\"code\",\"value\":\"import { render, screen, fireEvent } from 'testing-library/react';\\n\\nit('renders placeholder correctly', ()=\u003e{\\n    render(\u0026lt;Input placeholder=\\\"default placeholder\\\" /\u003e);\\n        \\n    const input = screen.getByPlaceholderText(\\\"default placeholder\\\") as HTMLInputElement;\\n        \\n    fireEvent.change(input, {target:{ value:'study react'}})\\n    expect(input.value).toBe('study react')\\n})\"},{\"type\":\"normal\",\"value\":\"Input 컴포넌트의 placeholder를 사용하여 Input 컴포넌트를 화면에 표시하고 해당컴포넌트를 getByPlaceholderText를 통해 찾았다. 이렇게 찾은 컴포넌트는 기본적으로 HTMLElement타입이다. 하지만 HTML의 input 태그를 사용하고 있으므로, 타입스크립트의 as를 사용하여 HTMLInputElement로 타입변환을 해준다.\"},{\"type\":\"normal\",\"value\":\"fireEvent의 change함수로 실제 사용자가 데이터를 입력하는 테스트 코드를 작성 해준다.\\n앞에서 찾은 Input 컴포넌트에 데이터를 입력해주고 입력된 데이터가 실제로 화면에 잘 표시 되고 있는지를 확인하기 위해 toBe를 사용하여 input, value값이 우리가 fireEvent를 사용하여 입력한 값과 같은지 확인 하였다.\"}]},\"segment\":\"posts\"}],[\"$\",\"div\",null,{\"className\":\"footer_footer_container__MsSvO\",\"children\":[\"$\",\"footer\",null,{\"className\":\"footer_footer__AwYty\",\"children\":[[\"$\",\"p\",null,{\"className\":\"footer_copylight___J5l0\",\"children\":[\"© 2024 \",\"베짱이가 되고싶은 개미。\",\" Some rights reserved.\"]}],[\"$\",\"p\",null,{\"className\":\"footer_theme__bwXbg\",\"children\":\"portfolio v1.0.0-alpha.3\"}]]}]}]],null]]},[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"categories\",\"children\",\"$a\",\"children\",\"$b\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/4be7aaf21dbfc26e.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]]},[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"categories\",\"children\",\"$a\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"categories\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]],\"search\":[\"__DEFAULT__\",{},[\"$d\",\"$Lf\",null]]},[null,[\"$\",\"$L10\",null,{\"children\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}],\"search\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"search\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"search\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$11\",\"styles\":null}],\"params\":{}}],null]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"className\":\"\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css\",\"as\":\"style\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.googleapis.com\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.gstatic.com\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR\u0026display=swap\",\"as\":\"style\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":\"$12\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":\"$13\",\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":\"$14\",\"children\":[\"$\",\"h2\",null,{\"style\":\"$15\",\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/04d20c09b3119d43.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]}]]}],null]],\"initialHead\":[false,\"$L16\"],\"globalErrorComponent\":\"$17\"}]]\n"])</script><script>self.__next_f.push([1,"f:E{\"digest\":\"NEXT_NOT_FOUND\"}\n"])</script><script>self.__next_f.push([1,"16:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"be come 💡\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"App for an Ant Who Wants to Become a Bejjangyi\"}]]\n6:null\ne:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>