<!DOCTYPE html><html lang="en" class=""><head><meta charSet="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/80c9ce4c138da48c.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0c496b0e03d530ba.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/19d2a4a42355ad75.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-ccbb0ed0b14a6538.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-0e492acdb34e0e7d.js" async="" crossorigin=""></script><script src="/_next/static/chunks/938-073485517c55f951.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-d3c7d898fafbc3cf.js" async="" crossorigin=""></script><script src="/_next/static/chunks/250-8b90be581650ff9d.js" async=""></script><script src="/_next/static/chunks/399-caf055eb211349e2.js" async=""></script><script src="/_next/static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-bbcf6e36dfc402e9.js" async=""></script><script src="/_next/static/chunks/46-f5c36f830a2ce4c4.js" async=""></script><script src="/_next/static/chunks/730-f56ebe909f1c8bdb.js" async=""></script><script src="/_next/static/chunks/35-86206131b00fc69c.js" async=""></script><script src="/_next/static/chunks/app/(layoutCase)/layout-3f2d0dcd82d40488.js" async=""></script><title>be come 💡</title><meta name="description" content="App for an Ant Who Wants to Become a Bejjangyi"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" as="style"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR&amp;display=swap" as="style"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><aside id="sidebar" class="sidemenu_sidebar__EmvJl"><header class="sidemenu_profile_wrapper__R57aU"><div class="sidemenu_profile__R1Mv0"><a href="/posts"><div class="imageLoader_imgloaderContainer__d3Tsu"><img alt="프로필이미지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" style="color:transparent;border-radius:50%;width:100%;height:auto" srcSet="https://nam-yeun-hwa.github.io/image/profile1.jpg?w=128&amp;q=75 1x, https://nam-yeun-hwa.github.io/image/profile1.jpg?w=256&amp;q=75 2x" src="https://nam-yeun-hwa.github.io/image/profile1.jpg?w=256&amp;q=75"/></div></a></div><h1 class="sidemenu_blog_name_txt__AfWhD">my blog</h1><p class="sidemenu_site_subtitle__eLcN7">You can only earn as much as an ant does by working like an ant.</p></header><nav><ul class="sidemenu_nav__6C5tz"><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/posts"><i class="fa-fw fas fa-home sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">HOME</span></a></li><li class="sidemenu_nav_item__tt_B1 sidemenu_active__fflT6"><a class="sidemenu_nav_link__WTCmf" href="/categories"><i class="fa-fw fas fa-stream sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">CATEGORIES</span></a></li><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/tags"><i class="fa-fw fas fa-tags sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">TAGS</span></a></li><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/archives"><i class="fa-fw fas fa-archive sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">ARCHIVES</span></a></li></ul></nav><div class="sidebar-bottom"></div></aside><div class="layout_main_wrapper__1M1Uy"><div class="contents_container__AfHAx"><header class="breadCrumb_topbar_wrapper__dGN_V"><div class="breadCrumb_top_bar__b_rV9"><nav class="breadCrumb_breadcrumb__l7WLX"><span><a class="breadCrumb_topbar_txt__ExrWf" href="/">Home</a><a class="breadCrumb_topbar_txt__ExrWf" href="">[TECH-QA] 원시값과 참조형</a></span></nav><search class="searchBar_search__Ftlhc"><i class="fas fa-search fa-fw searchBar_search_ico__STStc"></i><input id="search" class="searchBar_search_input__1XpQF" placeholder="Search..." autoComplete="off" value=""/></search></div><div class="breadCrumb_mobile_topbar__N1Azi"><button class="breadCrumb_sidebar_trigger__APgD8"><i class="fas fa-bars fa-fw breadCrumb_sidebar_trigger_ico__K9DdV"></i></button><div class="breadCrumb_mobile_topbar_title__oCVBS">be come 💡</div><button class="breadCrumb_search_trigger__PxWyf"><i class="fas fa-search fa-fw breadCrumb_search_trigger_ico__yqqpz"></i></button></div></header><div class="contents_contents__Hpf57"><main class="contents_inner_content__wyt37"><article><header><h1 class="postUserInfo_h1__uhAqy">[TECH-QA] 원시값과 참조형</h1></header></article><div class="postUserInfo_post_meta__ABvuC"><span>Posted<!-- --> <time class="postUserInfo_time__2exyR">16 days<!-- --> </time></span><span class="postUserInfo_update__f345P">Updated<!-- --> <time class="postUserInfo_time__2exyR">16 days</time></span></div><div><span class="postUserInfo_post_meta__ABvuC">By<!-- --> <em><a class="postUserInfo_author__fVGYM" href="https://nam-yeun-hwa.github.io/">베짱이가 되고싶은 개미。</a></em></span></div><div class="postDetail_content__OTeO2">자바스크립트에서 원시값(Primitive Values)과 참조형(Reference Types)의 동작 방식, 그리고 이들의 불변성(Immutability)과 가변성(Mutability)에 대해 설명 해 보겠습니다.</div><h2 class="heading_h2__fsXMw" style="font-weight:NORMAL">원시값 (Primitive Values)</h2><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4"><b>정의</b> : 원시값은 더 이상 쪼갤 수 없는 기본 데이터 타입으로, 자바스크립트에서는 undefined, null, boolean, number, bigint, string, symbol이 이에 해당합니다.</li><li class="liststyle_dot__SMzS4"><b>복제 방식</b> : 다른 변수에 원시값을 복사할 때, 해당 값이 그대로 복사되어 새로운 변수에 저장됩니다. 이때 메모리 주소 개념은 관여하지 않고, <b>단순히 값만 복사</b>됩니다.</li><li class="liststyle_dot__SMzS4"><b>불변성</b> : 원시값은 불변값입니다. 값을 변경하려고 하면, 기존 메모리 공간의 값을 수정하는 대신 새로운 메모리 공간에 새로운 값을 저장하고, 변수가 참조하던 메모리 주소를 변경합니다.</li></ul><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">let a = 10; // a는 숫자 10을 저장
let b = a;  // b에 a의 값 10을 복사 (독립적인 메모리 공간)

console.log(a); // 10
console.log(b); // 10

b = 20; // b에 새로운 값 20을 할당 (새로운 메모리 공간 사용)
console.log(a); // 10 (a는 여전히 10을 참조)
console.log(b); // 20</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">b = a를 실행하면, a의 값 10이 복사되어 b에 저장됩니다. 이때 <b>a와 b는 각각 독립적인 메모리 공간</b>을 가리킵니다.</li><li class="liststyle_dot__SMzS4">b = 20으로 값을 변경하면, b는 새로운 메모리 공간에 20을 저장하고 그 주소를 참조합니다. a는 영향을 받지 않습니다.</li><li class="liststyle_dot__SMzS4">원시값은 불변적이므로, a나 b의 값을 직접 수정하는 대신 새로운 값을 메모리에 할당합니다.</li></ul><h2 class="heading_h2__fsXMw" style="font-weight:NORMAL">참조형 (Reference Types)</h2><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4"><b>정의</b> : 참조형은 <span class="point">객체(Object)</span>, <span class="point">배열(Array)</span>, <span class="point">함수(Function)</span> 등으로, 여러 값을 하나의 단위로 묶은 데이터 타입입니다.</li><li class="liststyle_dot__SMzS4"><b>복제 방식</b> : 참조형은 값이 담긴 <b>메모리 주소를 복제</b>합니다. 즉, 변수는 실제 데이터(객체)가 저장된 메모리 주소를 가리키며, 복사 시 이 주소를 복사합니다. <span class="point">따라서 복사된 변수는 원본 객체와 동일한 메모리 주소를 참조</span>합니다.</li><li class="liststyle_dot__SMzS4"><b>가변성</b> : 참조형은 가변값입니다. 객체가 저장된 메모리 공간은 수정 가능하며, 변수는 해당 객체를 직접 변경할 수 있습니다. 객체의 프로퍼티를 추가, 갱신, 삭제할 수 있습니다.</li></ul><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">let obj1 = { name: &quot;Alice&quot;, age: 25 }; // obj1은 객체의 메모리 주소를 참조
let obj2 = obj1; // obj2는 obj1과 동일한 메모리 주소를 참조

console.log(obj1); // { name: &quot;Alice&quot;, age: 25 }
console.log(obj2); // { name: &quot;Alice&quot;, age: 25 }

// obj2를 통해 객체 수정
obj2.age = 30;
obj2.city = &quot;Seoul&quot;; // 동적으로 프로퍼티 추가

console.log(obj1); // { name: &quot;Alice&quot;, age: 30, city: &quot;Seoul&quot; }
console.log(obj2); // { name: &quot;Alice&quot;, age: 30, city: &quot;Seoul&quot; }

// 프로퍼티 삭제
delete obj1.city;

console.log(obj1); // { name: &quot;Alice&quot;, age: 30 }
console.log(obj2); // { name: &quot;Alice&quot;, age: 30 }</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">obj2 = obj1은 obj1이 참조하는 객체의 메모리 주소를 obj2에 복사합니다. 따라서 obj1과 obj2는 동일한 객체를 가리킵니다.</li><li class="liststyle_dot__SMzS4">obj2.age = 30 또는 obj2.city = "Seoul"로 객체를 수정하면, 동일한 메모리 공간을 참조하는 obj1에도 변경 사항이 반영됩니다.</li><li class="liststyle_dot__SMzS4">참조형은 가변적이므로, 객체의 프로퍼티를 동적으로 추가(city), 갱신(age), 삭제(delete obj1.city)할 수 있습니다.</li></ul><h2 class="heading_h2__fsXMw" style="font-weight:NORMAL">원시값 vs 참조형 비교</h2><table class="BasicTypeTable_table__Emrp_"><thead><tr><th><div class="headerAction_element__WDAVu"><div class="headerAction_txt__tbutB">특징</div></div></th><th><div class="headerAction_element__WDAVu"><div class="headerAction_txt__tbutB">원시값 (Primitive)</div></div></th><th><div class="headerAction_element__WDAVu"><div class="headerAction_txt__tbutB">참조형 (Reference)</div></div></th></tr></thead><tbody><tr class="BasicTypeTable_td__r_Im5"><td>데이터 타입</td><td>number, string, boolean 등</td><td>object, array, function 등</td></tr><tr class="BasicTypeTable_td__r_Im5"><td>복제 방식</td><td>값 자체 복사</td><td>메모리 주소 복사</td></tr><tr class="BasicTypeTable_td__r_Im5"><td>변경 가능성</td><td>불변 (새로운 값으로 교체)</td><td>가변 (객체 내부 수정 가능)</td></tr><tr class="BasicTypeTable_td__r_Im5"><td>메모리 동작</td><td>새로운 메모리 공간 생성</td><td>동일한 메모리 공간 공유</td></tr><tr class="BasicTypeTable_td__r_Im5"><td>예시</td><td>let x = 5; x = 10;</td><td>let obj = {a: 1}; obj.a = 2;</td></tr></tbody></table><h2 class="heading_h2__fsXMw" style="font-weight:NORMAL">참조형의 깊은 복사(Deep Copy)</h2><div class="postDetail_content__OTeO2">참조형의 기본 복사는 얕은 복사(Shallow Copy)로, 동일한 객체를 참조하게 됩니다. 객체를 독립적으로 복사하려면 깊은 복사가 필요합니다.</div><h4 class="heading_h4__ZTbA0" style="font-weight:NORMAL">📝 <!-- -->얕은 복사 vs 깊은 복사</h4><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">// 얕은 복사
let original = { name: &quot;Bob&quot;, info: { age: 40 } };
let shallowCopy = Object.assign({}, original);

shallowCopy.name = &quot;Charlie&quot;;
shallowCopy.info.age = 50;

console.log(original); // { name: &quot;Bob&quot;, info: { age: 50 } } (info는 여전히 공유됨)
console.log(shallowCopy); // { name: &quot;Charlie&quot;, info: { age: 50 } }

// 깊은 복사
let deepCopy = JSON.parse(JSON.stringify(original));

deepCopy.name = &quot;David&quot;;
deepCopy.info.age = 60;

console.log(original); // { name: &quot;Bob&quot;, info: { age: 50 } } (변경되지 않음)
console.log(deepCopy); // { name: &quot;David&quot;, info: { age: 60 } }</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">얕은 복사(Object.assign)는 최상위 프로퍼티만 복사하고, 중첩 객체(info)는 여전히 원본과 공유됩니다.</li><li class="liststyle_dot__SMzS4">깊은 복사(JSON.parse(JSON.stringify()))는 객체 전체를 새로 생성하여 독립적인 복사본을 만듭니다.</li></ul><h4 class="heading_h4__ZTbA0" style="font-weight:NORMAL">📝 <!-- -->원시값 활용</h4><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">function updateScore(score) {
    score = score + 10; // 새로운 메모리 공간에 값을 저장
    return score;
}

let playerScore = 50;
console.log(updateScore(playerScore)); // 60
console.log(playerScore); // 50 (원본 값은 변경되지 않음)</pre></div></div><div class="postDetail_content__OTeO2">원시값은 함수 내부에서 수정해도 원본에 영향을 주지 않습니다.</div><h4 class="heading_h4__ZTbA0" style="font-weight:NORMAL">📝 <!-- -->참조형 활용</h4><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">function updateProfile(profile) {
    profile.age += 1; // 동일한 객체를 직접 수정
    profile.city = &quot;Busan&quot;; // 동적 프로퍼티 추가
}

let user = { name: &quot;Eve&quot;, age: 28 };
updateProfile(user);

console.log(user); // { name: &quot;Eve&quot;, age: 29, city: &quot;Busan&quot; }</pre></div></div><div class="postDetail_content__OTeO2">참조형은 함수 내부에서 수정하면 원본 객체가 변경됩니다. user 원본 객체가 { name: "Eve", age: 28 } 에서 { name: "Eve", age: 29, city: "Busan" } 으로 변경 됨</div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4"><b>원시값</b>: 값 자체를 복사, 불변, 재할당 시 새로운 메모리 공간 사용.</li><li class="liststyle_dot__SMzS4"><b>참조형</b>: 메모리 주소를 복사, 가변, 객체 내부를 직접 수정 가능 (프로퍼티 추가/갱신/삭제).</li><li class="liststyle_dot__SMzS4">원시값은 독립적이고 안전하지만 수정이 제한적이며, 참조형은 유연하지만 공유 메모리로 인해 주의가 필요합니다.</li><li class="liststyle_dot__SMzS4">깊은 복사를 통해 참조형의 독립적인 복사가 가능합니다.</li></ul><div class="postDetail_content__OTeO2">자바스크립트에서 깊은 복사(Deep Copy)를 하는 방법은 여러 가지가 있습니다. 상황에 따라 간단한 객체부터 복잡한 객체까지 처리할 수 있습니다. 아래에 대표적인 방법과 예제를 정리해 보겠습니다.</div><div class="postDetail_content__OTeO2">구조적 복제 (Structured Clone)</div><div class="postDetail_content__OTeO2">structuredClone()은 브라우저 환경(Node.js 17+ 또는 최신 브라우저)에서 제공되는 깊은 복사를 위한 네이티브 메서드입니다. 이 방법은 JSON 방식보다 더 다양한 데이터 타입(예: Date, Map, Set 등)을 처리할 수 있습니다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">// 원본 객체
let original = {
  name: &quot;Bob&quot;,
  info: { age: 50, date: new Date() },
  hobbies: [&quot;reading&quot;, &quot;gaming&quot;]
};

// 깊은 복사 (structuredClone 사용)
let deepCopy = structuredClone(original);

// 복사본 수정
deepCopy.name = &quot;David&quot;;
deepCopy.info.age = 60;
deepCopy.hobbies.push(&quot;coding&quot;);

console.log(original);
// 출력: { name: &quot;Bob&quot;, info: { age: 50, date: [Date] }, hobbies: [&quot;reading&quot;, &quot;gaming&quot;] }

console.log(deepCopy);
// 출력: { name: &quot;David&quot;, info: { age: 60, date: [Date] }, hobbies: [&quot;reading&quot;, &quot;gaming&quot;, &quot;coding&quot;] }</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">structuredClone()은 객체와 그 하위 구조를 완전히 독립적으로 복사합니다.</li><li class="liststyle_dot__SMzS4">원본 객체의 info.age나 hobbies 배열이 수정되지 않음을 확인할 수 있습니다.</li><li class="liststyle_dot__SMzS4">Date 객체도 별도의 인스턴스로 복사되며, JSON 방식과 달리 손실 없이 복사됩니다.</li></ul><h4 class="heading_h4__ZTbA0" style="font-weight:NORMAL">📝 <!-- -->재귀 함수를 사용한 깊은 복사</h4><div class="postDetail_content__OTeO2">직접 깊은 복사를 구현하는 방법으로, 객체와 배열을 재귀적으로 순회하며 복사합니다. 이 방법은 커스터마이징이 가능하고, 특정 데이터 타입을 추가로 처리할 수 있습니다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">// 깊은 복사 함수
function deepCopy(obj) {
  // 원시값이거나 null인 경우 그대로 반환
  if (obj === null || typeof obj !== &quot;object&quot;) {
    return obj;
  }

  // 배열인 경우
  if (Array.isArray(obj)) {
    return obj.map(item =&gt; deepCopy(item));
  }

  // 객체인 경우
  const copy = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      copy[key] = deepCopy(obj[key]);
    }
  }
  return copy;
}</pre></div></div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">

// 원본 객체
let original = {
  name: &quot;Bob&quot;,
  info: { age: 50 },
  hobbies: [&quot;reading&quot;, &quot;gaming&quot;]
};

// 깊은 복사
let deepCopy = deepCopy(original);

// 복사본 수정
deepCopy.name = &quot;David&quot;;
deepCopy.info.age = 60;
deepCopy.hobbies.push(&quot;coding&quot;);

console.log(original);
// 출력: { name: &quot;Bob&quot;, info: { age: 50 }, hobbies: [&quot;reading&quot;, &quot;gaming&quot;] }

console.log(deepCopy);
// 출력: { name: &quot;David&quot;, info: { age: 60 }, hobbies: [&quot;reading&quot;, &quot;gaming&quot;, &quot;coding&quot;] }</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">deepCopy 함수는 재귀적으로 객체의 모든 프로퍼티를 복사합니다.</li><li class="liststyle_dot__SMzS4">배열과 객체를 구분하여 처리하며, 원시값은 그대로 반환합니다.</li><li class="liststyle_dot__SMzS4">이 방식은 JSON 방식의 한계를 극복하고, 함수나 undefined 같은 값도 커스터마이징하여 처리할 수 있습니다(필요 시 추가 로직 구현 가능).</li></ul><h4 class="heading_h4__ZTbA0" style="font-weight:NORMAL">📝 <!-- -->Lodash 라이브러리의 _.cloneDeep</h4><div class="postDetail_content__OTeO2">실제 프로젝트에서는 Lodash 같은 라이브러리를 사용하는 경우가 많습니다. Lodash의 _.cloneDeep 메서드는 깊은 복사를 간편하게 수행하며, 다양한 데이터 타입을 안전하게 처리합니다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">// Lodash를 사용하기 위해 필요 (HTML에서는 CDN 또는 모듈로 임포트)
// 예: &lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot;&gt;&lt;/script&gt;

// 원본 객체
let original = {
  name: &quot;Bob&quot;,
  info: { age: 50 },
  hobbies: [&quot;reading&quot;, &quot;gaming&quot;]
};

// 깊은 복사 (Lodash 사용)
let deepCopy = _.cloneDeep(original);

// 복사본 수정
deepCopy.name = &quot;David&quot;;
deepCopy.info.age = 60;
deepCopy.hobbies.push(&quot;coding&quot;);

console.log(original);
// 출력: { name: &quot;Bob&quot;, info: { age: 50 }, hobbies: [&quot;reading&quot;, &quot;gaming&quot;] }

console.log(deepCopy);
// 출력: { name: &quot;David&quot;, info: { age: 60 }, hobbies: [&quot;reading&quot;, &quot;gaming&quot;, &quot;coding&quot;] }</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">_.cloneDeep은 Lodash 라이브러리의 깊은 복사 메서드로, 복잡한 객체 구조를 안전하게 복사합니다.</li><li class="liststyle_dot__SMzS4">JSON 방식보다 다양한 데이터 타입(예: 함수, RegExp, Map)을 지원하며, 성능도 최적화되어 있습니다.</li><li class="liststyle_dot__SMzS4">실제 프로젝트에서 신뢰할 수 있는 방법 중 하나입니다.</li></ul><table class="BasicTypeTable_table__Emrp_"><thead><tr><th><div class="headerAction_element__WDAVu"><div class="headerAction_txt__tbutB">방법</div></div></th><th><div class="headerAction_element__WDAVu"><div class="headerAction_txt__tbutB">장점</div></div></th><th><div class="headerAction_element__WDAVu"><div class="headerAction_txt__tbutB">단점</div></div></th></tr></thead><tbody><tr class="BasicTypeTable_td__r_Im5"><td>JSON.parse(JSON.stringify())</td><td>간단하고 별도 라이브러리 불필요</td><td>undefined, 함수, Date 등 일부 데이터 타입 손실 가능</td></tr><tr class="BasicTypeTable_td__r_Im5"><td>structuredClone()</td><td>네이티브 API, 다양한 데이터 타입 지원, 손실 없음</td><td>브라우저/Node.js 버전 의존성 (구형 환경에서 동작하지 않을 수 있음)</td></tr><tr class="BasicTypeTable_td__r_Im5"><td>재귀 함수 (deepCopy)</td><td>커스터마이징 가능, 모든 데이터 타입 처리 가능</td><td>직접 구현해야 하며, 복잡한 객체에서 성능 고려 필요</td></tr><tr class="BasicTypeTable_td__r_Im5"><td>Lodash _.cloneDeep</td><td>신뢰성 높음, 다양한 데이터 타입 지원, 테스트 완료된 라이브러리</td><td>외부 라이브러리 의존성 추가 필요</td></tr></tbody></table><h4 class="heading_h4__ZTbA0" style="font-weight:NORMAL">📝 <!-- -->복잡한 객체(중첩 객체, 배열, Date, Map 포함)를 사용한 예제</h4><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">// 원본 객체 (복잡한 구조)
let original = {
  name: &quot;Bob&quot;,
  info: {
    age: 50,
    birthday: new Date(&quot;1975-01-01&quot;),
    address: { city: &quot;Seoul&quot;, country: &quot;Korea&quot; }
  },
  hobbies: [&quot;reading&quot;, { type: &quot;gaming&quot;, level: &quot;pro&quot; }],
  metadata: new Map([[&quot;id&quot;, 123], [&quot;active&quot;, true]])
};

// 깊은 복사
let deepCopy = structuredClone(original);

// 복사본 수정
deepCopy.name = &quot;David&quot;;
deepCopy.info.age = 60;
deepCopy.info.address.city = &quot;Busan&quot;;
deepCopy.hobbies[1].level = &quot;expert&quot;;
deepCopy.metadata.set(&quot;id&quot;, 456);

console.log(original);
// 출력: {
//   name: &quot;Bob&quot;,
//   info: { age: 50, birthday: [Date 1975-01-01], address: { city: &quot;Seoul&quot;, country: &quot;Korea&quot; } },
//   hobbies: [&quot;reading&quot;, { type: &quot;gaming&quot;, level: &quot;pro&quot; }],
//   metadata: Map { &quot;id&quot; =&gt; 123, &quot;active&quot; =&gt; true }
// }

console.log(deepCopy);
// 출력: {
//   name: &quot;David&quot;,
//   info: { age: 60, birthday: [Date 1975-01-01], address: { city: &quot;Busan&quot;, country: &quot;Korea&quot; } },
//   hobbies: [&quot;reading&quot;, { type: &quot;gaming&quot;, level: &quot;expert&quot; }],
//   metadata: Map { &quot;id&quot; =&gt; 456, &quot;active&quot; =&gt; true }
// }</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">중첩 객체(address), 배열 내 객체(hobbies[1]), Date, Map 등 다양한 데이터 타입이 포함된 복잡한 객체를 복사했습니다.</li><li class="liststyle_dot__SMzS4">structuredClone은 모든 수준에서 독립적인 복사본을 생성하여 원본이 수정되지 않음을 보여줍니다.</li></ul><div class="row"><nav class="postNavigation_post_navigation__Zbcpm"><a class="postNavigation_post_navgation_common__q8_Hl postNavigation_post_navigation_pre__SPHh_" aria-label="Older" href="/posts/64"><p class="postNavigation_post_navigation_text__3cjma">[TECH-QA] CSRF와 XSS</p></a><a class="postNavigation_post_navgation_common__q8_Hl postNavigation_post_navigation_next__yVEzg" aria-label="Newer" href="/posts/62"><p class="postNavigation_post_navigation_text__3cjma">[TECH-QA] 리액트 리렌더링</p></a></nav></div><div class="footer_footer_container__MsSvO"><footer class="footer_footer__AwYty"><p class="footer_copylight___J5l0">© 2024 <!-- -->베짱이가 되고싶은 개미。<!-- --> Some rights reserved.</p><p class="footer_theme__bwXbg">portfolio v1.0.0-alpha.3</p></footer></div></main><aside class="panel_panel_wrapper__bjPKT"><div class="panel_access__NiFhF"><section class="panel_access_lastmod__v6pgX"><h2 class="panel_panel_heading__n9W6w">Recently Updated</h2><ul class="panel_panel_recently__U0_Zp"><li class="panel_text_truncate__SFfHf"><a href="/posts/68">[TECH-QA] 애니메이션 분석 (Reflow와 Repaint 이론)</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/67">[TECH-QA] 리플로우(Reflow)와 리페인트(Repaint)는 브라우저의 렌더링 과정</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/66">[TECH-QA] 브라우저 렌더링 과정</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/65">[TECH-QA] 리액트에서 XSS 방어</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/64">[TECH-QA] CSRF와 XSS</a></li></ul></section><section class="panel_panel_tag_contain__h_Bwi"><h2 class="panel_panel_heading__n9W6w">Trending Tags</h2><div class="panel_panel_tag__eNz5c"><a class="panel_tag__3AiMO" href="/tags/브라우저">브라우저</a><a class="panel_tag__3AiMO" href="/tags/TECH-QA">TECH-QA</a><a class="panel_tag__3AiMO" href="/tags/Reflow">Reflow</a><a class="panel_tag__3AiMO" href="/tags/Repaint">Repaint</a><a class="panel_tag__3AiMO" href="/tags/리플로우">리플로우</a><a class="panel_tag__3AiMO" href="/tags/리페인트">리페인트</a><a class="panel_tag__3AiMO" href="/tags/웹성능 최적화">웹성능 최적화</a><a class="panel_tag__3AiMO" href="/tags/react">react</a><a class="panel_tag__3AiMO" href="/tags/XSS">XSS</a><a class="panel_tag__3AiMO" href="/tags/JavaScript">JavaScript</a><a class="panel_tag__3AiMO" href="/tags/CSRF">CSRF</a><a class="panel_tag__3AiMO" href="/tags/리렌더링">리렌더링</a><a class="panel_tag__3AiMO" href="/tags/Prototype">Prototype</a><a class="panel_tag__3AiMO" href="/tags/JWT">JWT</a><a class="panel_tag__3AiMO" href="/tags/React">React</a><a class="panel_tag__3AiMO" href="/tags/English">English</a><a class="panel_tag__3AiMO" href="/tags/midjourney">midjourney</a><a class="panel_tag__3AiMO" href="/tags/스키너의 심리상자 열기">스키너의 심리상자 열기</a><a class="panel_tag__3AiMO" href="/tags/독서">독서</a><a class="panel_tag__3AiMO" href="/tags/next">next</a><a class="panel_tag__3AiMO" href="/tags/지연로딩">지연로딩</a><a class="panel_tag__3AiMO" href="/tags/Lazy-loading">Lazy-loading</a><a class="panel_tag__3AiMO" href="/tags/CSS">CSS</a><a class="panel_tag__3AiMO" href="/tags/Tailwind">Tailwind</a><a class="panel_tag__3AiMO" href="/tags/mysql">mysql</a><a class="panel_tag__3AiMO" href="/tags/database">database</a><a class="panel_tag__3AiMO" href="/tags/TDD">TDD</a><a class="panel_tag__3AiMO" href="/tags/콜백함수">콜백함수</a><a class="panel_tag__3AiMO" href="/tags/browser">browser</a><a class="panel_tag__3AiMO" href="/tags/HTTP-Protocol">HTTP-Protocol</a><a class="panel_tag__3AiMO" href="/tags/git">git</a><a class="panel_tag__3AiMO" href="/tags/FrontEnd">FrontEnd</a><a class="panel_tag__3AiMO" href="/tags/Vue">Vue</a></div></section></div></aside></div></div></div><script src="/_next/static/chunks/webpack-ccbb0ed0b14a6538.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/80c9ce4c138da48c.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/css/0c496b0e03d530ba.css\",\"style\",{\"crossOrigin\":\"\"}]\n4:HL[\"/_next/static/css/19d2a4a42355ad75.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"5:I[7690,[],\"\"]\n7:I[5250,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"399\",\"static/chunks/399-caf055eb211349e2.js\",\"862\",\"static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-bbcf6e36dfc402e9.js\"],\"\"]\n8:I[8843,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"399\",\"static/chunks/399-caf055eb211349e2.js\",\"862\",\"static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-bbcf6e36dfc402e9.js\"],\"\"]\n9:I[2973,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"399\",\"stati"])</script><script>self.__next_f.push([1,"c/chunks/399-caf055eb211349e2.js\",\"862\",\"static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-bbcf6e36dfc402e9.js\"],\"\"]\nb:I[777,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"399\",\"static/chunks/399-caf055eb211349e2.js\",\"862\",\"static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-bbcf6e36dfc402e9.js\"],\"\"]\nc:I[5613,[],\"\"]\nf:I[1778,[],\"\"]\n13:I[3866,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"399\",\"static/chunks/399-caf055eb211349e2.js\",\"46\",\"static/chunk"])</script><script>self.__next_f.push([1,"s/46-f5c36f830a2ce4c4.js\",\"730\",\"static/chunks/730-f56ebe909f1c8bdb.js\",\"35\",\"static/chunks/35-86206131b00fc69c.js\",\"464\",\"static/chunks/app/(layoutCase)/layout-3f2d0dcd82d40488.js\"],\"\"]\n1a:I[8955,[],\"\"]\na:T43f,"])</script><script>self.__next_f.push([1,"// 원본 객체 (복잡한 구조)\nlet original = {\n  name: \"Bob\",\n  info: {\n    age: 50,\n    birthday: new Date(\"1975-01-01\"),\n    address: { city: \"Seoul\", country: \"Korea\" }\n  },\n  hobbies: [\"reading\", { type: \"gaming\", level: \"pro\" }],\n  metadata: new Map([[\"id\", 123], [\"active\", true]])\n};\n\n// 깊은 복사\nlet deepCopy = structuredClone(original);\n\n// 복사본 수정\ndeepCopy.name = \"David\";\ndeepCopy.info.age = 60;\ndeepCopy.info.address.city = \"Busan\";\ndeepCopy.hobbies[1].level = \"expert\";\ndeepCopy.metadata.set(\"id\", 456);\n\nconsole.log(original);\n// 출력: {\n//   name: \"Bob\",\n//   info: { age: 50, birthday: [Date 1975-01-01], address: { city: \"Seoul\", country: \"Korea\" } },\n//   hobbies: [\"reading\", { type: \"gaming\", level: \"pro\" }],\n//   metadata: Map { \"id\" =\u003e 123, \"active\" =\u003e true }\n// }\n\nconsole.log(deepCopy);\n// 출력: {\n//   name: \"David\",\n//   info: { age: 60, birthday: [Date 1975-01-01], address: { city: \"Busan\", country: \"Korea\" } },\n//   hobbies: [\"reading\", { type: \"gaming\", level: \"expert\" }],\n//   metadata: Map { \"id\" =\u003e 456, \"active\" =\u003e true }\n// }"])</script><script>self.__next_f.push([1,"d:[\"categoryname\",\"Javascript\",\"d\"]\ne:[\"postid\",\"63\",\"d\"]\n10:\"$L11\"\n14:[]\n15:{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"}\n16:{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"}\n17:{\"display\":\"inline-block\"}\n18:{\"fontSize\""])</script><script>self.__next_f.push([1,":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0}\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/80c9ce4c138da48c.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"b0WrnVhgyJRLEiiDRXPph\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/categories/Javascript/63\",\"initialTree\":[\"\",{\"children\":[\"(layoutCase)\",{\"children\":[\"categories\",{\"children\":[[\"categoryname\",\"Javascript\",\"d\"],{\"children\":[[\"postid\",\"63\",\"d\"],{\"children\":[\"__PAGE__?{\\\"categoryname\\\":\\\"Javascript\\\",\\\"postid\\\":\\\"63\\\"}\",{}]}]}]}],\"search\":[\"__DEFAULT__\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"(layoutCase)\",{\"children\":[\"categories\",{\"children\":[[\"categoryname\",\"Javascript\",\"d\"],{\"children\":[[\"postid\",\"63\",\"d\"],{\"children\":[\"__PAGE__\",{},[\"$L6\",[[[\"$\",\"article\",null,{\"className\":\"$undefined\",\"children\":[\"$\",\"header\",null,{\"children\":[\"$\",\"h1\",null,{\"className\":\"postUserInfo_h1__uhAqy\",\"children\":\"[TECH-QA] 원시값과 참조형\"}]}]}],[\"$\",\"div\",null,{\"className\":\"postUserInfo_post_meta__ABvuC\",\"children\":[[\"$\",\"span\",null,{\"children\":[\"Posted\",\" \",[\"$\",\"time\",null,{\"className\":\"postUserInfo_time__2exyR\",\"children\":[\"16 days\",\" \"]}]]}],[\"$\",\"span\",null,{\"className\":\"postUserInfo_update__f345P\",\"children\":[\"Updated\",\" \",[\"$\",\"time\",null,{\"className\":\"postUserInfo_time__2exyR\",\"children\":\"16 days\"}]]}]]}],[\"$\",\"div\",null,{\"children\":[\"$\",\"span\",null,{\"className\":\"postUserInfo_post_meta__ABvuC\",\"children\":[\"By\",\" \",[\"$\",\"em\",null,{\"children\":[\"$\",\"$L7\",null,{\"href\":\"https://nam-yeun-hwa.github.io/\",\"className\":\"postUserInfo_author__fVGYM\",\"children\":\"베짱이가 되고싶은 개미。\"}]}]]}]}]],[[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"자바스크립트에서 원시값(Primitive Values)과 참조형(Reference Types)의 동작 방식, 그리고 이들의 불변성(Immutability)과 가변성(Mutability)에 대해 설명 해 보겠습니다.\"}}],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"style\":{\"fontWeight\":\"NORMAL\"},\"children\":\"원시값 (Primitive Values)\"}],false,false],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e정의\u003c/b\u003e : 원시값은 더 이상 쪼갤 수 없는 기본 데이터 타입으로, 자바스크립트에서는 undefined, null, boolean, number, bigint, string, symbol이 이에 해당합니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e복제 방식\u003c/b\u003e : 다른 변수에 원시값을 복사할 때, 해당 값이 그대로 복사되어 새로운 변수에 저장됩니다. 이때 메모리 주소 개념은 관여하지 않고, \u003cb\u003e단순히 값만 복사\u003c/b\u003e됩니다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e불변성\u003c/b\u003e : 원시값은 불변값입니다. 값을 변경하려고 하면, 기존 메모리 공간의 값을 수정하는 대신 새로운 메모리 공간에 새로운 값을 저장하고, 변수가 참조하던 메모리 주소를 변경합니다.\"}}]]}],[\"$\",\"$L8\",null,{\"code\":\"let a = 10; // a는 숫자 10을 저장\\nlet b = a;  // b에 a의 값 10을 복사 (독립적인 메모리 공간)\\n\\nconsole.log(a); // 10\\nconsole.log(b); // 10\\n\\nb = 20; // b에 새로운 값 20을 할당 (새로운 메모리 공간 사용)\\nconsole.log(a); // 10 (a는 여전히 10을 참조)\\nconsole.log(b); // 20\",\"children\":\"$undefined\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"b = a를 실행하면, a의 값 10이 복사되어 b에 저장됩니다. 이때 \u003cb\u003ea와 b는 각각 독립적인 메모리 공간\u003c/b\u003e을 가리킵니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"b = 20으로 값을 변경하면, b는 새로운 메모리 공간에 20을 저장하고 그 주소를 참조합니다. a는 영향을 받지 않습니다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"원시값은 불변적이므로, a나 b의 값을 직접 수정하는 대신 새로운 값을 메모리에 할당합니다.\"}}]]}],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"style\":{\"fontWeight\":\"NORMAL\"},\"children\":\"참조형 (Reference Types)\"}],false,false],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e정의\u003c/b\u003e : 참조형은 \u003cspan class=\\\"point\\\"\u003e객체(Object)\u003c/span\u003e, \u003cspan class=\\\"point\\\"\u003e배열(Array)\u003c/span\u003e, \u003cspan class=\\\"point\\\"\u003e함수(Function)\u003c/span\u003e 등으로, 여러 값을 하나의 단위로 묶은 데이터 타입입니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e복제 방식\u003c/b\u003e : 참조형은 값이 담긴 \u003cb\u003e메모리 주소를 복제\u003c/b\u003e합니다. 즉, 변수는 실제 데이터(객체)가 저장된 메모리 주소를 가리키며, 복사 시 이 주소를 복사합니다. \u003cspan class=\\\"point\\\"\u003e따라서 복사된 변수는 원본 객체와 동일한 메모리 주소를 참조\u003c/span\u003e합니다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e가변성\u003c/b\u003e : 참조형은 가변값입니다. 객체가 저장된 메모리 공간은 수정 가능하며, 변수는 해당 객체를 직접 변경할 수 있습니다. 객체의 프로퍼티를 추가, 갱신, 삭제할 수 있습니다.\"}}]]}],[\"$\",\"$L8\",null,{\"code\":\"let obj1 = { name: \\\"Alice\\\", age: 25 }; // obj1은 객체의 메모리 주소를 참조\\nlet obj2 = obj1; // obj2는 obj1과 동일한 메모리 주소를 참조\\n\\nconsole.log(obj1); // { name: \\\"Alice\\\", age: 25 }\\nconsole.log(obj2); // { name: \\\"Alice\\\", age: 25 }\\n\\n// obj2를 통해 객체 수정\\nobj2.age = 30;\\nobj2.city = \\\"Seoul\\\"; // 동적으로 프로퍼티 추가\\n\\nconsole.log(obj1); // { name: \\\"Alice\\\", age: 30, city: \\\"Seoul\\\" }\\nconsole.log(obj2); // { name: \\\"Alice\\\", age: 30, city: \\\"Seoul\\\" }\\n\\n// 프로퍼티 삭제\\ndelete obj1.city;\\n\\nconsole.log(obj1); // { name: \\\"Alice\\\", age: 30 }\\nconsole.log(obj2); // { name: \\\"Alice\\\", age: 30 }\",\"children\":\"$undefined\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"obj2 = obj1은 obj1이 참조하는 객체의 메모리 주소를 obj2에 복사합니다. 따라서 obj1과 obj2는 동일한 객체를 가리킵니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"obj2.age = 30 또는 obj2.city = \\\"Seoul\\\"로 객체를 수정하면, 동일한 메모리 공간을 참조하는 obj1에도 변경 사항이 반영됩니다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"참조형은 가변적이므로, 객체의 프로퍼티를 동적으로 추가(city), 갱신(age), 삭제(delete obj1.city)할 수 있습니다.\"}}]]}],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"style\":{\"fontWeight\":\"NORMAL\"},\"children\":\"원시값 vs 참조형 비교\"}],false,false],[\"$\",\"$L9\",null,{\"header\":[{\"accessorKey\":\"feature\",\"header\":\"특징\"},{\"accessorKey\":\"primitive\",\"header\":\"원시값 (Primitive)\"},{\"accessorKey\":\"reference\",\"header\":\"참조형 (Reference)\"}],\"contents\":[{\"feature\":\"데이터 타입\",\"primitive\":\"number, string, boolean 등\",\"reference\":\"object, array, function 등\"},{\"feature\":\"복제 방식\",\"primitive\":\"값 자체 복사\",\"reference\":\"메모리 주소 복사\"},{\"feature\":\"변경 가능성\",\"primitive\":\"불변 (새로운 값으로 교체)\",\"reference\":\"가변 (객체 내부 수정 가능)\"},{\"feature\":\"메모리 동작\",\"primitive\":\"새로운 메모리 공간 생성\",\"reference\":\"동일한 메모리 공간 공유\"},{\"feature\":\"예시\",\"primitive\":\"let x = 5; x = 10;\",\"reference\":\"let obj = {a: 1}; obj.a = 2;\"}]}],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"style\":{\"fontWeight\":\"NORMAL\"},\"children\":\"참조형의 깊은 복사(Deep Copy)\"}],false,false],[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"참조형의 기본 복사는 얕은 복사(Shallow Copy)로, 동일한 객체를 참조하게 됩니다. 객체를 독립적으로 복사하려면 깊은 복사가 필요합니다.\"}}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"style\":{\"fontWeight\":\"NORMAL\"},\"children\":[\"📝 \",\"얕은 복사 vs 깊은 복사\"]}]],[\"$\",\"$L8\",null,{\"code\":\"// 얕은 복사\\nlet original = { name: \\\"Bob\\\", info: { age: 40 } };\\nlet shallowCopy = Object.assign({}, original);\\n\\nshallowCopy.name = \\\"Charlie\\\";\\nshallowCopy.info.age = 50;\\n\\nconsole.log(original); // { name: \\\"Bob\\\", info: { age: 50 } } (info는 여전히 공유됨)\\nconsole.log(shallowCopy); // { name: \\\"Charlie\\\", info: { age: 50 } }\\n\\n// 깊은 복사\\nlet deepCopy = JSON.parse(JSON.stringify(original));\\n\\ndeepCopy.name = \\\"David\\\";\\ndeepCopy.info.age = 60;\\n\\nconsole.log(original); // { name: \\\"Bob\\\", info: { age: 50 } } (변경되지 않음)\\nconsole.log(deepCopy); // { name: \\\"David\\\", info: { age: 60 } }\",\"children\":\"$undefined\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"얕은 복사(Object.assign)는 최상위 프로퍼티만 복사하고, 중첩 객체(info)는 여전히 원본과 공유됩니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"깊은 복사(JSON.parse(JSON.stringify()))는 객체 전체를 새로 생성하여 독립적인 복사본을 만듭니다.\"}}]]}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"style\":{\"fontWeight\":\"NORMAL\"},\"children\":[\"📝 \",\"원시값 활용\"]}]],[\"$\",\"$L8\",null,{\"code\":\"function updateScore(score) {\\n    score = score + 10; // 새로운 메모리 공간에 값을 저장\\n    return score;\\n}\\n\\nlet playerScore = 50;\\nconsole.log(updateScore(playerScore)); // 60\\nconsole.log(playerScore); // 50 (원본 값은 변경되지 않음)\",\"children\":\"$undefined\"}],[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"원시값은 함수 내부에서 수정해도 원본에 영향을 주지 않습니다.\"}}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"style\":{\"fontWeight\":\"NORMAL\"},\"children\":[\"📝 \",\"참조형 활용\"]}]],[\"$\",\"$L8\",null,{\"code\":\"function updateProfile(profile) {\\n    profile.age += 1; // 동일한 객체를 직접 수정\\n    profile.city = \\\"Busan\\\"; // 동적 프로퍼티 추가\\n}\\n\\nlet user = { name: \\\"Eve\\\", age: 28 };\\nupdateProfile(user);\\n\\nconsole.log(user); // { name: \\\"Eve\\\", age: 29, city: \\\"Busan\\\" }\",\"children\":\"$undefined\"}],[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"참조형은 함수 내부에서 수정하면 원본 객체가 변경됩니다. user 원본 객체가 { name: \\\"Eve\\\", age: 28 } 에서 { name: \\\"Eve\\\", age: 29, city: \\\"Busan\\\" } 으로 변경 됨\"}}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e원시값\u003c/b\u003e: 값 자체를 복사, 불변, 재할당 시 새로운 메모리 공간 사용.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e참조형\u003c/b\u003e: 메모리 주소를 복사, 가변, 객체 내부를 직접 수정 가능 (프로퍼티 추가/갱신/삭제).\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"원시값은 독립적이고 안전하지만 수정이 제한적이며, 참조형은 유연하지만 공유 메모리로 인해 주의가 필요합니다.\"}}],[\"$\",\"li\",\"3\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"깊은 복사를 통해 참조형의 독립적인 복사가 가능합니다.\"}}]]}],[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"자바스크립트에서 깊은 복사(Deep Copy)를 하는 방법은 여러 가지가 있습니다. 상황에 따라 간단한 객체부터 복잡한 객체까지 처리할 수 있습니다. 아래에 대표적인 방법과 예제를 정리해 보겠습니다.\"}}],[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"구조적 복제 (Structured Clone)\"}}],[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"structuredClone()은 브라우저 환경(Node.js 17+ 또는 최신 브라우저)에서 제공되는 깊은 복사를 위한 네이티브 메서드입니다. 이 방법은 JSON 방식보다 더 다양한 데이터 타입(예: Date, Map, Set 등)을 처리할 수 있습니다.\"}}],[\"$\",\"$L8\",null,{\"code\":\"// 원본 객체\\nlet original = {\\n  name: \\\"Bob\\\",\\n  info: { age: 50, date: new Date() },\\n  hobbies: [\\\"reading\\\", \\\"gaming\\\"]\\n};\\n\\n// 깊은 복사 (structuredClone 사용)\\nlet deepCopy = structuredClone(original);\\n\\n// 복사본 수정\\ndeepCopy.name = \\\"David\\\";\\ndeepCopy.info.age = 60;\\ndeepCopy.hobbies.push(\\\"coding\\\");\\n\\nconsole.log(original);\\n// 출력: { name: \\\"Bob\\\", info: { age: 50, date: [Date] }, hobbies: [\\\"reading\\\", \\\"gaming\\\"] }\\n\\nconsole.log(deepCopy);\\n// 출력: { name: \\\"David\\\", info: { age: 60, date: [Date] }, hobbies: [\\\"reading\\\", \\\"gaming\\\", \\\"coding\\\"] }\",\"children\":\"$undefined\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"structuredClone()은 객체와 그 하위 구조를 완전히 독립적으로 복사합니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"원본 객체의 info.age나 hobbies 배열이 수정되지 않음을 확인할 수 있습니다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"Date 객체도 별도의 인스턴스로 복사되며, JSON 방식과 달리 손실 없이 복사됩니다.\"}}]]}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"style\":{\"fontWeight\":\"NORMAL\"},\"children\":[\"📝 \",\"재귀 함수를 사용한 깊은 복사\"]}]],[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"직접 깊은 복사를 구현하는 방법으로, 객체와 배열을 재귀적으로 순회하며 복사합니다. 이 방법은 커스터마이징이 가능하고, 특정 데이터 타입을 추가로 처리할 수 있습니다.\"}}],[\"$\",\"$L8\",null,{\"code\":\"// 깊은 복사 함수\\nfunction deepCopy(obj) {\\n  // 원시값이거나 null인 경우 그대로 반환\\n  if (obj === null || typeof obj !== \\\"object\\\") {\\n    return obj;\\n  }\\n\\n  // 배열인 경우\\n  if (Array.isArray(obj)) {\\n    return obj.map(item =\u003e deepCopy(item));\\n  }\\n\\n  // 객체인 경우\\n  const copy = {};\\n  for (const key in obj) {\\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\\n      copy[key] = deepCopy(obj[key]);\\n    }\\n  }\\n  return copy;\\n}\",\"children\":\"$undefined\"}],[\"$\",\"$L8\",null,{\"code\":\"\\n// 원본 객체\\nlet original = {\\n  name: \\\"Bob\\\",\\n  info: { age: 50 },\\n  hobbies: [\\\"reading\\\", \\\"gaming\\\"]\\n};\\n\\n// 깊은 복사\\nlet deepCopy = deepCopy(original);\\n\\n// 복사본 수정\\ndeepCopy.name = \\\"David\\\";\\ndeepCopy.info.age = 60;\\ndeepCopy.hobbies.push(\\\"coding\\\");\\n\\nconsole.log(original);\\n// 출력: { name: \\\"Bob\\\", info: { age: 50 }, hobbies: [\\\"reading\\\", \\\"gaming\\\"] }\\n\\nconsole.log(deepCopy);\\n// 출력: { name: \\\"David\\\", info: { age: 60 }, hobbies: [\\\"reading\\\", \\\"gaming\\\", \\\"coding\\\"] }\",\"children\":\"$undefined\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"deepCopy 함수는 재귀적으로 객체의 모든 프로퍼티를 복사합니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"배열과 객체를 구분하여 처리하며, 원시값은 그대로 반환합니다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"이 방식은 JSON 방식의 한계를 극복하고, 함수나 undefined 같은 값도 커스터마이징하여 처리할 수 있습니다(필요 시 추가 로직 구현 가능).\"}}]]}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"style\":{\"fontWeight\":\"NORMAL\"},\"children\":[\"📝 \",\"Lodash 라이브러리의 _.cloneDeep\"]}]],[\"$\",\"div\",null,{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"실제 프로젝트에서는 Lodash 같은 라이브러리를 사용하는 경우가 많습니다. Lodash의 _.cloneDeep 메서드는 깊은 복사를 간편하게 수행하며, 다양한 데이터 타입을 안전하게 처리합니다.\"}}],[\"$\",\"$L8\",null,{\"code\":\"// Lodash를 사용하기 위해 필요 (HTML에서는 CDN 또는 모듈로 임포트)\\n// 예: \u003cscript src=\\\"https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js\\\"\u003e\u003c/script\u003e\\n\\n// 원본 객체\\nlet original = {\\n  name: \\\"Bob\\\",\\n  info: { age: 50 },\\n  hobbies: [\\\"reading\\\", \\\"gaming\\\"]\\n};\\n\\n// 깊은 복사 (Lodash 사용)\\nlet deepCopy = _.cloneDeep(original);\\n\\n// 복사본 수정\\ndeepCopy.name = \\\"David\\\";\\ndeepCopy.info.age = 60;\\ndeepCopy.hobbies.push(\\\"coding\\\");\\n\\nconsole.log(original);\\n// 출력: { name: \\\"Bob\\\", info: { age: 50 }, hobbies: [\\\"reading\\\", \\\"gaming\\\"] }\\n\\nconsole.log(deepCopy);\\n// 출력: { name: \\\"David\\\", info: { age: 60 }, hobbies: [\\\"reading\\\", \\\"gaming\\\", \\\"coding\\\"] }\",\"children\":\"$undefined\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"_.cloneDeep은 Lodash 라이브러리의 깊은 복사 메서드로, 복잡한 객체 구조를 안전하게 복사합니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"JSON 방식보다 다양한 데이터 타입(예: 함수, RegExp, Map)을 지원하며, 성능도 최적화되어 있습니다.\"}}],[\"$\",\"li\",\"2\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"실제 프로젝트에서 신뢰할 수 있는 방법 중 하나입니다.\"}}]]}],[\"$\",\"$L9\",null,{\"header\":[{\"accessorKey\":\"method\",\"header\":\"방법\"},{\"accessorKey\":\"advantage\",\"header\":\"장점\"},{\"accessorKey\":\"disadvantage\",\"header\":\"단점\"}],\"contents\":[{\"method\":\"JSON.parse(JSON.stringify())\",\"advantage\":\"간단하고 별도 라이브러리 불필요\",\"disadvantage\":\"undefined, 함수, Date 등 일부 데이터 타입 손실 가능\"},{\"method\":\"structuredClone()\",\"advantage\":\"네이티브 API, 다양한 데이터 타입 지원, 손실 없음\",\"disadvantage\":\"브라우저/Node.js 버전 의존성 (구형 환경에서 동작하지 않을 수 있음)\"},{\"method\":\"재귀 함수 (deepCopy)\",\"advantage\":\"커스터마이징 가능, 모든 데이터 타입 처리 가능\",\"disadvantage\":\"직접 구현해야 하며, 복잡한 객체에서 성능 고려 필요\"},{\"method\":\"Lodash _.cloneDeep\",\"advantage\":\"신뢰성 높음, 다양한 데이터 타입 지원, 테스트 완료된 라이브러리\",\"disadvantage\":\"외부 라이브러리 의존성 추가 필요\"}]}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"style\":{\"fontWeight\":\"NORMAL\"},\"children\":[\"📝 \",\"복잡한 객체(중첩 객체, 배열, Date, Map 포함)를 사용한 예제\"]}]],[\"$\",\"$L8\",null,{\"code\":\"$a\",\"children\":\"$undefined\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"중첩 객체(address), 배열 내 객체(hobbies[1]), Date, Map 등 다양한 데이터 타입이 포함된 복잡한 객체를 복사했습니다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"structuredClone은 모든 수준에서 독립적인 복사본을 생성하여 원본이 수정되지 않음을 보여줍니다.\"}}]]}]],[\"$\",\"$Lb\",null,{\"postid\":63,\"prePostTitle\":{\"id\":64,\"title\":\"[TECH-QA] CSRF와 XSS\",\"date\":\"2025-04-14 22:48:33\",\"folder\":\"Javascript\",\"tag\":[\"JavaScript\",\"TECH-QA\",\"XSS\",\"CSRF\"],\"preview\":\"CSRF 공격은 \u003cb\u003e사용자의 인증 정보를 악용\u003c/b\u003e하여 의도하지 않은 요청을 서버에 보내는 공격입니다. 이를 방어하기 위한 주요 방법은 다음과 같습니다.\",\"post\":[{\"type\":\"Heading\",\"headingType\":\"h2\",\"value\":\"CSRF 토큰 이란\"},{\"type\":\"normal\",\"value\":\"CSRF 토큰은 크로스 사이트 요청 위조(Cross-Site Request Forgery, CSRF) 공격을 방어하기 위해 사용되는 고유한 랜덤 문자열입니다. 서버에서 생성되어 사용자 세션과 연결되며, 클라이언트가 서버에 요청(예: 폼 제출, AJAX 호출)을 보낼 때 이 토큰을 함께 전송하여 요청의 유효성을 검증합니다.\"},{\"type\":\"Heading\",\"headingType\":\"h2\",\"value\":\"CSRF 토큰의 일반적인 흐름\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"서버에서 CSRF 토큰 생성\"},{\"type\":\"stringlist\",\"value\":\"사용자가 웹 애플리케이션에 접속하면, 서버는 해당 사용자 세션에 고유한 CSRF 토큰을 생성합니다.\\n이 토큰은 서버의 세션에 저장됩니다(예: 세션 ID와 연계된 서버 메모리, 데이터베이스, 또는 캐시).\\n서버 세션은 사용자마다 고유하며, 서버가 관리하는 상태 저장소입니다.\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"클라이언트로 CSRF 토큰 전달\"},{\"type\":\"normal\",\"value\":\"서버는 생성한 CSRF 토큰을 클라이언트(프론트엔드)로 전송합니다. 이는 보통 다음과 같은 방식으로 이루어집니다:\"},{\"type\":\"stringlist\",\"value\":\"HTML 폼의 숨겨진 필드(\u003cinput type=\\\"hidden\\\" name=\\\"_csrf\\\" value=\\\"토큰값\\\"\u003e)로 포함.\\nAJAX 요청을 위해 HTTP 헤더(예: X-CSRF-Token)로 전달.\\n쿠키로 전송(단, 쿠키 자체는 CSRF 방지에 직접 사용되지 않음).\"},{\"type\":\"normal\",\"value\":\"클라이언트는 이 토큰을 받아서 저장합니다. 이 저장은 주로 프론트엔드의 메모리(예: JavaScript 변수)나 HTML 폼에 일시적으로 유지되며, 프론트엔드의 세션 스토리지나 로컬 스토리지에 저장하는 경우는 드뭅니다(보안상 권장되지 않음).\"},{\"type\":\"Heading\",\"headingType\":\"h2\",\"value\":\"클라이언트가 요청 전송\"},{\"type\":\"stringlist\",\"value\":\"사용자가 폼을 제출하거나 AJAX 요청을 보낼 때, \u003cb\u003e클라이언트는 CSRF 토큰을 요청에 포함\u003c/b\u003e시킵니다.\\n예: \u003cb\u003ePOST 요청의 바디에 _csrf 필드로 포함\u003c/b\u003e되거나, \u003cb\u003e헤더에 X-CSRF-Token으로 추가\u003c/b\u003e됨.\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"서버에서 CSRF 토큰 검증\"},{\"type\":\"stringlist\",\"value\":\"서버는 클라이언트로부터 받은 CSRF 토큰을 서버 세션에 저장된 토큰과 비교합니다.\\n토큰이 일치하면 요청이 유효한 것으로 간주하고 처리합니다.\\n토큰이 일치하지 않거나 없으면 요청을 거부(예: 403 Forbidden 응답).\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"세션 유지 및 토큰 갱신\"},{\"type\":\"normal\",\"value\":\"요청이 성공적으로 처리된 후, 서버는 필요에 따라 새로운 CSRF 토큰을 생성하여 세션에 저장하고 클라이언트에 전달합니다.\\n이는 보안을 강화하기 위해 토큰을 일회성 또는 주기적으로 갱신하는 방식입니다.\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"예시\"},{\"type\":\"code\",\"value\":\"\u003cform method=\\\"POST\\\" action=\\\"/update-profile\\\"\u003e\\n  \u003cspan class=\\\"point\\\"\u003e\u003cinput type=\\\"hidden\\\" name=\\\"_csrf\\\" value=\\\"abc123xyz789\\\"\u003e\u003c/span\u003e\\n  \u003cinput type=\\\"text\\\" name=\\\"username\\\"\u003e\\n  \u003cbutton type=\\\"submit\\\"\u003e저장\u003c/button\u003e\\n\u003c/form\u003e\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"예제: JavaScript (Fetch API)\"},{\"type\":\"code\",\"value\":\"\u003c!DOCTYPE html\u003e\\n\u003chtml\u003e\\n\u003chead\u003e\\n    \u003ctitle\u003eCSRF AJAX Example\u003c/title\u003e\\n    \u003c!-- CSRF 토큰을 메타 태그로 포함 --\u003e\\n    \u003cmeta name=\\\"csrf-token\\\" content=\\\"3f9a8b2c-7e5d-4a1b-9c0f-1234567890ab\\\"\u003e\\n\u003c/head\u003e\\n\u003cbody\u003e\\n    \u003cbutton onclick=\\\"submitData()\\\"\u003eSubmit via AJAX\u003c/button\u003e\\n\\n    \u003cscript\u003e\\n        function submitData() {\\n            // 메타 태그에서 CSRF 토큰 가져오기\\n            const csrfToken = document.querySelector('meta[name=\\\"csrf-token\\\"]').getAttribute('content');\\n\\n            fetch('/submit', {\\n                method: 'POST',\\n                headers: {\\n                    'Content-Type': 'application/json',\\n                    'X-CSRF-Token': csrfToken // CSRF 토큰을 헤더에 추가\\n                },\\n                body: JSON.stringify({ username: 'john' })\\n            })\\n            .then(response =\u003e response.text())\\n            .then(data =\u003e console.log(data))\\n            .catch(error =\u003e console.error('Error:', error));\\n        }\\n    \u003c/script\u003e\\n\u003c/body\u003e\\n\u003c/html\u003e\"},{\"type\":\"normal\",\"value\":\"\u003cmeta name=\\\"csrf-token\\\" content=\\\"...\\\"\u003e는 서버에서 생성한 CSRF 토큰을 프론트엔드에 전달하는 일반적인 방법입니다.\\nJavaScript에서 fetch를 사용하여 POST 요청을 보낼 때, X-CSRF-Token 헤더에 토큰을 추가합니다.\"},{\"type\":\"code\",\"value\":\"POST /submit HTTP/1.1\\nHost: example.com\\nContent-Type: application/json\\nX-CSRF-Token: 3f9a8b2c-7e5d-4a1b-9c0f-1234567890ab\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"HTTP 요청 헤더\"},{\"type\":\"code\",\"value\":\"POST /submit HTTP/1.1\\nHost: example.com\\nContent-Type: application/json\\nX-CSRF-Token: 3f9a8b2c-7e5d-4a1b-9c0f-1234567890ab\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"요청 바디\"},{\"type\":\"code\",\"value\":\"{\\\"username\\\":\\\"john\\\"}\"},{\"type\":\"normal\",\"value\":\"서버는 _csrf 값이 세션의 토큰과 일치하는지 확인 후 요청을 처리합니다.\"},{\"type\":\"Heading\",\"headingType\":\"h2\",\"value\":\"CSRF 토큰의 중요성\"},{\"type\":\"stringlist\",\"value\":\"\u003cb\u003e공격 방어\u003c/b\u003e: 공격자가 사용자의 인증 쿠키를 악용해 위조 요청을 보내더라도, CSRF 토큰이 없으면 서버가 요청을 거부합니다.\\n\u003cb\u003e간단한 구현\u003c/b\u003e: 대부분의 웹 프레임워크(예: Spring, Django, Laravel)는 CSRF 토큰 생성 및 검증 기능을 기본 제공합니다.\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"추가 고려사항\"},{\"type\":\"stringlist\",\"value\":\"\u003cb\u003e보안\u003c/b\u003e: 토큰이 노출되지 않도록 HTTPS를 사용하고, GET 요청에 포함시키지 않습니다.\\n\u003cb\u003e사용성\u003c/b\u003e: AJAX 요청에서는 헤더로 토큰을 전송하는 방식이 일반적입니다.\\n\u003cb\u003eSameSite 쿠키와 조합\u003c/b\u003e: CSRF 토큰 외에 SameSite 속성을 쿠키에 설정하면 추가적인 보호를 제공합니다.\"},{\"type\":\"Heading\",\"headingType\":\"h2\",\"value\":\"쿠키 속성 설정(SameSite)\"},{\"type\":\"normal\",\"value\":\"쿠키에 SameSite 속성을 설정하여 동일 출처(Same-Origin) 또는 제한된 조건에서만 쿠키가 전송되도록 합니다.\"},{\"type\":\"stringlist\",\"value\":\"\u003cb\u003eStrict\u003c/b\u003e: 동일 도메인에서만 쿠키 전송 가능.\\n\u003cb\u003eLax\u003c/b\u003e: 동일 도메인 외의 GET 요청(예: 링크 이동)에서만 쿠키 전송 가능.\\n\u003cb\u003eNone\u003c/b\u003e: 모든 요청에서 쿠키 전송(단, HTTPS와 Secure 속성 필수)\"},{\"type\":\"normal\",\"value\":\"\u003cspan class=\\\"point\\\"\u003eSameSite=Lax\u003c/span\u003e 는 대부분의 CSRF 방어에 적합하며, 사용자 경험을 해치지 않으면서 보안을 강화합니다. \u003cspan class=\\\"point\\\"\u003eSameSite=Strict\u003c/span\u003e는 더 강력하지만, 외부 링크를 통한 접근 시 쿠키가 전송되지 않아 기능적 제약이 있을 수 있습니다.\"},{\"type\":\"stringlist\",\"value\":\"\u003cb\u003eHTTP 메서드 제한\u003c/b\u003e: 상태 변경 요청(예: 돈 이체, 계정 수정)은 POST, PUT, DELETE와 같은 메서드만 허용하고, GET 요청은 상태 변경을 유발하지 않도록 설계합니다.\\n\\t\\t\\t\u003cb\u003eReferer/Origin 헤더 검증\u003c/b\u003e: 요청의 출처를 확인하여 신뢰할 수 있는 도메인에서만 요청을 허용합니다. 단, Referer 헤더는 브라우저 설정에 따라 누락될 수 있으므로 보조적 수단으로 사용합니다.\"},{\"type\":\"Heading\",\"headingType\":\"h2\",\"value\":\"XSS 공격 방어\"},{\"type\":\"normal\",\"value\":\"XSS 공격은 악성 스크립트를 웹 페이지에 삽입하여 사용자의 브라우저에서 실행되도록 만드는 공격입니다. 이를 방어하기 위한 방법은 다음과 같습니다.\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"입력 값 유효성 검증 및 특수문자 이스케이프\"},{\"type\":\"normal\",\"value\":\"사용자로부터 입력받은 데이터(예: 텍스트, URL, JSON 등)의 유효성을 검증하고, HTML, JavaScript, SQL 등에서 실행 가능한 특수문자(\u003cspan class=\\\"point\\\"\u003e \u003c, \u003e, \\\", ', \u0026\u003c/span\u003e 등)를 이스케이프 처리합니다.\"},{\"type\":\"GuideMessage\",\"value\":\"\u003cb\u003e이스케이프 처리란?\u003c/b\u003e\u003c/br\u003e\\n\\t\\t\\t\\t사용자가 \u003cscript\u003ealert('악성 코드')\u003c/script\u003e를 입력했다고 가정한다면\u003c/br\u003e\\n\\t\\t\\t\\t- \u003cb\u003e이스케이프 처리 전\u003c/b\u003e: 브라우저가 이를 JavaScript로 실행하여 경고창이 표시됨(XSS 공격 성공).\u003c/br\u003e\\n\\t\\t\\t\\t- \u003cb\u003e이스케이프 처리 후\u003c/b\u003e: [ \u003c → \u0026amp;lt; ] [ \u003e → \u0026ampgt; ] 로 변환되어 \u003cscript\u003e가 텍스트로 표시됨(악성 코드 실행 방지).\"},{\"type\":\"normal\",\"value\":\"사용자가 입력한 데이터(예: 텍스트 필드, 쿼리 파라미터)를 서버 또는 클라이언트에서 받으면 입력 데이터에 포함된 특수 문자를 안전한 문자(예: \u003c)로 변환하여 변환된 데이터를 HTML, JavaScript 등의 문맥에서 출력하여 브라우저가 이를 코드가 아닌 텍스트로 처리하도록 함.\"},{\"type\":\"code\",\"value\":\"\u003c!-- 입력: \u003cscript\u003ealert('XSS')\u003c/script\u003e --\u003e \\n\u003c!-- 이스케이프 처리 후 출력 --\u003e\\n\u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;)\u0026lt;script\u0026gt;\"},{\"type\":\"stringlist\",\"value\":\"브라우저는 위를 \u003cscript\u003ealert('XSS')\u003c/script\u003e로 표시하며, 실행하지 않음.\"},{\"type\":\"normal\",\"value\":\"클라이언트와 서버 모두에서 입력 검증을 수행해야 하며 서버에서는 데이터베이스 저장 전, 클라이언트에서는 사용자 경험을 위해 검증합니다. 예를 들어,  \u003cscript\u003e는 \u003cspan class=\\\"point\\\"\u003e\u0026amplt;script\u0026ampgt;\u003c/span\u003e로 변환하여 렌더링 시 실행되지 않도록 합니다. 라이브러리(예: DOMPurify, OWASP Java Encoder)를 사용하면 이스케이프 처리가 더 안전합니다.\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"CSP(Content Security Policy) 설정\"},{\"type\":\"normal\",\"value\":\"서버에서 HTTP 응답 헤더에 CSP를 설정하여 허용된 스크립트, 스타일, 이미지 등의 출처를 제한합니다.\"},{\"type\":\"code\",\"value\":\"Content-Security-Policy: script-src 'self' https://trusted.cdn.com;\"},{\"type\":\"normal\",\"value\":\"CSP는 인라인 스크립트(\u003cscript\u003ealert('xss')\u003c/script\u003e)나 외부 출처의 악성 스크립트 실행을 차단합니다. 'strict-dynamic', 'nonce', 'hash'와 같은 옵션을 사용하면 더 세밀한 제어가 가능합니다. 그러나 CSP 설정은 신중히 설계해야 하며, 기존 코드와의 호환성 문제를 테스트해야 합니다.\"},{\"type\":\"normal\",\"value\":\"\"},{\"type\":\"stringlist\",\"value\":\"\u003cb\u003e출력 이스케이프\u003c/b\u003e: 데이터를 렌더링할 때 문맥(HTML, 속성, JavaScript, CSS, URL 등)에 맞게 이스케이프 처리합니다. 예: HTML 속성에는 더블쿼테이션(\\\")를 \u0026ampquot;로 변환.\\n\\t\\t\\t\u003cb\u003e안전한 API 사용\u003c/b\u003e: innerHTML 대신 textContent나 setAttribute를 사용해 스크립트 실행을 방지합니다.\\n\\t\\t\\t\u003cb\u003e쿠키 보호\u003c/b\u003e: HttpOnly 속성을 쿠키에 설정하여 JavaScript에서 쿠키에 접근하지 못하도록 제한합니다.\\n\\t\\t\\t\u003cb\u003e프레임워크 보안\u003c/b\u003e: React, Angular 등 현대 프레임워크는 기본적으로 XSS 방어를 제공하지만, dangerouslySetInnerHTML 같은 기능을 사용할 때는 주의가 필요합니다.\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"HTTPS를 통한 통신 보안\"},{\"type\":\"normal\",\"value\":\"HTTP는 데이터가 평문으로 전송되어 도청 및 조작에 취약합니다. HTTPS는 \u003cb\u003eSSL/TLS\u003c/b\u003e를 통해 통신을 암호화하여 보안을 강화합니다.\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"HTTPS 적용\"},{\"type\":\"normal\",\"value\":\"HSTS는 웹 브라우저에게 해당 사이트는 항상 HTTPS로만 접속해야 한다고 지시하는 보안 기능입니다. 한 번 브라우저가 이 헤더를 받으면, 이후엔 자동으로 HTTP 요청을 HTTPS로 업그레이드합니다.\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"HSTS 헤더 예시\"},{\"type\":\"normal\",\"value\":\"서버에서 다음과 같은 헤더를 응답에 추가합니다.\"},{\"type\":\"code\",\"value\":\"Strict-Transport-Security: max-age=31536000; includeSubDomains\"},{\"type\":\"normal\",\"value\":\"HTTPS는 데이터 무결성과 기밀성을 보장하며, CSRF와 XSS 공격에서 쿠키나 토큰이 탈취되는 것을 방지합니다. HSTS는 중간자 공격(MITM)을 줄이는 데 효과적입니다. 또한, 최신 TLS 버전(예: TLS 1.3)과 강력한 암호화 알고리즘을 사용하는 것이 중요합니다.\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"추가 보안 고려사항\"},{\"type\":\"stringlist\",\"value\":\"\u003cb\u003e인증서 관리\u003c/b\u003e: 신뢰할 수 있는 인증 기관(CA)에서 발급받은 SSL/TLS 인증서를 사용하고, 만료 전에 갱신합니다.\\n\\t\\t\\t\u003cb\u003e혼합 콘텐츠 방지\u003c/b\u003e: HTTPS 페이지에서 HTTP 리소스(이미지, 스크립트 등)를 로드하지 않도록 주의합니다. 브라우저는 혼합 콘텐츠를 차단하거나 경고를 표시할 수 있습니다.\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"종합적인 보안 전략\"},{\"type\":\"normal\",\"value\":\"CSRF와 XSS 방어는 단일 기법에 의존하지 않고, 여러 방어 계층을 조합하여 적용하는 심층 방어(Defense-in-Depth) 전략이 필요합니다.\"},{\"type\":\"stringlist\",\"value\":\"\u003cb\u003e개발 단계\u003c/b\u003e: 코드 리뷰, 보안 라이브러리 사용, OWASP 가이드라인 준수.\\n\\t\\t\\t\u003cb\u003e배포 단계\u003c/b\u003e: 보안 헤더 설정(CSP, HSTS, X-Frame-Options 등), 취약점 스캔.\\n\\t\\t\\t\u003cb\u003e운영 단계\u003c/b\u003e: 로그 모니터링, WAF(Web Application Firewall) 도입, 정기적인 보안 패치.\"}]},\"nextPostTile\":{\"id\":62,\"title\":\"[TECH-QA] 리액트 리렌더링\",\"date\":\"2025-04-12 15:34:33\",\"folder\":\"Javascript\",\"tag\":[\"JavaScript\",\"TECH-QA\",\"react\",\"리렌더링\"],\"preview\":\"리액트에서 리렌더링(re-rendering)은 컴포넌트가 다시 그려지는 과정입니다. 즉, 어떤 변화가 발생했을 때, 리액트가 해당 컴포넌트(혹은 그 자식들 포함)를 다시 실행해서 UI를 업데이트하는 걸 말합니다.\",\"post\":[{\"type\":\"normal\",\"value\":\"리액트에서 리렌더링(re-rendering)은 컴포넌트가 다시 그려지는 과정입니다. 즉, 어떤 변화가 발생했을 때, 리액트가 해당 컴포넌트(혹은 그 자식들 포함)를 다시 실행해서 UI를 업데이트하는 걸 말합니다. 리렌더링이 너무 많이 발생하면 성능에 부정적인 영향을 줄 수 있습니다. 특히 대규모 애플리케이션이나 자주 렌더링되는 컴포넌트에서는 주의가 필요합니다. 그래서 이번 글에서는 리액트 리렌더링에 대해 이야기 해보려고 합니다.\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"언제 리렌더링이 발생할까요?\"},{\"type\":\"stringlist\",\"value\":\"state가 변경될 때\\n\\t\\t\\t\\tprops가 변경될 때\\n\\t\\t\\t\\tcontext 값이 변경될 때\\n\\t\\t\\t\\t부모 컴포넌트가 리렌더링되면 자식도 리렌더링\"},{\"type\":\"normal\",\"value\":\"위와 같은 경우에 리액트 컴포넌트에서는 리렌더링이 발생합니다. 한 컴포넌트에 여러가지 스테이트들이 존재하고 UI에서는 여러 인터렉션(버튼 클릭, 입력, 체크박스 등)이 발생하며 스테이드 값들이 변경될때 컴포넌트는 리렌더링 되고 있다고 생각하면 됩니다.\"},{\"type\":\"GuideMessage\",\"value\":\"리렌더링된다고 해서 DOM 전체를 다시 그리는 건 아닙니다. 리액트는 \\\"Virtual DOM\\\"을 이용해서 변경된 부분만 최소한으로 UI를 업데이트 하며 컴포넌트에 있는 함수들은 새로 생성됩니다. 예를 들면 아래 코드를 보시면 이해 하실 수 있습니다.\"},{\"type\":\"code\",\"value\":\"const MyComponent = () =\u003e {\\n  const [count, setCount] = useState(0);\\n\\n  const handleClick = () =\u003e setCount(count + 1);\\n\\n  return \u003cbutton onClick={handleClick}\u003e{count}\u003c/button\u003e;\\n};\\n\"},{\"type\":\"normal\",\"value\":\"위 함수가 리렌더링이 일어나면 \"},{\"type\":\"stringlist\",\"value\":\"버튼 클릭 → setCount 호출 → count 값 변경\\n\\n변경된 state로 인해 MyComponent() 함수 전체가 다시 실행됨\\n\\ncount, handleClick, JSX 등이 다시 계산됨\\n\\nVirtual DOM에서 변화 비교 후, 실제 DOM은 필요한 부분만 업데이트됨\"},{\"type\":\"normal\",\"value\":\"위와 같은 일이 이루어 집니다. 여기에서 UI는 최소한으로 부분 업데이트 되며 handleClick 함수는 새로 생성됩니다. 새로 생성된다 함은 함수 객체 자체가 메모리에 새로 만들어지는 것입니다. \"},{\"type\":\"code\",\"value\":\"const handleClick = () =\u003e setCount(count + 1);\"},{\"type\":\"normal\",\"value\":\"위 코드는 함수 표현식(= 함수 리터럴)이기 때문에 이 줄이 실행될 때마다 새로운 함수 객체가 메모리에 만들어집니다. \u003c/br\u003e 코드로 확인해 보겠습니다.\"},{\"type\":\"code\",\"value\":\"const MyComponent = () =\u003e {\\n  const [count, setCount] = useState(0);\\n\\n  const handleClick = () =\u003e setCount(count + 1);\\n\\n  useEffect(() =\u003e {\\n    console.log(\\\"handleClick 함수가 새로 만들어졌어요!\\\");\\n  }, [handleClick]);\\n\\n  return \u003cbutton onClick={handleClick}\u003e{count}\u003c/button\u003e;\\n};\\n\"},{\"type\":\"stringlist\",\"value\":\"버튼을 누르면 setCount로 상태가 바뀌고,\\n\\n컴포넌트가 다시 렌더링됨,\\n\\n그러면 handleClick도 새로 생성됨,\\n\\n따라서 useEffect가 실행됨 → 콘솔에 로그 출력!\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"그럼 왜 리렌더링 때마다 새로 생성될까요?\"},{\"type\":\"normal\",\"value\":\"리액트 함수형 컴포넌트는 결국 함수이자, 매번 실행되는 실행 단위입니다. 여기서 컴포넌트가 호출되면, 그 내부의 handleClick = () =\u003e { ... }도 다시 실행되는 것입니다.\\n그래서 이 때마다 새로운 함수 객체가 생성되는 것이라고 볼 수 있습니다. 그럼 조금 더 들어가서 리액트 컴포넌트가 리렌더링이 덜 되도록 하는 방법에 대해 생각해 보도록 하겠습니다.\"},{\"type\":\"normal\",\"value\":\"한 컴포넌트에서 여러 기능을 가지고 여러 스테이트들을 관리하던 것을 훅에서 스테이트 값이나 상태 값을 관리하고, 컴포넌트는 순수하게 인터렉션만 처리하도록 설계된 경우, 해당 컴포넌트는 스테이트 변경에 따른 리렌더링을 피할 수 있습니다. 하지만 이게 보장되려면 몇 가지 조건과 주의점이 필요합니다. 아래에서 이 상황을 자세히 분석하고, 왜 리렌더링이 일어나지 않을 수 있는지, 그리고 어떤 경우에 주의해야 하는지 설명하겠습니다. 코드를 통해 살펴 보겠습니다.\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"[커스텀 훅] usePdfController.js\"},{\"type\":\"code\",\"value\":\"const usePdfController = () =\u003e {\\n  const [file, setFile] = useState(null);\\n  const pdfInputRef = useRef(null);\\n\\n  const handlePDFChange = (event) =\u003e {\\n    const selectedFile = event.target.files[0];\\n    setFile(selectedFile);\\n  };\\n\\n  return { file, pdfInputRef, handlePDFChange };\\n};\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"[자식 컴포넌트] FileUpload.jsx (인터랙션만 처리)\"},{\"type\":\"code\",\"value\":\"const FileUpload = ({ onChange, InputRef, children }) =\u003e {\\n  return (\\n    \u003clabel\u003e\\n      {children}\\n      \u003cinput type=\\\"file\\\" ref={InputRef} onChange={onChange} style={{ display: 'none' }} /\u003e\\n    \u003c/label\u003e\\n  );\\n};\\n\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"[부모 컴포넌트] StampController.jsx\"},{\"type\":\"code\",\"value\":\"const StampController = () =\u003e {\\n  const { file, pdfInputRef, handlePDFChange } = usePdfController();\\n\\n  return (\\n    \u003cdiv\u003e\\n      \u003cFileUpload InputRef={pdfInputRef} onChange={handlePDFChange}\u003e\\n        PDF 업로드\\n      \u003c/FileUpload\u003e\\n      {file?.name \u0026\u0026 \u003cdiv\u003e{file.name}\u003c/div\u003e}\\n    \u003c/div\u003e\\n  );\\n};\"},{\"type\":\"stringlist\",\"value\":\"\u003cb\u003e스테이트 관리\u003c/b\u003e: 스테이트는 커스텀 훅(예: usePdfController) 또는 스토어(예: useCanvasStore)에서 관리.\\n\u003cb\u003e인터랙션 컴포넌트\u003c/b\u003e: 특정 컴포넌트(예: FileUpload, Button)는 사용자 인터랙션(클릭, 파일 선택 등)만 처리하고, 스테이트나 상태 값을 직접 소유하지 않음.\\n\u003cb\u003e인터랙션 처리\u003c/b\u003e: 인터랙션은 훅이나 스토어에서 제공하는 함수(예: handlePDFChange, handleDownload)를 호출.\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"자식 컴포넌트 \u003cFileUpload/\u003e 리렌더링\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"스테이트 소유 여부\"},{\"type\":\"stringlist\",\"value\":\"자식 컴포넌트 FileUpload은 자체 스테이트를 가지지 않습니다. 따라서 FileUpload 내부에서 useState나 useReducer로 인해 리렌더링이 발생할 가능성이 없습니다.\\n스테이트는 usePdfController에서 관리되며, file 변경은 StampController 같은 부모 컴포넌트에 영향을 줍니다.\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"Props 안정성\"},{\"type\":\"stringlist\",\"value\":\"자식 컴포넌트 FileUpload가 받는 props(예: onChange, InputRef)가 변경되지 않는 한, React는 이 컴포넌트를 리렌더링하지 않습니다.\\nFileUpload가 props로 받는 handlePDFChange가 메모이제이션되지 않으면, StampController가 리렌더링될 때마다 handlePDFChange는 \u003cb\u003e새로운 함수 참조가 생성\u003c/b\u003e되어 FileUpload의 props가 변경된 것으로 간주되어 자식 컴포넌트 FileUpload는 리렌더링 됩니다. 이를 피하기 위해 \u003cu\u003e커스텀 훅 usePdfController에서 handlePDFChange를 메모이제이션(useCallback)하여, 함수가 매 렌더링마다 동일한 참조를 유지\u003c/u\u003e하도록 합니다.\\n\"},{\"type\":\"code\",\"value\":\"// usePdfController.js\\n// ★★★커스텀 훅 내부에서 useCallback 사용\\n  const handlePDFChange = useCallback((event) =\u003e {\\n  const selectedFile = event.target.files[0];\\n  setFile(selectedFile);\\n}, []);\"},{\"type\":\"stringlist\",\"value\":\"InputRef는 useRef로 생성된 참조로, 렌더링 간에 변경되지 않습니다.\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"부모 컴포넌트의 리렌더링 영향 \"},{\"type\":\"stringlist\",\"value\":\"부모 컴포넌트 StampController가 자주 리렌더링되면, 자식 컴포넌트 FileUpload도 기본적으로 리렌더링됩니다. \\n\\t\\t\\t\\tReact는 부모가 리렌더링되면 자식도 렌더링 시도\\n\\t\\t\\t\\t이를 피하기 위해서는 자식 컴포넌트인 FileUpload을 React.memo로 감싸줍니다.\"},{\"type\":\"code\",\"value\":\"const FileUpload = ({ onChange, InputRef, children }) =\u003e {\\n  console.log('FileUpload rendered');\\n  return (\\n    \u003clabel\u003e\\n      {children}\\n      \u003cinput type=\\\"file\\\" ref={InputRef} onChange={onChange} style={{ display: 'none' }} /\u003e\\n    \u003c/label\u003e\\n  );\\n};\\nexport default React.memo(FileUpload);\"},{\"type\":\"stringlist\",\"value\":\"이렇게 하면 onChange, InputRef, children이 변경되지 않는 한 FileUpload은 리렌더링되지 않습니다. 부모컴포넌트 StampController가 file 상태 변경으로 리렌더링되더라도, 자식 컴포넌트 FileUpload가 React.memo로 감싸져 있다면 props가 변경되지 않는 한 리렌더링을 건너뜁니다\"},{\"type\":\"stringlist\",\"value\":\"React.memo는 props의 얕은 비교(shallow comparison)를 수행해 props가 변경되지 않는 한 컴포넌트의 리렌더링을 방지합니다.\"},{\"type\":\"stringlist\",\"value\":\"인터랙션의 경우 (예: 파일 선택)은 handlePDFChange를 호출하고, 이는 usePdfController의 file 상태를 변경합니다. 하지만 이 변경은 StampController의 렌더링에만 직접 영향을 주고, FileUpload은 스테이트를 소유하지 않으므로 간접적인 리렌더링을 피할 수 있습니다.\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"\u003cFileUpload/\u003e Children Props 변경\"},{\"type\":\"normal\",\"value\":\"FileUpload의 children(예: \\\"PDF 업로드\\\")이 동적으로 생성되거나 매번 새로운 참조를 가지면, React.memo를 사용하더라도 리렌더링될 수 있습니다. children이 정적이거나 메모이제이션된 값을 사용하도록 합니다.\"},{\"type\":\"code\",\"value\":\"\u003cFileUpload InputRef={pdfInputRef} onChange={handlePDFChange}\u003e\\n  PDF 업로드\\n\u003c/FileUpload\u003e\"},{\"type\":\"Heading\",\"headingType\":\"h4\",\"value\":\"\u003cFileUpload/\u003e 같은 자식 컴포넌트가 스토어 상태를 직접 구독하지 않도록 하여 리렌더링을 방지 한다.\"},{\"type\":\"code\",\"value\":\"// 잘못된 예\\nconst FileUpload = ({ onChange, InputRef, children }) =\u003e {\\n  const { file } = useCanvasStore(); // 스토어 구독\\n  return \u003cinput type=\\\"file\\\" ref={InputRef} onChange={onChange} /\u003e;\\n};\\n\\n// 올바른 예\\nconst FileUpload = ({ onChange, InputRef, children }) =\u003e {\\n  return \u003cinput type=\\\"file\\\" ref={InputRef} onChange={onChange} /\u003e;\\n};\"},{\"type\":\"Heading\",\"headingType\":\"h3\",\"value\":\"리렌더링이 되지 않는 조건을 지켜는 방법\"},{\"type\":\"stringlist\",\"value\":\"컴포넌트가 자체 스테이트를 소유하지 않고 커스텀 훅으로 관리.\\n\\t\\t\\t\\t컴포넌트가 스토어나 Context를 직접 구독하지 않고 커스텀 훅으로 관리하도록 함.\\n전달된 props(함수, 참조, 값)가 메모이제이션되어 전달 받도록 하기.\\n컴포넌트가 React.memo로 감싸져 있어 부모 리렌더링의 영향을 받지 않음.\"}]},\"segment\":\"posts\"}],[\"$\",\"div\",null,{\"className\":\"footer_footer_container__MsSvO\",\"children\":[\"$\",\"footer\",null,{\"className\":\"footer_footer__AwYty\",\"children\":[[\"$\",\"p\",null,{\"className\":\"footer_copylight___J5l0\",\"children\":[\"© 2024 \",\"베짱이가 되고싶은 개미。\",\" Some rights reserved.\"]}],[\"$\",\"p\",null,{\"className\":\"footer_theme__bwXbg\",\"children\":\"portfolio v1.0.0-alpha.3\"}]]}]}]],null]]},[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"categories\",\"children\",\"$d\",\"children\",\"$e\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/19d2a4a42355ad75.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]]},[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"categories\",\"children\",\"$d\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"categories\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]],\"search\":[\"__DEFAULT__\",{},[\"$10\",\"$L12\",null]]},[null,[\"$\",\"$L13\",null,{\"children\":[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}],\"search\":[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"search\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"search\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$14\",\"styles\":null}],\"params\":{}}],null]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"className\":\"\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css\",\"as\":\"style\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.googleapis.com\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.gstatic.com\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR\u0026display=swap\",\"as\":\"style\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"$Lc\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":\"$15\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":\"$16\",\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":\"$17\",\"children\":[\"$\",\"h2\",null,{\"style\":\"$18\",\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0c496b0e03d530ba.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]}]]}],null]],\"initialHead\":[false,\"$L19\"],\"globalErrorComponent\":\"$1a\"}]]\n"])</script><script>self.__next_f.push([1,"12:E{\"digest\":\"NEXT_NOT_FOUND\"}\n"])</script><script>self.__next_f.push([1,"19:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"be come 💡\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"App for an Ant Who Wants to Become a Bejjangyi\"}]]\n6:null\n11:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>