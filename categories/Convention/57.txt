2:I[5250,["250","static/chunks/250-8b90be581650ff9d.js","399","static/chunks/399-caf055eb211349e2.js","862","static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-52cda30c3ceb6c8a.js"],""]
3:I[8843,["250","static/chunks/250-8b90be581650ff9d.js","399","static/chunks/399-caf055eb211349e2.js","862","static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-52cda30c3ceb6c8a.js"],""]
4:I[2973,["250","static/chunks/250-8b90be581650ff9d.js","399","static/chunks/399-caf055eb211349e2.js","862","static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-52cda30c3ceb6c8a.js"],""]
5:I[777,["250","static/chunks/250-8b90be581650ff9d.js","399","static/chunks/399-caf055eb211349e2.js","862","static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-52cda30c3ceb6c8a.js"],""]
7:I[5613,[],""]
a:I[1778,[],""]
e:I[3866,["250","static/chunks/250-8b90be581650ff9d.js","399","static/chunks/399-caf055eb211349e2.js","46","static/chunks/46-f5c36f830a2ce4c4.js","730","static/chunks/730-f56ebe909f1c8bdb.js","35","static/chunks/35-917f6d62db20f146.js","464","static/chunks/app/(layoutCase)/layout-b678e44923655761.js"],""]
6:T8e1,<b>타입스크립트의 가장 큰 특징은 정적 타입 시스템을 도입했다는 점입니다.</b></br> 이는 변수, 함수, 객체 등의 타입을 코드 작성 단계에서 명시적으로 정의해 줍니다. 이렇게 정의된 타입은 <u>컴파일 단계에서 오류를 포착</u>할 수 있도록 도와주며, <u>런타임에서 발생할 수 있는 잠재적인 버그를 사전에 줄이는 데 큰 장점이 있습니다.</u></br></br>

				<b>타입스크립트는 강력한 객체지향 프로그래밍을 지원합니다.</b></br> 클래스(Class), 인터페이스(Interface), 제네릭(Generics), 모듈(Module)과 같은 기능을 제공하여 <u>대규모 애플리케이션 개발 시 코드의 구조를 더 체계적으로 관리할 수 있게 합니다.</u></br>예를 들어, 인터페이스를 사용하면 객체의 구조를 명확히 정의할 수 있고, 제네릭을 통해 재사용 가능하면서도 타입 안전성을 보장하는 코드를 작성할 수 있습니다.</br></br>

				<b>타입스크립트는 ES6(ECMAScript 2015) 및 <b>그 이후의 최신 자바스크립트 기능을 기본적으로 지원</b>합니다.</b></br> 자바스크립트로 작성된 코드를 실행하기 위해 바벨(Babel)과 같은 별도의 트랜스파일러를 사용할 필요 없이, 타입스크립트 자체적으로 최신 ECMAScript 문법을 기존 자바스크립트 엔진에서 실행 가능한 코드로 변환해줍니다. 이는 개발 워크플로우를 단순화하고 생산성을 높이는 데 기여합니다.</br></br>

				<b>명시적인 정적 타입 지정은 코드의 가독성을 크게 향상시키며, 특히 협업 환경에서 다른 개발자가 코드를 이해하고 유지보수하는 데 도움을 줍니다.</b></br> 예를 들어, 함수의 매개변수나 반환값에 타입을 명시하면 해당 함수가 어떤 데이터를 다루는지 바로 알 수 있어 디버깅 과정도 훨씬 수월해집니다. 게다가 타입스크립트는 타입 추론(Type Inference) 기능을 제공하여, 개발자가 모든 타입을 직접 명시하지 않더라도 컴파일러가 문맥을 통해 타입을 자동으로 추론하게 함으로써 편리함과 안전성을 동시에 제공합니다.</br>8:["categoryname","Convention","d"]
9:["postid","57","d"]
b:"$Lc"
f:[]
10:{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"}
11:{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"}
12:{"display":"inline-block"}
13:{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0}
0:["5LFqdBjTKdOX-pUbi_i-X",[[["",{"children":["(layoutCase)",{"children":["categories",{"children":[["categoryname","Convention","d"],{"children":[["postid","57","d"],{"children":["__PAGE__?{\"categoryname\":\"Convention\",\"postid\":\"57\"}",{}]}]}]}],"search":["__DEFAULT__",{}]}]},"$undefined","$undefined",true],["",{"children":["(layoutCase)",{"children":["categories",{"children":[["categoryname","Convention","d"],{"children":[["postid","57","d"],{"children":["__PAGE__",{},["$L1",[[["$","article",null,{"className":"$undefined","children":["$","header",null,{"children":["$","h1",null,{"className":"postUserInfo_h1__uhAqy","children":"[TECH-QA] 타입 정의 파일(.d.ts) "}]}]}],["$","div",null,{"className":"postUserInfo_post_meta__ABvuC","children":[["$","span",null,{"children":["Posted"," ",["$","time",null,{"className":"postUserInfo_time__2exyR","children":["4 months"," "]}]]}],["$","span",null,{"className":"postUserInfo_update__f345P","children":["Updated"," ",["$","time",null,{"className":"postUserInfo_time__2exyR","children":"4 months"}]]}]]}],["$","div",null,{"children":["$","span",null,{"className":"postUserInfo_post_meta__ABvuC","children":["By"," ",["$","em",null,{"children":["$","$L2",null,{"href":"https://nam-yeun-hwa.github.io/","className":"postUserInfo_author__fVGYM","children":"베짱이가 되고싶은 개미。"}]}]]}]}]],[[false,false,["$","h3",null,{"className":"heading_h3__UisKt","style":{"fontWeight":"NORMAL"},"children":"interface나 type으로 정의하여 쓸수 있는데 d.ts로 사용하는 이유 대하여"}],false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"타입스크립트에서 interface나 type을 사용해 타입을 정의할 수 있는데도 .d.ts 파일을 사용하는 이유는 사용 목적과 맥락의 차이에 있습니다. .d.ts 파일은 주로 <b>선언 파일(Declaration File)</b>로서 특정한 역할을 수행하며, 일반적인 interface나 type 정의와는 다른 상황에서 유용합니다. 아래에서 .d.ts를 사용하는 이유와 그 장점을 구체적으로 설명하겠습니다.\n\t\t\t\t"}}],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"자바스크립트와의 통합: 기존 자바스크립트 코드나 외부 라이브러리에 타입을 추가할 때."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"선언과 구현 분리: 타입 정의를 별도로 관리하고 런타임 코드에 영향을 주지 않으려 할 때."}}],["$","li","2",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"글로벌 타입 제공: 프로젝트 전체에서 사용할 공통 타입을 전역적으로 선언할 때."}}],["$","li","3",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"라이브러리 배포: 타입스크립트 사용자를 위해 타입 정의를 제공할 때."}}]]}],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"반면, 프로젝트 내부에서만 타입을 정의하고 사용할 때는 interface나 type을 .ts 파일에 작성하는 것이 더 간단하고 적합합니다. .d.ts는 특히 외부와의 인터페이스를 다룰 때 빛을 발하는 도구라고 볼 수 있습니다."}}],[false,false,["$","h3",null,{"className":"heading_h3__UisKt","style":{"fontWeight":"NORMAL"},"children":"간단한 자바스크립트 함수에 타입 정의 추가"}],false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"기존 자바스크립트 파일에 타입이 없는 상황을 가정하고, .d.ts 파일로 타입을 제공하는 예제입니다."}}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","자바스크립트 파일 (math.js)"]}]],["$","$L3",null,{"code":"function add(a, b) {\n  return a + b;\n}\n\nmodule.exports = { add };","children":"$undefined"}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","타입 선언 파일 (math.d.ts)"]}]],["$","$L3",null,{"code":"export function add(a: number, b: number): number;","children":"$undefined"}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","타입스크립트에서 사용 (app.ts)"]}]],["$","$L3",null,{"code":"import { add } from \"./math\";\n\nconst result = add(5, 3); // result는 number 타입으로 추론됨\nconsole.log(result); // 8\n\n// add(\"5\", \"3\"); // 오류: 'string' 타입은 'number' 타입에 할당할 수 없음","children":"$undefined"}],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"math.js는 타입 정보가 없는 자바스크립트 파일이지만, math.d.ts에서 add 함수의 매개변수와 반환 타입을 정의해줍니다. 타입스크립트는 이 선언 파일을 참조하여 타입 검사를 수행하며, 잘못된 타입 사용 시 오류를 발생시킵니다. 타입정의는 컴파일 시 타입 체크에 사용되고 자바스크립트로 변환된 런타임 코드에는 타입이 직접 포함되지 않습니다. 실제 실행되는 로직만 남습니다."}}],[false,false,["$","h3",null,{"className":"heading_h3__UisKt","style":{"fontWeight":"NORMAL"},"children":"Lodash와 같은 외부 라이브러리 통합"}],false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"Lodash는 인기 있는 자바스크립트 유틸리티 라이브러리입니다. 타입스크립트에서 이를 사용하려면 @types/lodash와 같은 타입 정의 패키지를 설치하거나 직접 .d.ts 파일을 작성할 수 있습니다."}}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","Lodash 설치"]}]],["$","$L3",null,{"code":"npm install lodash\nnpm install --save-dev @types/lodash //타입 정의 설치 (DefinitelyTyped 제공)","children":"$undefined"}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","타입스크립트에서 사용"]}]],["$","$L3",null,{"code":"import _ from \"lodash\";\n\nconst numbers = [1, 2, 3, 4];\nconst sum = _.sum(numbers); // sum은 number 타입으로 추론됨\nconsole.log(sum); // 10\n\n// _.sum(\"not an array\"); // 오류: 'string'은 'ArrayLike<number>' 타입에 할당할 수 없음","children":"$undefined"}],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"@types/lodash 패키지는 Lodash의 모든 함수에 대한 타입 정의를 제공합니다. 예를 들어, _.sum은 숫자 배열을 받아 숫자를 반환하는 함수로 타입이 정의되어 있으며, 타입스크립트는 이를 기반으로 타입 검사를 수행합니다."}}],[false,false,["$","h3",null,{"className":"heading_h3__UisKt","style":{"fontWeight":"NORMAL"},"children":"React 컴포넌트와 통합"}],false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"React는 자바스크립트로 작성된 라이브러리지만, 타입스크립트에서 사용하려면 타입 정의가 필요합니다.<br /> @types/react와 @types/react-dom을 통해 이를 해결할 수 있습니다."}}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","React 설치"]}]],["$","$L3",null,{"code":"npm install react react-dom\nnpm install --save-dev @types/react @types/react-dom","children":"$undefined"}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","타입스크립트로 React 컴포넌트 작성"]}]],["$","$L3",null,{"code":"import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\ninterface Props {\n  name: string;\n}\n\nconst Greeting: React.FC<Props> = ({ name }) => {\n  return <h1>Hello, {name}!</h1>;\n};\n\nReactDOM.render(<Greeting name=\"Alice\" />, document.getElementById(\"root\"));\n\n// <Greeting name={123} /> // 오류: 'number' 타입은 'string' 타입에 할당할 수 없음","children":"$undefined"}],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"@types/react는 React의 타입 정의를 제공하며, React.FC와 같은 타입을 통해 함수형 컴포넌트의 props 타입을 정의할 수 있습니다. name props가 string으로 정의되었으므로, 숫자를 전달하면 컴파일 오류가 발생합니다."}}],[false,false,["$","h3",null,{"className":"heading_h3__UisKt","style":{"fontWeight":"NORMAL"},"children":"React에 커스텀 타입을 추가하고 싶다면 커스텀 .d.ts로 확장 (선택적)"}],false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"만약 React에 커스텀 타입을 추가하고 싶다면, 다음과 같이 custom.d.ts 파일을 작성할 수 있습니다. 이 경우 customProp을 React 컴포넌트에서 타입 안전하게 사용할 수 있습니다."}}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","custom.d.ts"]}]],["$","$L3",null,{"code":"declare module \"react\" {\n  interface CustomComponentProps {\n    customProp: boolean;\n  }\n}","children":"$undefined"}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","CustomComponent.tsx"]}]],["$","$L3",null,{"code":"import React from \"react\";\n\nconst CustomComponent: React.FC<CustomComponentProps> = ({ customProp }) => {\n  return <div>{customProp ? \"Yes\" : \"No\"}</div>;\n};\n\nexport default CustomComponent;","children":"$undefined"}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","App.tsx"]}]],["$","$L3",null,{"code":"import React from \"react\";\nimport CustomComponent from \"./CustomComponent\";\n\nconst App: React.FC = () => {\n  return (\n      <CustomComponent customProp={true} />\n  );\n};\n\nexport default App;","children":"$undefined"}],[false,false,["$","h3",null,{"className":"heading_h3__UisKt","style":{"fontWeight":"NORMAL"},"children":"커스텀 .d.ts로 확장"}],false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"타입스크립트가 인식하지 못하는 타입이나 타입스크립트 내에서 사용할 타입들을 정의 할때 예로 <b>svg 파일</b>을 타입스크립트에서 불러올 수 있게 하도록 custom.d.ts 파일을 생성해준다."}}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","custom.d.ts"]}]],["$","$L3",null,{"code":"declare module \"*.svg\" {\n  import * as React from \"react\";\n\n  interface CustomSVGProps {\n    title?: string;\n  }\n\n  // SVG 컴포넌트의 전체 props 타입 정의\n  type SVGComponentProps = React.SVGProps<SVGSVGElement> & CustomSVGProps;\n\n  // ReactComponent를 함수형 컴포넌트로 선언\n  export const ReactComponent: React.FunctionComponent<SVGComponentProps>;\n\n  // SVG 파일의 기본 내보내기로 문자열 URL 정의\n  const path: string;\n  export default path;\n}","children":"$undefined"}],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"이 선언을 사용하면 SVG 파일을 다음과 같이 가져와 활용할 수 있습니다"}}],["$","$L3",null,{"code":"import { ReactComponent as Icon } from \"./icon.svg\";\nimport iconPath from \"./icon.svg\";\n\nconst App: React.FC = () => (\n  <div>\n    <Icon width=\"50\" height=\"50\" fill=\"blue\" title=\"My Icon\" />\n    <img src={iconPath} alt=\"Icon\" width=\"50\" height=\"50\" />\n  </div>\n);","children":"$undefined"}],["$","ul",null,{"className":"liststyle_ul__uFdBS","children":[["$","li","0",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"Icon은 SVGComponentProps 타입을 기반으로 타입 검사가 이루어지며, title은 옵셔널로 사용 가능합니다."}}],["$","li","1",{"className":"liststyle_dot__SMzS4","dangerouslySetInnerHTML":{"__html":"iconPath는 string 타입으로 이미지 소스로 활용됩니다."}}]]}],[false,false,["$","h3",null,{"className":"heading_h3__UisKt","style":{"fontWeight":"NORMAL"},"children":"구현 코드와 타입 정의의 분리"}],false],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"타입 정의와 실제 구현 코드를 분리하고 싶을 때, .d.ts 파일은 선언만 포함하고 이는 런타임에 영향을 주지 않습니다. 반면 .ts 파일에 interface나 type과 함께 구현 코드를 섞으면 컴파일 시 자바스크립트 코드로 변환되어 런타임에 포함됩니다."}}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ",".ts 파일에 모두 작성(math.ts)"]}]],["$","$L3",null,{"code":"interface MathOperation {\n  (a: number, b: number): number;\n}\nconst add: MathOperation = (a, b) => a + b;\nexport { add };","children":"$undefined"}],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"math.ts 컴파일 결과: interface는 사라지고 구현 코드만 남음."}}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","math.d.ts"]}]],["$","$L3",null,{"code":"export interface MathOperation {\n  (a: number, b: number): number;\n}\nexport const add: MathOperation;","children":"$undefined"}],[false,false,false,["$","h4",null,{"className":"heading_h4__ZTbA0","style":{"fontWeight":"NORMAL"},"children":["📝 ","math.js"]}]],["$","$L3",null,{"code":"const add = (a, b) => a + b;\nmodule.exports = { add };\nexport const add: MathOperation;","children":"$undefined"}],["$","div",null,{"className":"postDetail_content__OTeO2","dangerouslySetInnerHTML":{"__html":"선언과 구현을 분리하면 실제 실행되는 로직(구현)은 별도의 소스 파일에 두고 <b>타입 정의는 주로 컴파일 타임에 사용되어 코드의 정합성을 확인하거나 개발자에게 힌트를 주는 역할</b>을 하지만, <u>런타임에 실행되는 기계어 코드나 프로그램의 동작에는 직접적인 영향을 미치지 않습니다.</u>  타입 정의만 공유하거나 재사용하기 쉬워집니다. 특히 외부 라이브러리와 통합할 때 유용합니다."}}],[false,false,["$","h3",null,{"className":"heading_h3__UisKt","style":{"fontWeight":"NORMAL"},"children":"interface/type과 .d.ts의 차이점 요약"}],false],["$","$L4",null,{"header":[{"accessorKey":"Feature","header":"특징"},{"accessorKey":"Scope","header":"사용범위"},{"accessorKey":"ImplementationInclusion","header":"구현 포함 여부"},{"accessorKey":"ModuleIntegration","header":"모듈 통합"},{"accessorKey":"GlobalDeclaration","header":"전역 선언"},{"accessorKey":"Purpose","header":"목적"}],"contents":[{"Feature":"interface / type","Scope":"타입스크립트 코드 내부에서만 유효","ImplementationInclusion":".ts 파일 내에서 구현과 함께 사용 가능","sessionStorage":"외부 모듈의 타입 수정 불가","GlobalDeclaration":"import/export 필요","Purpose":"프로젝트 내 타입 정의"},{"Feature":".d.ts 파일","Scope":"자바스크립트와 타입스크립트 연결 가능","ImplementationInclusion":"선언만 포함, 구현은 별도 파일에서","sessionStorage":"declare module로 외부 모듈 타입 정의 가능","GlobalDeclaration":"전역 타입 정의 가능 (declare 사용)","Purpose":"외부 코드와의 인터페이스 역할"}]}]],["$","$L5",null,{"postid":57,"prePostTitle":{"id":58,"title":"[TECH-QA] 컴파일(Compile)과 빌드(Build) 그리고 React 웹팩(Webpack)과 바벨(Babel)","date":"2025-04-02 13:58:33","folder":"Javascript","tag":["JavaScript","TECH-QA","React"],"preview":"\"Build\"와 \"컴파일\"은 소프트웨어 개발에서 자주 사용되는 용어인데, 서로 관련이 있지만 약간 다른 개념을 가리킵니다. 한국어로 자연스럽게 설명해볼게요.","post":[{"type":"Heading","headingType":"h2","value":"컴파일 (Compile)"},{"type":"normal","value":"컴파일은 소스 코드를 사람이 작성한 <b>고급 프로그래밍 언어(예: C, Java, Python 등)에서 컴퓨터가 이해할 수 있는 저급 언어(기계어 또는 바이트코드)로 변환</b>하는 과정을 뜻합니다. 이 작업은 컴파일러(Compiler)라는 도구가 수행합니다."},{"type":"stringlist","value":"예를 들어, C 언어로 작성된 코드를 컴파일하면 실행 가능한 파일(예: .exe)이 만들어집니다.\n<u>문법 오류</u>나 <u>타입 오류</u> 같은 문제가 있으면 컴파일러가 이를 잡아내고 <b>에러 메시지를 출력</b>합니다."},{"type":"Heading","headingType":"h2","value":"빌드 (Build)"},{"type":"normal","value":"빌드는 컴파일을 포함한 더 큰 프로세스를 의미합니다. <b>소프트웨어를 실행하거나 배포할 수 있는 상태</b>로 만드는 전체 작업을 빌드라고 부릅니다. 빌드 과정에는 보통 이런 단계들이 포함되며 단순히 코드를 번역하는 것뿐만 아니라, 프로젝트 전체를 준비하는 과정이라고 볼 수 있습니다."},{"type":"stringlist","value":"1.<b>컴파일</b> : 소스 코드를 기계어로 변환.\n2.<b>링킹(Linking)</b> : 여러 소스 파일이나 라이브러리를 하나로 연결.\n3.<b>테스트</b> : 자동화된 테스트 실행 (경우에 따라).\n4.<b>패키징</b> : 실행 파일이나 배포 가능한 파일(예: .jar, .apk) 생성."},{"type":"normal","value":"요약해보자면"},{"type":"stringlist","value":"<b>컴파일</b>: 코드 번역 과정 (부분).\n<b>빌드</b>: 컴파일 + 추가 작업까지 포함한 전체 준비 과정."},{"type":"Heading","headingType":"h2","value":"리액트 빌드(Build)도구"},{"type":"normal","value":"리액트(React)에서 주로 사용되는 빌드 도구들은 프론트엔드 개발에서 코드 번들링, 트랜스파일링, 최적화 등을 담당하며, 개발 경험과 배포 효율성을 높여줍니다. 아래에 리액트 프로젝트에서 많이 사용되는 대표적인 빌드 도구들을 설명 하겠습니다."},{"type":"Heading","headingType":"h3","value":"웹팩(Webpack)"},{"type":"normal","value":"웹팩은 프로젝트의 구조를 분석하여 자바스크립트 모듈을 비롯한 관련 리소스(예: CSS, 이미지, 폰트 등)를 찾아내고, 이를 브라우저에서 실행할 수 있는 하나의 번들(Bundle)로 묶고 패킹하는 <b>모듈 번들러(Module Bundler)</b>입니다.\n\t\t\t\t모듈 번들러란, 개발 과정에서 여러 개로 나뉘어 있는 파일들(모듈들)을 하나로 통합해 주는 도구이자 라이브러리로, 이를 통해 코드의 의존성을 관리하고 효율적으로 배포할 수 있게 도와줍니다.</br></br>\n\n예를 들어, 웹페이지를 구성하기 위해 자바스크립트, 스타일시트, 이미지 등 수많은 파일이 필요할 때, 브라우저가 이 파일들을 서버에 개별적으로 요청하면 로딩 시간이 길어지고 성능이 저하될 수 있습니다. <b>웹팩</b>은 이런 문제를 해결하기 위해 모든 리소스를 하나의 파일(또는 필요에 따라 몇 개의 파일)로 압축하고 최적화합니다. 이렇게 번들링된 결과물은 요청 횟수를 줄이고, 코드 크기를 최소화하며, 브라우저에서 더 빠르게 실행될 수 있도록 만듭니다."},{"type":"stringlist","value":"<b>의존성 관리</b> : 웹팩은 프로젝트 내 모듈 간의 의존성을 파악합니다. 예를 들어, import나 require로 연결된 파일들을 추적해 필요한 코드만 포함시키고, <b>사용되지 않는 코드는 제외(트리 쉐이킹)</b>할 수 있습니다.\n<b>로더(Loader)</b> : 자바스크립트 외에도 CSS(css-loader), 이미지(file-loader), TypeScript(ts-loader) 등 다양한 파일 형식을 처리할 수 있게 해주는 확장 기능이 있습니다.\n<b>플러그인(Plugins)</b> : 번들링 과정에서 추가 작업을 수행할 수 있도록 지원합니다. 예를 들어, HtmlWebpackPlugin은 HTML 파일을 자동 생성하고, UglifyJsPlugin은 코드를 압축합니다.\n<b>개발 편의성</b> : webpack-dev-server를 통해 실시간으로 코드 변경을 반영하는 핫 리로딩(Hot Reloading)을 제공해 개발 속도를 높여줍니다.\n<b>최적화</b> : 프로덕션 환경에서는 <b>코드 분할(Code Splitting)</b>을 통해 필요한 부분만 로드하거나, 캐싱을 활용해 성능을 개선할 수 있습니다."},{"type":"normal","value":"리액트 프로젝트에서 웹팩은 JSX를 일반 자바스크립트로 변환(Babel과 함께 사용)하고, 컴포넌트와 스타일, 기타 자원을 하나로 묶어 배포 가능한 형태로 만드는 데 자주 사용됩니다. 특히 Create React App은 웹팩을 기반으로 설정이 미리 되어 있어, 개발자가 직접 설정하지 않아도 바로 사용할 수 있게 해줍니다.\n\n결론적으로, 웹팩은 단순히 파일을 묶는 것을 넘어, 현대 웹 개발에서 필수적인 코드 최적화와 성능 개선을 담당하는 강력한 도구입니다. 다만, 설정이 복잡할 수 있다는 단점 때문에 최근에는 Vite나 Parcel 같은 대안도 주목받고 있죠."},{"type":"Heading","headingType":"h3","value":"바벨(Babel)"},{"type":"normal","value":"바벨은 모든 실행 환경에서 자바스크립트가 정상적으로 동작할 수 있도록 해주는 <b>자바스크립트 컴파일러(Transpiler)</b>입니다. "},{"type":"stringlist","value":"주로 최신 자바스크립트 문법(예: ES6/ES2015 이상)을 구형 브라우저에서도 실행 가능한 ES5 코드로 변환해 주는 역할을 합니다. \n\t\t\t\t리액트의 JSX나 TypeScript(TS)와 같은 특수 문법을 일반 자바스크립트로 변환하며, \n\t\t\t\t특정 브라우저에서 지원되지 않는 최신 기능을 사용할 수 있게끔 코드를 재구성해 줍니다."},{"type":"Heading","headingType":"h3","value":"트랜스파일링(Transpiling)의 의미"},{"type":"normal","value":"바벨은 엄밀히 말해 \"컴파일러\"라기보다는 \"트랜스파일러\"로 불립니다. 이는 소스 코드를 다른 언어로 바꾸는 대신, 같은 자바스크립트 언어 내에서 최신 문법을 구형 문법으로 변환하는 과정을 뜻하기 때문입니다. 예를 들어, const나 화살표 함수(=>) 같은 ES6 문법을 ES5의 var와 일반 함수로 바꿔줍니다."},{"type":"stringlist","value":"<b>ES6+ 변환</b>: let, const, async/await, 모듈(import/export) 등 최신 자바스크립트 기능을 구형 환경에 맞게 변환.\n<b>JSX 지원</b>: 리액트에서 사용하는 JSX 문법(예: <div>Hello</div>)을 React.createElement() 같은 자바스크립트 코드로 변환.\n<b>TypeScript 지원</b>: .ts나 .tsx 파일을 자바스크립트로 변환하며, 타입 체크는 별도로 TypeScript 컴파일러(tsc)에 맡김.\n<b>폴리필(Polyfill)</b>: 바벨 자체는 문법만 변환하지만, @babel/polyfill이나 core-js와 함께 사용하면 Promise, Array.includes 같은 최신 API도 구형 브라우저에서 동작하게 추가 가능."},{"type":"Heading","headingType":"h3","value":"작동 방식"},{"type":"stringlist","value":"파싱(Parsing): 소스 코드를 읽어 추상 구문 트리(AST)로 변환.\n변환(Transforming): 플러그인과 프리셋(Preset)을 통해 AST를 수정(예: ES6 → ES5).\n생성(Generating): 수정된 AST를 기반으로 최종 자바스크립트 코드를 출력."},{"type":"Heading","headingType":"h3","value":"플러그인과 프리셋"},{"type":"stringlist","value":"바벨은 모듈화된 구조로, 특정 변환 작업을 플러그인(예: @babel/plugin-transform-arrow-functions)으로 추가할 수 있습니다.\n프리셋은 여러 플러그인을 묶은 세트로, @babel/preset-env는 타겟 브라우저에 맞춰 필요한 변환만 적용해 효율성을 높여줍니다. 리액트용으로는 @babel/preset-react가 JSX 처리를 담당합니다."},{"type":"normal","value":"리액트 개발에서 바벨은 필수적입니다. JSX를 브라우저가 이해할 수 있는 코드로 바꿔주고, 최신 자바스크립트 기능을 사용하면서도 다양한 브라우저 호환성을 보장해 줍니다. Create React App이나 Vite 같은 도구는 바벨을 기본으로 내장하고 있어 설정 없이도 바로 사용 가능합니다. </br>결론적으로, 바벨은 자바스크립트 개발에서 \"호환성의 다리\" 역할을 하며, 특히 리액트처럼 최신 기술을 사용하는 환경에서 없어서는 안 될 도구입니다. 웹팩이나 Vite 같은 빌드 도구와 함께 사용되며, 개발자가 최신 기능을 자유롭게 쓰면서도 모든 사용자를 지원할 수 있게 해줍니다."}]},"nextPostTile":{"id":56,"title":"[TECH-QA] 타입스크립트","date":"2025-03-31 14:07:33","folder":"Javascript","tag":["JavaScript","TECH-QA"],"preview":"타입스크립트는 자바스크립트 기반의 언이이며 자바스크립트의 상위확정전입니다. 정적타입으로 컴파일 단계에서 오류를 포착할수 있는 장점이 있고 강력한 객체지향 프로그래밍을 지원합니다.","post":[{"type":"normal","value":"타입스크립트는 자바스크립트 기반의 언이이며 자바스크립트의 상위확정전입니다. 정적타입으로 컴파일 단계에서 오류를 포착할수 있는 장점이 있고 강력한 객체지향 프로그래밍을 지원합니다."},{"type":"Heading","headingType":"h2","value":"타입스크립트 특징"},{"type":"stringlist","value":"$6"},{"type":"GuideMessage","value":"<b>타입추론이란?</b></br>\n\t\t\t\t<b>변수 선언에서의 타입 추론</b>: 변수를 초기화할 때 값을 할당하면, 타입스크립트는 해당 값의 타입을 기반으로 변수의 타입을 추론합니다.</br>\n\t\t\t\t<b>함수 반환 타입 추론</b>:함수의 반환값을 명시적으로 타입으로 선언하지 않아도, 타입스크립트는 함수 내부의 로직을 분석해 반환 타입을 추론합니다.</br>\n\t\t\t\t<b>객체 리터럴에서의 타입 추론</b>:객체를 생성할 때 각 속성의 타입을 명시하지 않아도, 초기화된 값에 따라 타입이 추론됩니다.","promptTypeProps":"TIP"},{"type":"normal","value":"추가적으로, 타입스크립트는 방대한 생태계를 자랑합니다. <b>타입 정의 파일(.d.ts)</b>을 통해 기존 자바스크립트 라이브러리(예: React, Lodash 등)와의 통합이 용이하며, 커뮤니티에서 제공하는 DefinitelyTyped 프로젝트를 통해 수많은 라이브러리의 타입 정의를 쉽게 가져와 사용할 수 있습니다. 이로 인해 타입스크립트는 프론트엔드(React, Angular, Vue.js)와 백엔드(Node.js) 개발 모두에서 널리 사용되며, 현대 웹 개발에서 필수적인 도구로 자리 잡았습니다.\n\n결론적으로, 타입스크립트는 자바스크립트의 유연성을 유지하면서도 정적 타입의 안정성과 객체지향 프로그래밍의 강력함을 더한 언어로, 코드 품질을 높이고 대규모 프로젝트를 효율적으로 관리하려는 개발자들에게 이상적인 선택입니다."}]},"segment":"posts"}],["$","div",null,{"className":"footer_footer_container__MsSvO","children":["$","footer",null,{"className":"footer_footer__AwYty","children":[["$","p",null,{"className":"footer_copylight___J5l0","children":["© 2024 ","베짱이가 되고싶은 개미。"," Some rights reserved."]}],["$","p",null,{"className":"footer_theme__bwXbg","children":"portfolio v1.0.0-alpha.3"}]]}]}]],null]]},["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children","(layoutCase)","children","categories","children","$8","children","$9","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$La",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/175d6c648827cdb6.css","precedence":"next","crossOrigin":""}]]}]]},["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children","(layoutCase)","children","categories","children","$8","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$La",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children","(layoutCase)","children","categories","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$La",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]],"search":["__DEFAULT__",{},["$b","$Ld",null]]},[null,["$","$Le",null,{"children":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children","(layoutCase)","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$La",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":null}],"search":["$","$L7",null,{"parallelRouterKey":"search","segmentPath":["children","(layoutCase)","search"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$La",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$f","styles":null}],"params":{}}],null]]},[null,["$","html",null,{"lang":"en","className":"","children":[["$","head",null,{"children":[["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css","as":"style"}],["$","link",null,{"rel":"preconnect","href":"https://fonts.googleapis.com"}],["$","link",null,{"rel":"preconnect","href":"https://fonts.gstatic.com"}],["$","link",null,{"rel":"stylesheet","href":"https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR&display=swap","as":"style"}]]}],["$","body",null,{"children":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$La",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":"$10","children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":"$11","children":"404"}],["$","div",null,{"style":"$12","children":["$","h2",null,{"style":"$13","children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/0c496b0e03d530ba.css","precedence":"next","crossOrigin":""}]]}]}]]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/80c9ce4c138da48c.css","precedence":"next","crossOrigin":""}]],"$L14"]]]]
d:E{"digest":"NEXT_NOT_FOUND"}
14:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"be come 💡"}],["$","meta","3",{"name":"description","content":"App for an Ant Who Wants to Become a Bejjangyi"}]]
1:null
c:null
