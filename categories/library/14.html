<!DOCTYPE html><html lang="en" class=""><head><meta charSet="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/b61b62d196836ce7.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/04d20c09b3119d43.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/4be7aaf21dbfc26e.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-7cbbdf1c4fd681ae.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-0e492acdb34e0e7d.js" async="" crossorigin=""></script><script src="/_next/static/chunks/938-073485517c55f951.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-d3c7d898fafbc3cf.js" async="" crossorigin=""></script><script src="/_next/static/chunks/250-8b90be581650ff9d.js" async=""></script><script src="/_next/static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-9eb9aaf2756d2762.js" async=""></script><script src="/_next/static/chunks/304-f6bea3ededee4fbe.js" async=""></script><script src="/_next/static/chunks/730-7ade87634bab4187.js" async=""></script><script src="/_next/static/chunks/566-b141861ca793acbd.js" async=""></script><script src="/_next/static/chunks/35-428bf187f02277f1.js" async=""></script><script src="/_next/static/chunks/338-f2b637e42a7ca177.js" async=""></script><script src="/_next/static/chunks/app/(layoutCase)/layout-b528a91c526f504b.js" async=""></script><title>be come 💡</title><meta name="description" content="App for an Ant Who Wants to Become a Bejjangyi"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" as="style"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR&amp;display=swap" as="style"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><aside id="sidebar" class="sidemenu_sidebar__EmvJl"><header class="sidemenu_profile_wrapper__R57aU"><a href="/posts"><img alt="프로필 사진" loading="lazy" width="112" height="112" decoding="async" data-nimg="1" class="imageLoader_img__X4hab" style="color:transparent" srcSet="https://nam-yeun-hwa.github.io/image/profile1.jpg?w=128&amp;q=75 1x, https://nam-yeun-hwa.github.io/image/profile1.jpg?w=256&amp;q=75 2x" src="https://nam-yeun-hwa.github.io/image/profile1.jpg?w=256&amp;q=75"/></a><h1 class="sidemenu_blog_name_txt__AfWhD">my blog</h1><p class="sidemenu_site_subtitle__eLcN7">You can only earn as much as an ant does by working like an ant.</p></header><nav><ul class="sidemenu_nav__6C5tz"><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/posts"><i class="fa-fw fas fa-home sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">HOME</span></a></li><li class="sidemenu_nav_item__tt_B1 sidemenu_active__fflT6"><a class="sidemenu_nav_link__WTCmf" href="/categories"><i class="fa-fw fas fa-stream sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">CATEGORIES</span></a></li><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/tags"><i class="fa-fw fas fa-tags sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">TAGS</span></a></li><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/archives"><i class="fa-fw fas fa-archive sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">ARCHIVES</span></a></li><li class="sidemenu_nav_item__tt_B1"><a class="sidemenu_nav_link__WTCmf" href="/algorithm"><i class="fa-solid fa-mug-saucer sidemenu_ico__6idJs"></i><span class="sidemenu_nav_txt__mSemS">CODING</span></a></li></ul></nav><div class="sidebar-bottom"></div></aside><div class="layout_main_wrapper__1M1Uy"><div class="contents_container__AfHAx"><header class="breadCrumb_topbar_wrapper__dGN_V"><div class="breadCrumb_top_bar__b_rV9"><nav class="breadCrumb_breadcrumb__l7WLX"><span><a class="breadCrumb_topbar_txt__ExrWf" href="/">Home</a><a class="breadCrumb_topbar_txt__ExrWf" href="">테스트 주도 개발(Test driven devlopment, TDD)</a></span></nav><search class="searchBar_search__Ftlhc"><i class="fas fa-search fa-fw searchBar_search_ico__STStc"></i><input id="search" class="searchBar_search_input__1XpQF" placeholder="Search..." autoComplete="off" value=""/></search></div><div class="breadCrumb_mobile_topbar__N1Azi"><button class="breadCrumb_sidebar_trigger__APgD8"><i class="fas fa-bars fa-fw breadCrumb_sidebar_trigger_ico__K9DdV"></i></button><div class="breadCrumb_mobile_topbar_title__oCVBS">be come 💡</div><button class="breadCrumb_search_trigger__PxWyf"><i class="fas fa-search fa-fw breadCrumb_search_trigger_ico__yqqpz"></i></button></div></header><div class="contents_contents__Hpf57"><main class="contents_inner_content__wyt37"><article><header><h1 class="postUserInfo_h1__uhAqy">테스트 주도 개발(Test driven devlopment, TDD)</h1></header></article><div class="postUserInfo_post_meta__ABvuC"><span>Posted<!-- --> <time class="postUserInfo_time__2exyR">13 days<!-- --> </time></span><span class="postUserInfo_update__f345P">Updated<!-- --> <time class="postUserInfo_time__2exyR">13 days</time></span></div><div><span class="postUserInfo_post_meta__ABvuC">By<!-- --> <em><a class="postUserInfo_author__fVGYM" href="https://nam-yeun-hwa.github.io/">베짱이가 되고싶은 개미。</a></em></span></div><div class="postDetail_content__OTeO2">소프트웨어를 전문적으로 개발하는 기업들은 서비스의 안정적인 운영과 서비스의 품질을 확보하기 위해 테스트 코드를 작성하고 관리하고 있다. 다시 말하면 서비스의 품질을 확보하기 위해서는 테스트 코드 작성이 필수라는 것이다.</div><div class="postDetail_content__OTeO2">테스트 주도 개발이라는 개념이 나오기 전에는 우리가 지금까지 해온 것과 같이 움직이는 소프트웨어를 개발한 후 해당 소프트 웨어에 대한 테스트 코드를 작성하는 방식을 사용해 왔다. 이 방식을 사용하면 다음과 같은 문제점들이 있다.</div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">다른 사람이 작성한 소스 코드 또는 내가 예전에 작성한 코드에 대해 테스트 코드를 작성해야 하는데 이 코드가 어떻게 동작하는지 알 수 없거나 기억할 수 없음으로 코드를 다시 분석하고 테스트 코드를 작성해야 한다.</li><li class="liststyle_dot__SMzS4">        작성된 코드가 테스트하기 쉽게 작성되어 있지 않다. 따라서 테스트 코드를 작성하기가 불가능 하거나 테스트 코드를 작성하기 위해 이미 작성된 코드를 수정해야 할 경우가 발생한다. 이때 기존 코드의 수정으로 인해 예기치 않은 문제가 발생할 수 있다.</li></ul><div class="postDetail_content__OTeO2">이런 문제를 해결하기 위해 켄트백(Kent Beck)은 테스트 코드를 먼저 작성하는 테스트 주도 개발론을 제안하게 되었다. 테스트 줃 개발 방벙론은 테스트 프레임워크 등을 사용하여 자동화된 테스트 시스템에서 미리 정의된 사양을 바탕으로</div><blockquote class="Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_warning__ZYPQt"><p class="Prompts_detail__nD6Io">실패하는 테스트 명세를 작성하고 그 테스트 명세를 통과하기 위한 최소한의 코드를 작성한다. 마지막으로 해당 코드를 리팩토링 하는 것으로 개발을 마치는 프로세스이다.</p></blockquote><h2 class="heading_h2__fsXMw">Jest 테스트 프레임워크로 테스트 코드 작성하기</h2><div class="postDetail_content__OTeO2">Jest는 주로 JavaScript 및 TypeScript 애플리케이션을 테스트하기 위해 사용되는 JavaScript 테스팅 프레임워크로 특히 React 애플리케이션 테스트에 최적화되어 있다. 페이스북(현 메타)에서 개발했으며,  React 외에도 다른 JavaScript 프레임워크나 라이브러리와도 잘 작동한다.</div><h2 class="heading_h2__fsXMw">Jest의 주요 쿼리 함수</h2><h3>describe 함수 </h3><div class="postDetail_content__OTeO2">describe함수는 jest가 제공하는 함수로써 여러 테스트를 한 그룹으로 묶고 설명을 붙이기 위해 사용한다.</div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">첫번째 매개변수는 명령 프롬프트에 표시할 설명</li><li class="liststyle_dot__SMzS4">        두번째 매개변수는 여러 테스트를 그룹으로 묶을 콜백 함수</li></ul><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">describe('test index.js file', () => {

});</pre></div></div><h3>it 함수</h3><div class="postDetail_content__OTeO2">it함수는 실제 테스트가 실행되는 테스트 명세를 작성할 때 사용한다.</div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">첫번째 매개변수는 테스트 명세의 설명</li><li class="liststyle_dot__SMzS4">        두 번째 매개변수에는 실제로 테스트를 실행하는 테스트 코드를 작성</li></ul><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">it('sum 1+2 to equal 3', () => {
      
});</pre></div></div><h3>expect 함수</h3><div class="postDetail_content__OTeO2">expect 함수는 주로 테스트 프레임워크에서 테스트 결과를 확인하기 위해 사용되는 메서드나 함수이다. expect 함수는 테스트 대상이 특정 조건을 만족하는지, 즉 예상된 동작을 수행하는지를 검증하는 역할이다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">it('sum 1+2 to equal 3', () => {
      expect(sum(1,2)).toBe(3);
});</pre></div></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">여기서 sum(1,2)는 테스트 대상이 실제로 생성한 값이고, 3는 기대하는 값이며 toBe는 일치 여부를 확인하는 메서드이다.</li></ul><div class="postDetail_content__OTeO2">expect는 단순한 값 비교 외에도 다양한 일치 조건을 제공한다. 예를 들어, 두 객체가 동일한지, 배열이 특정 요소를 포함하는지, 함수가 특정 예외를 던지는지 등을 확인할 수 있다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">// 객체나 배열의 동등성 비교
expect(actualValue).toEqual(expectedValue); 

// 배열이 특정 아이템을 포함하는지
expect(array).toContain(item); 

// 함수가 특정 오류를 던지는지
expect(() => functionCall()).toThrow(ErrorType); 
        </pre></div></div><h2 class="heading_h2__fsXMw">@testing-library로 리액트 컴포넌트 테스트 코드 작성 하기</h2><div class="postDetail_content__OTeO2">@testing-library는 DOM 테스팅 라이브러리(DOM Testing Library)이다. @testing-library는 사용자 중심 방식으로 UI 컴포넌트를 테스트하는데 도움을 주는 라이브러리이며
        리액트 컴포넌트의 테스트 코드 작성을 도와준다. </br></br>
        
        테스트 코드를 작성할 때 컴포넌트 세부 구현사항을 포함하지 않으면서도 신뢰할 수 있는 테스트 코드 작성에 도움을 준다. 이렇게 컴포넌트의 세부 구현 사항을 포함하지 않은 테스트 코드를 작성하면 컴포넌트의 세부 구현 부분을 리팩토링 하여도 테스트 코드를 수정할 필요가 없다, 이로 인해 한번 작성한 테스트 코드는 긴 시간 유지할 수 있으며 오랜 기간 유지 가능하여 테스트 코드를 자주 수정하지 않아도 되므로 개발 생산성을 향상 시켜 준다.</div><h3>App.js 컴포넌트 - 렌더링 테스트</h3><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">import { render, screen } from 'testing-library/react';
import App from './App.js';
        
test('renders learn react link', ()=>{
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
})</pre></div></div><h3>test</h3><div class="postDetail_content__OTeO2">test 함수(it 함수와 같은 역할을 하는 함수)를 사용하여 테스트 명세를 작성한 테스트 코드이다.</div><h3>render</h3><div class="postDetail_content__OTeO2">리액트 컴포넌트를 화면에 표시하기 위함</div><h3>screen</h3><div class="postDetail_content__OTeO2">리액트 컴포넌트가 표시된 화면을 의미한다.</div><h3>GetByText</h3><div class="postDetail_content__OTeO2">getByText 함수는 주어진 텍스트를 포함하는 DOM 요소를 찾는 데 사용된다. 렌더링된 컴포넌트에서 screen.GetByText를 통해 화면에서 'learn react'라는 글자를 가지고 있는 돔 요소를 찾는다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">import { render, screen } from '@testing-library/react';
import App from './App';
        
test('renders Hello World text', () => {
  render(<App />);
  const textElement = screen.getByText('Hello World');
  expect(textElement).toBeInTheDocument();
});
        </pre></div></div><h3>toBeInTheDocument</h3><div class="postDetail_content__OTeO2">요소를 찾아 jest expect().toBeInTheDocument()를 사용하여 돔에 표시되어 있는지 확인 한다. </br>

        render 함수는 메모리상에 돔을 만들고 screen을 통해 해당 돔에 접근 하는 것을 의미한다.
        react-testing-library의 render 함수를 사용하여 App이라는 컴포넌트를 렌더링 하였다.</div><h2 class="heading_h2__fsXMw">React Testing Library의 주요 쿼리 함수</h2><h3>getByText</h3><div class="postDetail_content__OTeO2">주어진 텍스트를 포함하는 요소를 찾습니다.</br>
        ex) screen.getByText(/learn react/i)는 대소문자를 구분하지 않고 "learn react"라는 텍스트를 포함하는 요소를 찾습니다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">import { render, screen } from '@testing-library/react';
import App from './App';
        
test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
        </pre></div></div><h3>getByRole</h3><div class="postDetail_content__OTeO2">특정 역할(예: 버튼, 링크)을 가진 요소를 찾습니다.</br>
        screen.getByRole('button', { name: /submit/i })은 "submit" 텍스트를 가진 버튼을 찾습니다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">import { render, screen } from '@testing-library/react';
import App from './App';
        
test('renders submit button', () => {
  render(<App />);
  const buttonElement = screen.getByRole('button', { name: /submit/i });
  expect(buttonElement).toBeInTheDocument();
});
        </pre></div></div><h3>getByLabelText</h3><div class="postDetail_content__OTeO2">특정 라벨 텍스트와 연결된 요소(주로 폼 필드)를 찾습니다.</br>
        screen.getByLabelText('Username')은 "Username" 라벨을 가진 입력 필드를 찾습니다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">import { render, screen } from '@testing-library/react';
import LoginForm from './LoginForm';
        
test('finds the username input', () => {
  render(<LoginForm />);
  const inputElement = screen.getByLabelText('Username');
  expect(inputElement).toBeInTheDocument();
});
        </pre></div></div><h3>getByPlaceholderText</h3><div class="postDetail_content__OTeO2">특정 플레이스홀더 텍스트를 가진 입력 요소를 찾습니다. </br>
        screen.getByPlaceholderText('Enter your username')은 "Enter your username" 플레이스홀더를 가진 입력 필드를 찾습니다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">import { render, screen } from '@testing-library/react';
import LoginForm from './LoginForm';
        
test('finds the input by placeholder', () => {
  render(<LoginForm />);
  const inputElement = screen.getByPlaceholderText('Enter your username');
  expect(inputElement).toBeInTheDocument();
});
        </pre></div></div><h3>getByAltText</h3><div class="postDetail_content__OTeO2">주어진 alt 텍스트를 가진 이미지를 찾습니다.</br>
        screen.getByAltText('Profile Picture')은 "Profile Picture" alt 텍스트를 가진 이미지를 찾습니다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">import { render, screen } from '@testing-library/react';
import Profile from './Profile';
        
test('finds the profile picture', () => {
  render(<Profile />);
  const imageElement = screen.getByAltText('Profile Picture');
  expect(imageElement).toBeInTheDocument();
});
        </pre></div></div><h3>getByTestId</h3><div class="postDetail_content__OTeO2">data-testid 속성을 사용하여 요소를 찾습니다. </br>
        screen.getByTestId('custom-element')은 data-testid="custom-element" 속성을 가진 요소를 찾습니다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">import { render, screen } from '@testing-library/react';
import Component from './Component';
        
test('finds element by test id', () => {
  render(<Component />);
  const element = screen.getByTestId('custom-element');
  expect(element).toBeInTheDocument();
});
        </pre></div></div><h3>queryByText</h3><div class="postDetail_content__OTeO2">요소가 존재하지 않거나, 하나만 존재할 때 사용합니다. 존재하지 않으면 null을 반환합니다. </br>
        getByText는 요소가 없으면 에러를 던집니다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">import { render, screen } from '@testing-library/react';
import App from './App';
        
test('does not find non-existing text', () => {
  render(<App />);
  const textElement = screen.queryByText('Non-existing Text');
  expect(textElement).toBeNull();
});
        </pre></div></div><h3>findByText</h3><div class="postDetail_content__OTeO2">비동기적으로 요소를 찾을 때 사용합니다. 주로 요소가 나중에 렌더링될 경우에 사용합니다. 반환 값은 Promise입니다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">import { render, screen } from '@testing-library/react';
import App from './App';
        
test('renders welcome message', async () => {
  render(<App />);
  const messageElement = await screen.findByText(/welcome/i);
  expect(messageElement).toBeInTheDocument();
});
        </pre></div></div><h2 class="heading_h2__fsXMw">참고할만한 예제들</h2><h3>예제 [1] - 컴포넌트가 올바르게 렌더링되는지를 확인하는 테스트 케이스</h3><div class="postDetail_content__OTeO2">&lt;App />에 대한 Jest 테스트 스위트를 작성한 것으로 <App /> 컴포넌트가 올바르게 렌더링되는지를 확인하는 하나의 테스트 케이스를 포함하고 있다.</div><div class="Keyword_container__llQKF"><p class="Keyword_keywordTilte__P_LIO">관련 키워드</p><div class="Keyword_keywordContainer__3u0Pv"><p class="Keyword_keyword__CZ9_3">render</p><p class="Keyword_keyword__CZ9_3">getElementByClassName</p><p class="Keyword_keyword__CZ9_3">toHaveLength</p><p class="Keyword_keyword__CZ9_3">toHaveAttribute</p></div></div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">describe('&lt;App />', ()=>{
it('renders component correctly', ()=>{      
      ① const { container } = render(<App />);              
      ② expect(container.getElementByClassName('App-logo')).toHaveLength(1);       
      ③ expect(container.getElementByClassName('App-logo')[0]).toHaveAttribute('src','logo.svg');
    })
})</pre></div></div><div class="postDetail_content__OTeO2">① 이 줄은 &lt;App /> 컴포넌트를 렌더링한다. render 함수는 컴포넌트를 가상 DOM에 렌더링하고, 반환된 객체에서 container를 구조 분해 할당하여 가져오며 container는 렌더링된 DOM 트리를 포함한다.
        ② 이 줄은 container 안에 'App-logo' 클래스를 가진 요소가 하나 있는지 확인한다. expect 함수는 기대값을 설정하는 데 사용되고, toHaveLength(1)는 요소의 길이가 1인지 확인한다.
        ③ 이 줄은 'App-logo' 클래스를 가진 첫 번째 요소가 'src' 속성을 가지고 있으며, 그 값이 'logo.svg'인지 확인한다. toHaveAttribute('src', 'logo.svg')는 요소의 src 속성이 'logo.svg'인지를 확인한다.</div><h3>예제 [2] - &lt;img /&gt; 테스트 코드</h3><div class="Keyword_container__llQKF"><p class="Keyword_keywordTilte__P_LIO">관련 키워드</p><div class="Keyword_keywordContainer__3u0Pv"><p class="Keyword_keyword__CZ9_3">render</p><p class="Keyword_keyword__CZ9_3">getElementsByTagName</p><p class="Keyword_keyword__CZ9_3">toHaveLength</p><p class="Keyword_keyword__CZ9_3">toHaveTextContext</p></div></div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">describe('&lt;App />', ()=>{
it('renders component correctly', ()=>{
      ①const { container } = render(<App />);  
      ② expect(container.getElementsByTagName('p')).toHaveLength(1);
      ③ expect(container.getElementsByTagName('p')[0]).toHaveTextContext('Edit src/App.js and save to reload.')
   })
})</pre></div></div><div class="postDetail_content__OTeO2">① 이 줄은 &lt;App /> 컴포넌트를 렌더링한다. render 함수는 컴포넌트를 가상 DOM에 렌더링하고, 반환된 객체에서 container를 구조 분해 할당하여 가져오며 container는 렌더링된 DOM 트리를 포함한다.
        ② 이 줄은 container 안에 <p> 태그를 가진 요소가 하나 있는지 확인한다. expect 함수는 기대값을 설정하는 데 사용되고, toHaveLength(1)는 해당 요소의 길이가 1인지 확인한다.
        ③ 이 줄은 &lt;p> 태그를 가진 첫 번째 요소가 'Edit src/App.js and save to reload.'라는 텍스트 내용을 가지고 있는지 확인한다. expect 함수는 기대값을 설정하는 데 사용되고, toHaveTextContent('Edit src/App.js and save to reload.')는 해당 요소의 텍스트 내용이 정확히 일치하는지를 확인한다.</div><h3>예제 [3] - &lt;p/&gt; 테스트</h3><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">describe('&lt;App />', ()=>{
  it('renders component correctly', ()=>{
      const { container } = render(<App />);    
      expect(container).toMatchSnapshot();
    })
})</pre></div></div><div class="postDetail_content__OTeO2">toMatchSnapshot가 실행되면 src/snapshots/App.test.js.snap이라는 파일이 생성된 것을 확인 할 수 있다. 파일을 열어 내용을 확인해 보면 App 컴포넌트가 화면에 렌더링될 때 표시되는 HTML 내용이 저장된 것을 확인 할 수 있다.</br>
        저장된 스냅샷은 App 컴포넌트가 수정되어 화면에 표시되는 HTML 구조가 변경되면 에러를 표시하게 된다. 이렇게 스냅샷은 화면에 표시되는 컴포넌트가 변경되었는지 감지하기 위한 테스트로 많이 사용된다.</div><blockquote class="Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_warning__ZYPQt"><p class="Prompts_detail__nD6Io">만약 컴포넌트를 수정하여 화면 표시가 변경된 것이 의도된 수정이었다면 스냅샷 테스트로 저장된 파일을 업데이트해 주어야 한다. 명령프롬프트에 에러가 표시된 상태에서 키보드 'u'키를 누르면 스냅샷으로 생성된 파일이 업데이트 된다. 그러면 새롭게 업데이트된 스냅샷 파일이 다시 기준이 되어 변경을 감지하고 에러를 표시하게 된다.</p></blockquote><h3>예제 [4] - 스냅샷 (화면에 표시되는 내용이 변경 되었는지 체크)</h3><div class="Keyword_container__llQKF"><p class="Keyword_keywordTilte__P_LIO">관련 키워드</p><div class="Keyword_keywordContainer__3u0Pv"><p class="Keyword_keyword__CZ9_3">getByText</p><p class="Keyword_keyword__CZ9_3">parentElement</p><p class="Keyword_keyword__CZ9_3">toHaveStyleRule</p></div></div><div class="postDetail_content__OTeO2">Button 컴포넌트는 Props만을 가지는 단순 컴포넌트이다.
        Button 컴포넌트가 화면에 잘 표시 되는지, Props가 잘 적용되는지를 확인하도록 한다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">import React from 'react';
import { render, screen } from 'testing-library/react';
import 'jest-styled-components';
import {Button} from './index';

describe('&lt;Button />', ()=>{
  it('renders component correctly', ()=>{
        ① const { container } = render(&lt;Button label="Button Test" />);

        ② const label = screen.getByText("button Test");
           expect(label).toBeInTheDocument();

        ③ const parent = label.parentElement;
        ④ expect(parent).toHaveStyleRule('background-color', '#304FFE');
          expect(parent).toHaveStyleRule('background-color', '#1E40FF', { modifier:'hover'});
        
        ⑤ expect(container).toMatchSnapshot();
    })
})</pre></div></div><div class="postDetail_content__OTeO2">
        ① render 함수는 &lt;Button label="Button Test" />를 가상 DOM에 렌더링하고, 반환된 객체에서 container를 구조 분해 할당한다. </br></br>
② screen.getByText를 사용하여 "Button Test"라는 텍스트를 가진 요소를 찾는다. 
expect로 해당 요소가 문서에 존재하는지 확인한다.</br></br>
③ label 요소의 부모 요소(parentElement)를 가져온다.</br></br>

④ expect를 사용하여 부모 요소가 특정 스타일 규칙을 가지고 있는지 확인한다. jest-styled-components의 toHaveStyleRule을 사용하여 다음 두 가지 스타일 규칙을 확인한다.</br></div><ul class="liststyle_ul__uFdBS"><li class="liststyle_dot__SMzS4">기본 배경색이 #304FFE인지</li><li class="liststyle_dot__SMzS4">        hover 상태에서 배경색이 #1E40FF인지</li></ul><div class="postDetail_content__OTeO2">backgroundColor과 hoverColor은 우리가 screen.getByText로 찾은 Label 컴포넌트가 아닌 Label 컴포넌트의 부모 요소인 Container 컴포넌트에 설정이 된다. 따라서 label.parentElement를 사용해 Label 컴포넌트의 부모 요소(Container 컴포넌트)에 접근하여 값이 잘 설정 되었는지 확인 한다.</br></br>

        Button 컴포넌트는 Props로 BackgroundClolor과 hoverColor이 설정되어 있지 않으면 기본값이 설정되도록 개발 되었다. backgroundColor과 hoverColor가 설정되어 있지 않은 상황에서 기본값이 잘 설정되는지 확인하기 위해 jest-styled-components의 새로운 Matcher인 toHaveStyleRule를 사용하여 확인 하도록 한다.</div><div class="postDetail_content__OTeO2">⑤ 마지막으로, container의 현재 상태를 스냅샷으로 저장하여 이후 테스트 실행 시 컴포넌트의 출력이 변하지 않았는지 확인합니다.</div><h3>예제 [4] - onClick 함수 테스트</h3><div class="postDetail_content__OTeO2">Button 컴포넌트의 onClick 함수를 테스트 하기 위한 테스트 명세이다.</div><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">it('clicks the button', () => {
    ① const handlerClick = jest.fn(); 
    ② render(&lt;Button label="Button Test" onClick={handlerClick} />); 
    ③ const label = screen.getByText('Button Test'); 
    ④ expect(handleClick).toHaveBeenCalledTimes(0); 
    ⑤ fireEvent.click(label); 
    ⑥ expect(handlerClick).toHaveBeenCalledTimes(1); 
});</pre></div></div><div class="postDetail_content__OTeO2">
        ① 클릭 핸들러 함수로 jest.fn()을 사용하여 mock 함수 생성 </br>
        ② Button 컴포넌트를 렌더링하고, onClick props에 mock 함수 전달</br>
        ③ 화면에서 "Button Test" 라는 텍스트를 가진 요소를 찾음</br>
        ④ 클릭 이벤트가 발생하지 않았는지 확인</br>
        ⑤ 찾은 요소에 클릭 이벤트를 발생시킴</br>
        ⑥ 클릭 이벤트 핸들러가 한 번 호출되었는지 확인</br>
        </div><div class="postDetail_content__OTeO2">그다음 화면에 표시된 버튼 컴포넌트를 찾아서 아직 해당 컴포넌트를 클릭하지 않았음을 확인하기 위해 toHaveBeenCalledTimes 함수를 사용하여 우리가 만든 모의함수가 잘 호출되었는지 확인해준다.</div><blockquote class="Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_warning__ZYPQt"><p class="Prompts_detail__nD6Io"><b>모의 함수(Mocking functions)</b></br>
        onClick 이벤트에는 사실 어떤 함수가 연결될지 알 수가 없다. jest에서는 이처럼 어떤 이벤트를 통해 함수가 호출되는지를 확인하기 위해 모의 함수(Mocking functions)를 사용한다. 모의 함수를 사용하여 onClick 이벤트를 테스트 한다.</br></br>

jest의 모의함수(jest.fn)을 사용하여 handlerClick 변수를 선언하고 Button 컴포넌트의 Props로 onClick을 통해 전달 해준다.
        </p></blockquote><h3>예제 [5] - &lt;Input /&gt; 입력된 값이 일치 체크</h3><div class="Keyword_container__llQKF"><p class="Keyword_keywordTilte__P_LIO">관련 키워드</p><div class="Keyword_keywordContainer__3u0Pv"><p class="Keyword_keyword__CZ9_3">getByDisplayValue</p><p class="Keyword_keyword__CZ9_3">getByPlaceholderText</p><p class="Keyword_keyword__CZ9_3">fireEvent</p><p class="Keyword_keyword__CZ9_3">fireEvent.change</p></div></div><h4 class="heading_h4__ZTbA0">📝 <!-- -->getByDisplayValue를 이용하여 input을 찾아 렌더링 하는 예제</h4><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">import React from 'react';
import { render, screen, fireEvent } from 'testing-library/react';
import 'jest-styled-components';
import {Input} from './index';

describe('&lt;Input />', ()=>{
	it('renders component correctly', ()=>{
      ① const { container } = render(&lt;Input value="default value" />);
      ② const label = screen.getByDisplayValue("default value");
      ③ expect(label).toBeInTheDocument();
      ④ expect(container).toMatchSnapshot();
   })
})</pre></div></div><div class="postDetail_content__OTeO2">이 코드는 React 컴포넌트 &lt;Input />를 테스트하기 위해 작성된 Jest 테스트 파일이다. react-testing-library와 jest-styled-components를 사용하여 &lt;Input /> 컴포넌트의 렌더링 및 동작을 한다.</div><div class="postDetail_content__OTeO2">① render 함수는 &lt;Input /> 컴포넌트를 렌더링합니다. 여기서 value prop으로 "default value"를 설정합니다.</br>
② screen.getByDisplayValue 함수는 주어진 값("default value")을 표시하는 요소를 검색합니다.</br>
　여기서는 &lt;Input /> 컴포넌트가 "default value"라는 값을 가진 입력 필드를 렌더링하는지 확인합니다.</br>
③ expect 함수는 단언(assertion)을 정의합니다. 여기서는 label 요소가 문서 내에 존재하는지 확인합니다.
　toBeInTheDocument 매처는 요소가 실제로 DOM에 존재하는지 확인합니다.</div><div class="postDetail_content__OTeO2">Input 컴포넌트는 Button 컴포넌트와 다르게 필수 Props가 존재하지 않는다. 따라서 화면에 표시되었는지를 알기 위해 검색(Query)할 방법이 없다. </br>

그래서 Input 컴포넌트의 필수가 아닌 Props인 value값을 설정하고 react-testing-library의 screen.getByDisplayValue를 사용하여 input 컴포넌트를 찾는다.</div><h4 class="heading_h4__ZTbA0">📝 <!-- -->getByPlaceholderText를 이용하여 input을 찾아 렌더링 하는 예제</h4><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">it('renders placeholder correctly', ()=>{
    render(&lt;Input placeholder="default placeholder" />);

    const input = screen.getByPlaceholderText("default placeholder");
    expect(input).toBeInTheDocument();        
})</pre></div></div><h4 class="heading_h4__ZTbA0">📝 <!-- -->fireEvent를 이용하여 이벤트 테스트 하는 예제</h4><div class="LanguageConsole_console_container__AqYGR"><div class="LanguageConsole_console_header__inJS4"><span class="LanguageConsole_title__QSrQq" data-label-text="Javascript"><i class="fas fa-code fa-fw small LanguageConsole_ico_title__oetQW"></i></span><button class="LanguageConsole_copy__l7rff"><i class="far fa-clipboard LanguageConsole_ico_clipboard__tvVJz"></i></button></div><div class="LanguageConsole_console_content__O4Cw8"><pre class="LanguageConsole_console_code__9O_nt">import { render, screen, fireEvent } from 'testing-library/react';

it('renders placeholder correctly', ()=>{
    render(&lt;Input placeholder="default placeholder" />);
        
    const input = screen.getByPlaceholderText("default placeholder") as HTMLInputElement;
        
    fireEvent.change(input, {target:{ value:'study react'}})
    expect(input.value).toBe('study react')
})</pre></div></div><div class="postDetail_content__OTeO2">Input 컴포넌트의 placeholder를 사용하여 Input 컴포넌트를 화면에 표시하고 해당컴포넌트를 getByPlaceholderText를 통해 찾았다. 이렇게 찾은 컴포넌트는 기본적으로 HTMLElement타입이다. 하지만 HTML의 input 태그를 사용하고 있으므로, 타입스크립트의 as를 사용하여 HTMLInputElement로 타입변환을 해준다.</div><div class="postDetail_content__OTeO2">fireEvent의 change함수로 실제 사용자가 데이터를 입력하는 테스트 코드를 작성 해준다.
앞에서 찾은 Input 컴포넌트에 데이터를 입력해주고 입력된 데이터가 실제로 화면에 잘 표시 되고 있는지를 확인하기 위해 toBe를 사용하여 input, value값이 우리가 fireEvent를 사용하여 입력한 값과 같은지 확인 하였다.</div><div class="row"><nav class="postNavigation_post_navigation__Zbcpm"><a class="postNavigation_post_navgation_common__q8_Hl postNavigation_post_navigation_pre__SPHh_" aria-label="Older" href="/posts/15"><p class="postNavigation_post_navigation_text__3cjma">리액트(React) vs 뷰(Vue)</p></a><a class="postNavigation_post_navgation_common__q8_Hl postNavigation_post_navigation_next__yVEzg" aria-label="Newer" href="/posts/13"><p class="postNavigation_post_navigation_text__3cjma">리액트와 불변성</p></a></nav></div><div class="footer_footer_container__MsSvO"><footer class="footer_footer__AwYty"><p class="footer_copylight___J5l0">© 2024 <!-- -->베짱이가 되고싶은 개미。<!-- --> Some rights reserved.</p><p class="footer_theme__bwXbg">portfolio v1.0.0-alpha.3</p></footer></div></main><aside class="panel_panel_wrapper__bjPKT"><div class="panel_access__NiFhF"><section class="panel_access_lastmod__v6pgX"><h2 class="panel_panel_heading__n9W6w">Recently Updated</h2><ul class="panel_panel_recently__U0_Zp"><li class="panel_text_truncate__SFfHf"><a href="/posts/14">테스트 주도 개발(Test driven devlopment, TDD)</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/25">브라우저 렌더링 중 스크립트 태그를 만날 때 파싱이 중단되는 문제와 해결</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/24">Function.prototype.bind()</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/23">HTML(하이퍼텍스트 마크업 언어)에서 속성(Attribute)과 프로퍼티(Property)</a></li><li class="panel_text_truncate__SFfHf"><a href="/posts/22">화살표 함수와 일반함수의 차이점</a></li></ul></section><section class="panel_panel_tag_contain__h_Bwi"><h2 class="panel_panel_heading__n9W6w">Trending Tags</h2><div class="panel_panel_tag__eNz5c"><a class="panel_tag__3AiMO" href="/tags/테스트 주도 개발">테스트 주도 개발</a><a class="panel_tag__3AiMO" href="/tags/Javascript">Javascript</a><a class="panel_tag__3AiMO" href="/tags/콜백함수">콜백함수</a><a class="panel_tag__3AiMO" href="/tags/browser">browser</a><a class="panel_tag__3AiMO" href="/tags/HTTP-Protocol">HTTP-Protocol</a><a class="panel_tag__3AiMO" href="/tags/git">git</a><a class="panel_tag__3AiMO" href="/tags/React">React</a><a class="panel_tag__3AiMO" href="/tags/Vue">Vue</a><a class="panel_tag__3AiMO" href="/tags/JWT">JWT</a><a class="panel_tag__3AiMO" href="/tags/Token">Token</a></div></section></div></aside></div></div></div><script src="/_next/static/chunks/webpack-7cbbdf1c4fd681ae.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/b61b62d196836ce7.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/css/04d20c09b3119d43.css\",\"style\",{\"crossOrigin\":\"\"}]\n4:HL[\"/_next/static/css/4be7aaf21dbfc26e.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"5:I[7690,[],\"\"]\n7:I[5250,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"862\",\"static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-9eb9aaf2756d2762.js\"],\"\"]\n8:I[8843,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"862\",\"static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-9eb9aaf2756d2762.js\"],\"\"]\n9:I[688,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"862\",\"static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-9eb9aaf2756d2762.js"])</script><script>self.__next_f.push([1,"\"],\"\"]\na:I[777,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"862\",\"static/chunks/app/(layoutCase)/categories/%5Bcategoryname%5D/%5Bpostid%5D/page-9eb9aaf2756d2762.js\"],\"\"]\nb:I[5613,[],\"\"]\ne:I[1778,[],\"\"]\n12:I[5210,[\"250\",\"static/chunks/250-8b90be581650ff9d.js\",\"304\",\"static/chunks/304-f6bea3ededee4fbe.js\",\"730\",\"static/chunks/730-7ade87634bab4187.js\",\"566\",\"static/chunks/566-b141861ca793acbd.js\",\"35\",\"static/chunks/35-428bf187f02277f1.js\",\"338\",\"static/chunks/338-f2b637e42a7ca177.js\",\"464\",\"static/chunks/"])</script><script>self.__next_f.push([1,"app/(layoutCase)/layout-b528a91c526f504b.js\"],\"\"]\n19:I[8955,[],\"\"]\nc:[\"categoryname\",\"library\",\"d\"]\nd:[\"postid\",\"14\",\"d\"]\nf:\"$L10\"\n13:[]\n14:{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"}\n15:{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"l"])</script><script>self.__next_f.push([1,"ineHeight\":\"49px\"}\n16:{\"display\":\"inline-block\"}\n17:{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0}\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/b61b62d196836ce7.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"f20neTUnWIe7OHbcT20zs\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/categories/library/14\",\"initialTree\":[\"\",{\"children\":[\"(layoutCase)\",{\"children\":[\"categories\",{\"children\":[[\"categoryname\",\"library\",\"d\"],{\"children\":[[\"postid\",\"14\",\"d\"],{\"children\":[\"__PAGE__?{\\\"categoryname\\\":\\\"library\\\",\\\"postid\\\":\\\"14\\\"}\",{}]}]}]}],\"search\":[\"__DEFAULT__\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"(layoutCase)\",{\"children\":[\"categories\",{\"children\":[[\"categoryname\",\"library\",\"d\"],{\"children\":[[\"postid\",\"14\",\"d\"],{\"children\":[\"__PAGE__\",{},[\"$L6\",[[[\"$\",\"article\",null,{\"className\":\"$undefined\",\"children\":[\"$\",\"header\",null,{\"children\":[\"$\",\"h1\",null,{\"className\":\"postUserInfo_h1__uhAqy\",\"children\":\"테스트 주도 개발(Test driven devlopment, TDD)\"}]}]}],[\"$\",\"div\",null,{\"className\":\"postUserInfo_post_meta__ABvuC\",\"children\":[[\"$\",\"span\",null,{\"children\":[\"Posted\",\" \",[\"$\",\"time\",null,{\"className\":\"postUserInfo_time__2exyR\",\"children\":[\"13 days\",\" \"]}]]}],[\"$\",\"span\",null,{\"className\":\"postUserInfo_update__f345P\",\"children\":[\"Updated\",\" \",[\"$\",\"time\",null,{\"className\":\"postUserInfo_time__2exyR\",\"children\":\"13 days\"}]]}]]}],[\"$\",\"div\",null,{\"children\":[\"$\",\"span\",null,{\"className\":\"postUserInfo_post_meta__ABvuC\",\"children\":[\"By\",\" \",[\"$\",\"em\",null,{\"children\":[\"$\",\"$L7\",null,{\"href\":\"https://nam-yeun-hwa.github.io/\",\"className\":\"postUserInfo_author__fVGYM\",\"children\":\"베짱이가 되고싶은 개미。\"}]}]]}]}]],[[\"$\",\"div\",\"0\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"소프트웨어를 전문적으로 개발하는 기업들은 서비스의 안정적인 운영과 서비스의 품질을 확보하기 위해 테스트 코드를 작성하고 관리하고 있다. 다시 말하면 서비스의 품질을 확보하기 위해서는 테스트 코드 작성이 필수라는 것이다.\"}}],[\"$\",\"div\",\"1\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"테스트 주도 개발이라는 개념이 나오기 전에는 우리가 지금까지 해온 것과 같이 움직이는 소프트웨어를 개발한 후 해당 소프트 웨어에 대한 테스트 코드를 작성하는 방식을 사용해 왔다. 이 방식을 사용하면 다음과 같은 문제점들이 있다.\"}}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"다른 사람이 작성한 소스 코드 또는 내가 예전에 작성한 코드에 대해 테스트 코드를 작성해야 하는데 이 코드가 어떻게 동작하는지 알 수 없거나 기억할 수 없음으로 코드를 다시 분석하고 테스트 코드를 작성해야 한다.\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"        작성된 코드가 테스트하기 쉽게 작성되어 있지 않다. 따라서 테스트 코드를 작성하기가 불가능 하거나 테스트 코드를 작성하기 위해 이미 작성된 코드를 수정해야 할 경우가 발생한다. 이때 기존 코드의 수정으로 인해 예기치 않은 문제가 발생할 수 있다.\"}}]]}],[\"$\",\"div\",\"3\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"이런 문제를 해결하기 위해 켄트백(Kent Beck)은 테스트 코드를 먼저 작성하는 테스트 주도 개발론을 제안하게 되었다. 테스트 줃 개발 방벙론은 테스트 프레임워크 등을 사용하여 자동화된 테스트 시스템에서 미리 정의된 사양을 바탕으로\"}}],[false,false,[\"$\",\"blockquote\",null,{\"className\":\"Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_warning__ZYPQt\",\"children\":[\"$\",\"p\",null,{\"className\":\"Prompts_detail__nD6Io\",\"dangerouslySetInnerHTML\":{\"__html\":\"실패하는 테스트 명세를 작성하고 그 테스트 명세를 통과하기 위한 최소한의 코드를 작성한다. 마지막으로 해당 코드를 리팩토링 하는 것으로 개발을 마치는 프로세스이다.\"}}]}],false],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"children\":\"Jest 테스트 프레임워크로 테스트 코드 작성하기\"}],false,false],[\"$\",\"div\",\"6\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"Jest는 주로 JavaScript 및 TypeScript 애플리케이션을 테스트하기 위해 사용되는 JavaScript 테스팅 프레임워크로 특히 React 애플리케이션 테스트에 최적화되어 있다. 페이스북(현 메타)에서 개발했으며,  React 외에도 다른 JavaScript 프레임워크나 라이브러리와도 잘 작동한다.\"}}],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"children\":\"Jest의 주요 쿼리 함수\"}],false,false],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"describe 함수 \"}],false],[\"$\",\"div\",\"9\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"describe함수는 jest가 제공하는 함수로써 여러 테스트를 한 그룹으로 묶고 설명을 붙이기 위해 사용한다.\"}}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"첫번째 매개변수는 명령 프롬프트에 표시할 설명\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"        두번째 매개변수는 여러 테스트를 그룹으로 묶을 콜백 함수\"}}]]}],[\"$\",\"$L8\",\"11\",{\"code\":\"describe('test index.js file', () =\u003e {\\n\\n});\"}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"it 함수\"}],false],[\"$\",\"div\",\"13\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"it함수는 실제 테스트가 실행되는 테스트 명세를 작성할 때 사용한다.\"}}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"첫번째 매개변수는 테스트 명세의 설명\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"        두 번째 매개변수에는 실제로 테스트를 실행하는 테스트 코드를 작성\"}}]]}],[\"$\",\"$L8\",\"15\",{\"code\":\"it('sum 1+2 to equal 3', () =\u003e {\\n      \\n});\"}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"expect 함수\"}],false],[\"$\",\"div\",\"17\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"expect 함수는 주로 테스트 프레임워크에서 테스트 결과를 확인하기 위해 사용되는 메서드나 함수이다. expect 함수는 테스트 대상이 특정 조건을 만족하는지, 즉 예상된 동작을 수행하는지를 검증하는 역할이다.\"}}],[\"$\",\"$L8\",\"18\",{\"code\":\"it('sum 1+2 to equal 3', () =\u003e {\\n      expect(sum(1,2)).toBe(3);\\n});\"}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"여기서 sum(1,2)는 테스트 대상이 실제로 생성한 값이고, 3는 기대하는 값이며 toBe는 일치 여부를 확인하는 메서드이다.\"}}]]}],[\"$\",\"div\",\"20\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"expect는 단순한 값 비교 외에도 다양한 일치 조건을 제공한다. 예를 들어, 두 객체가 동일한지, 배열이 특정 요소를 포함하는지, 함수가 특정 예외를 던지는지 등을 확인할 수 있다.\"}}],[\"$\",\"$L8\",\"21\",{\"code\":\"// 객체나 배열의 동등성 비교\\nexpect(actualValue).toEqual(expectedValue); \\n\\n// 배열이 특정 아이템을 포함하는지\\nexpect(array).toContain(item); \\n\\n// 함수가 특정 오류를 던지는지\\nexpect(() =\u003e functionCall()).toThrow(ErrorType); \\n        \"}],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"children\":\"@testing-library로 리액트 컴포넌트 테스트 코드 작성 하기\"}],false,false],[\"$\",\"div\",\"23\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"@testing-library는 DOM 테스팅 라이브러리(DOM Testing Library)이다. @testing-library는 사용자 중심 방식으로 UI 컴포넌트를 테스트하는데 도움을 주는 라이브러리이며\\n        리액트 컴포넌트의 테스트 코드 작성을 도와준다. \u003c/br\u003e\u003c/br\u003e\\n        \\n        테스트 코드를 작성할 때 컴포넌트 세부 구현사항을 포함하지 않으면서도 신뢰할 수 있는 테스트 코드 작성에 도움을 준다. 이렇게 컴포넌트의 세부 구현 사항을 포함하지 않은 테스트 코드를 작성하면 컴포넌트의 세부 구현 부분을 리팩토링 하여도 테스트 코드를 수정할 필요가 없다, 이로 인해 한번 작성한 테스트 코드는 긴 시간 유지할 수 있으며 오랜 기간 유지 가능하여 테스트 코드를 자주 수정하지 않아도 되므로 개발 생산성을 향상 시켜 준다.\"}}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"App.js 컴포넌트 - 렌더링 테스트\"}],false],[\"$\",\"$L8\",\"25\",{\"code\":\"import { render, screen } from 'testing-library/react';\\nimport App from './App.js';\\n        \\ntest('renders learn react link', ()=\u003e{\\n  render(\u003cApp /\u003e);\\n  const linkElement = screen.getByText(/learn react/i);\\n  expect(linkElement).toBeInTheDocument();\\n})\"}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"test\"}],false],[\"$\",\"div\",\"27\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"test 함수(it 함수와 같은 역할을 하는 함수)를 사용하여 테스트 명세를 작성한 테스트 코드이다.\"}}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"render\"}],false],[\"$\",\"div\",\"29\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"리액트 컴포넌트를 화면에 표시하기 위함\"}}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"screen\"}],false],[\"$\",\"div\",\"31\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"리액트 컴포넌트가 표시된 화면을 의미한다.\"}}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"GetByText\"}],false],[\"$\",\"div\",\"33\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"getByText 함수는 주어진 텍스트를 포함하는 DOM 요소를 찾는 데 사용된다. 렌더링된 컴포넌트에서 screen.GetByText를 통해 화면에서 'learn react'라는 글자를 가지고 있는 돔 요소를 찾는다.\"}}],[\"$\",\"$L8\",\"34\",{\"code\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('renders Hello World text', () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const textElement = screen.getByText('Hello World');\\n  expect(textElement).toBeInTheDocument();\\n});\\n        \"}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"toBeInTheDocument\"}],false],[\"$\",\"div\",\"36\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"요소를 찾아 jest expect().toBeInTheDocument()를 사용하여 돔에 표시되어 있는지 확인 한다. \u003c/br\u003e\\n\\n        render 함수는 메모리상에 돔을 만들고 screen을 통해 해당 돔에 접근 하는 것을 의미한다.\\n        react-testing-library의 render 함수를 사용하여 App이라는 컴포넌트를 렌더링 하였다.\"}}],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"children\":\"React Testing Library의 주요 쿼리 함수\"}],false,false],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"getByText\"}],false],[\"$\",\"div\",\"39\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"주어진 텍스트를 포함하는 요소를 찾습니다.\u003c/br\u003e\\n        ex) screen.getByText(/learn react/i)는 대소문자를 구분하지 않고 \\\"learn react\\\"라는 텍스트를 포함하는 요소를 찾습니다.\"}}],[\"$\",\"$L8\",\"40\",{\"code\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('renders learn react link', () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const linkElement = screen.getByText(/learn react/i);\\n  expect(linkElement).toBeInTheDocument();\\n});\\n        \"}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"getByRole\"}],false],[\"$\",\"div\",\"42\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"특정 역할(예: 버튼, 링크)을 가진 요소를 찾습니다.\u003c/br\u003e\\n        screen.getByRole('button', { name: /submit/i })은 \\\"submit\\\" 텍스트를 가진 버튼을 찾습니다.\"}}],[\"$\",\"$L8\",\"43\",{\"code\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('renders submit button', () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const buttonElement = screen.getByRole('button', { name: /submit/i });\\n  expect(buttonElement).toBeInTheDocument();\\n});\\n        \"}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"getByLabelText\"}],false],[\"$\",\"div\",\"45\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"특정 라벨 텍스트와 연결된 요소(주로 폼 필드)를 찾습니다.\u003c/br\u003e\\n        screen.getByLabelText('Username')은 \\\"Username\\\" 라벨을 가진 입력 필드를 찾습니다.\"}}],[\"$\",\"$L8\",\"46\",{\"code\":\"import { render, screen } from '@testing-library/react';\\nimport LoginForm from './LoginForm';\\n        \\ntest('finds the username input', () =\u003e {\\n  render(\u003cLoginForm /\u003e);\\n  const inputElement = screen.getByLabelText('Username');\\n  expect(inputElement).toBeInTheDocument();\\n});\\n        \"}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"getByPlaceholderText\"}],false],[\"$\",\"div\",\"48\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"특정 플레이스홀더 텍스트를 가진 입력 요소를 찾습니다. \u003c/br\u003e\\n        screen.getByPlaceholderText('Enter your username')은 \\\"Enter your username\\\" 플레이스홀더를 가진 입력 필드를 찾습니다.\"}}],[\"$\",\"$L8\",\"49\",{\"code\":\"import { render, screen } from '@testing-library/react';\\nimport LoginForm from './LoginForm';\\n        \\ntest('finds the input by placeholder', () =\u003e {\\n  render(\u003cLoginForm /\u003e);\\n  const inputElement = screen.getByPlaceholderText('Enter your username');\\n  expect(inputElement).toBeInTheDocument();\\n});\\n        \"}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"getByAltText\"}],false],[\"$\",\"div\",\"51\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"주어진 alt 텍스트를 가진 이미지를 찾습니다.\u003c/br\u003e\\n        screen.getByAltText('Profile Picture')은 \\\"Profile Picture\\\" alt 텍스트를 가진 이미지를 찾습니다.\"}}],[\"$\",\"$L8\",\"52\",{\"code\":\"import { render, screen } from '@testing-library/react';\\nimport Profile from './Profile';\\n        \\ntest('finds the profile picture', () =\u003e {\\n  render(\u003cProfile /\u003e);\\n  const imageElement = screen.getByAltText('Profile Picture');\\n  expect(imageElement).toBeInTheDocument();\\n});\\n        \"}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"getByTestId\"}],false],[\"$\",\"div\",\"54\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"data-testid 속성을 사용하여 요소를 찾습니다. \u003c/br\u003e\\n        screen.getByTestId('custom-element')은 data-testid=\\\"custom-element\\\" 속성을 가진 요소를 찾습니다.\"}}],[\"$\",\"$L8\",\"55\",{\"code\":\"import { render, screen } from '@testing-library/react';\\nimport Component from './Component';\\n        \\ntest('finds element by test id', () =\u003e {\\n  render(\u003cComponent /\u003e);\\n  const element = screen.getByTestId('custom-element');\\n  expect(element).toBeInTheDocument();\\n});\\n        \"}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"queryByText\"}],false],[\"$\",\"div\",\"57\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"요소가 존재하지 않거나, 하나만 존재할 때 사용합니다. 존재하지 않으면 null을 반환합니다. \u003c/br\u003e\\n        getByText는 요소가 없으면 에러를 던집니다.\"}}],[\"$\",\"$L8\",\"58\",{\"code\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('does not find non-existing text', () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const textElement = screen.queryByText('Non-existing Text');\\n  expect(textElement).toBeNull();\\n});\\n        \"}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"findByText\"}],false],[\"$\",\"div\",\"60\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"비동기적으로 요소를 찾을 때 사용합니다. 주로 요소가 나중에 렌더링될 경우에 사용합니다. 반환 값은 Promise입니다.\"}}],[\"$\",\"$L8\",\"61\",{\"code\":\"import { render, screen } from '@testing-library/react';\\nimport App from './App';\\n        \\ntest('renders welcome message', async () =\u003e {\\n  render(\u003cApp /\u003e);\\n  const messageElement = await screen.findByText(/welcome/i);\\n  expect(messageElement).toBeInTheDocument();\\n});\\n        \"}],[false,[\"$\",\"h2\",null,{\"className\":\"heading_h2__fsXMw\",\"children\":\"참고할만한 예제들\"}],false,false],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"예제 [1] - 컴포넌트가 올바르게 렌더링되는지를 확인하는 테스트 케이스\"}],false],[\"$\",\"div\",\"64\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u0026lt;App /\u003e에 대한 Jest 테스트 스위트를 작성한 것으로 \u003cApp /\u003e 컴포넌트가 올바르게 렌더링되는지를 확인하는 하나의 테스트 케이스를 포함하고 있다.\"}}],[\"$\",\"$L9\",\"65\",{\"keyword\":\"render,getElementByClassName,toHaveLength,toHaveAttribute\"}],[\"$\",\"$L8\",\"66\",{\"code\":\"describe('\u0026lt;App /\u003e', ()=\u003e{\\nit('renders component correctly', ()=\u003e{      \\n      ① const { container } = render(\u003cApp /\u003e);              \\n      ② expect(container.getElementByClassName('App-logo')).toHaveLength(1);       \\n      ③ expect(container.getElementByClassName('App-logo')[0]).toHaveAttribute('src','logo.svg');\\n    })\\n})\"}],[\"$\",\"div\",\"67\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"① 이 줄은 \u0026lt;App /\u003e 컴포넌트를 렌더링한다. render 함수는 컴포넌트를 가상 DOM에 렌더링하고, 반환된 객체에서 container를 구조 분해 할당하여 가져오며 container는 렌더링된 DOM 트리를 포함한다.\\n        ② 이 줄은 container 안에 'App-logo' 클래스를 가진 요소가 하나 있는지 확인한다. expect 함수는 기대값을 설정하는 데 사용되고, toHaveLength(1)는 요소의 길이가 1인지 확인한다.\\n        ③ 이 줄은 'App-logo' 클래스를 가진 첫 번째 요소가 'src' 속성을 가지고 있으며, 그 값이 'logo.svg'인지 확인한다. toHaveAttribute('src', 'logo.svg')는 요소의 src 속성이 'logo.svg'인지를 확인한다.\"}}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"예제 [2] - \u003cimg /\u003e 테스트 코드\"}],false],[\"$\",\"$L9\",\"69\",{\"keyword\":\"render,getElementsByTagName,toHaveLength,toHaveTextContext\"}],[\"$\",\"$L8\",\"70\",{\"code\":\"describe('\u0026lt;App /\u003e', ()=\u003e{\\nit('renders component correctly', ()=\u003e{\\n      ①const { container } = render(\u003cApp /\u003e);  \\n      ② expect(container.getElementsByTagName('p')).toHaveLength(1);\\n      ③ expect(container.getElementsByTagName('p')[0]).toHaveTextContext('Edit src/App.js and save to reload.')\\n   })\\n})\"}],[\"$\",\"div\",\"71\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"① 이 줄은 \u0026lt;App /\u003e 컴포넌트를 렌더링한다. render 함수는 컴포넌트를 가상 DOM에 렌더링하고, 반환된 객체에서 container를 구조 분해 할당하여 가져오며 container는 렌더링된 DOM 트리를 포함한다.\\n        ② 이 줄은 container 안에 \u003cp\u003e 태그를 가진 요소가 하나 있는지 확인한다. expect 함수는 기대값을 설정하는 데 사용되고, toHaveLength(1)는 해당 요소의 길이가 1인지 확인한다.\\n        ③ 이 줄은 \u0026lt;p\u003e 태그를 가진 첫 번째 요소가 'Edit src/App.js and save to reload.'라는 텍스트 내용을 가지고 있는지 확인한다. expect 함수는 기대값을 설정하는 데 사용되고, toHaveTextContent('Edit src/App.js and save to reload.')는 해당 요소의 텍스트 내용이 정확히 일치하는지를 확인한다.\"}}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"예제 [3] - \u003cp/\u003e 테스트\"}],false],[\"$\",\"$L8\",\"73\",{\"code\":\"describe('\u0026lt;App /\u003e', ()=\u003e{\\n  it('renders component correctly', ()=\u003e{\\n      const { container } = render(\u003cApp /\u003e);    \\n      expect(container).toMatchSnapshot();\\n    })\\n})\"}],[\"$\",\"div\",\"74\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"toMatchSnapshot가 실행되면 src/snapshots/App.test.js.snap이라는 파일이 생성된 것을 확인 할 수 있다. 파일을 열어 내용을 확인해 보면 App 컴포넌트가 화면에 렌더링될 때 표시되는 HTML 내용이 저장된 것을 확인 할 수 있다.\u003c/br\u003e\\n        저장된 스냅샷은 App 컴포넌트가 수정되어 화면에 표시되는 HTML 구조가 변경되면 에러를 표시하게 된다. 이렇게 스냅샷은 화면에 표시되는 컴포넌트가 변경되었는지 감지하기 위한 테스트로 많이 사용된다.\"}}],[false,false,[\"$\",\"blockquote\",null,{\"className\":\"Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_warning__ZYPQt\",\"children\":[\"$\",\"p\",null,{\"className\":\"Prompts_detail__nD6Io\",\"dangerouslySetInnerHTML\":{\"__html\":\"만약 컴포넌트를 수정하여 화면 표시가 변경된 것이 의도된 수정이었다면 스냅샷 테스트로 저장된 파일을 업데이트해 주어야 한다. 명령프롬프트에 에러가 표시된 상태에서 키보드 'u'키를 누르면 스냅샷으로 생성된 파일이 업데이트 된다. 그러면 새롭게 업데이트된 스냅샷 파일이 다시 기준이 되어 변경을 감지하고 에러를 표시하게 된다.\"}}]}],false],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"예제 [4] - 스냅샷 (화면에 표시되는 내용이 변경 되었는지 체크)\"}],false],[\"$\",\"$L9\",\"77\",{\"keyword\":\"getByText,parentElement,toHaveStyleRule\"}],[\"$\",\"div\",\"78\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"Button 컴포넌트는 Props만을 가지는 단순 컴포넌트이다.\\n        Button 컴포넌트가 화면에 잘 표시 되는지, Props가 잘 적용되는지를 확인하도록 한다.\"}}],[\"$\",\"$L8\",\"79\",{\"code\":\"import React from 'react';\\nimport { render, screen } from 'testing-library/react';\\nimport 'jest-styled-components';\\nimport {Button} from './index';\\n\\ndescribe('\u0026lt;Button /\u003e', ()=\u003e{\\n  it('renders component correctly', ()=\u003e{\\n        ① const { container } = render(\u0026lt;Button label=\\\"Button Test\\\" /\u003e);\\n\\n        ② const label = screen.getByText(\\\"button Test\\\");\\n           expect(label).toBeInTheDocument();\\n\\n        ③ const parent = label.parentElement;\\n        ④ expect(parent).toHaveStyleRule('background-color', '#304FFE');\\n          expect(parent).toHaveStyleRule('background-color', '#1E40FF', { modifier:'hover'});\\n        \\n        ⑤ expect(container).toMatchSnapshot();\\n    })\\n})\"}],[\"$\",\"div\",\"80\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"\\n        ① render 함수는 \u0026lt;Button label=\\\"Button Test\\\" /\u003e를 가상 DOM에 렌더링하고, 반환된 객체에서 container를 구조 분해 할당한다. \u003c/br\u003e\u003c/br\u003e\\n② screen.getByText를 사용하여 \\\"Button Test\\\"라는 텍스트를 가진 요소를 찾는다. \\nexpect로 해당 요소가 문서에 존재하는지 확인한다.\u003c/br\u003e\u003c/br\u003e\\n③ label 요소의 부모 요소(parentElement)를 가져온다.\u003c/br\u003e\u003c/br\u003e\\n\\n④ expect를 사용하여 부모 요소가 특정 스타일 규칙을 가지고 있는지 확인한다. jest-styled-components의 toHaveStyleRule을 사용하여 다음 두 가지 스타일 규칙을 확인한다.\u003c/br\u003e\"}}],[\"$\",\"ul\",null,{\"className\":\"liststyle_ul__uFdBS\",\"children\":[[\"$\",\"li\",\"0\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"기본 배경색이 #304FFE인지\"}}],[\"$\",\"li\",\"1\",{\"className\":\"liststyle_dot__SMzS4\",\"dangerouslySetInnerHTML\":{\"__html\":\"        hover 상태에서 배경색이 #1E40FF인지\"}}]]}],[\"$\",\"div\",\"82\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"backgroundColor과 hoverColor은 우리가 screen.getByText로 찾은 Label 컴포넌트가 아닌 Label 컴포넌트의 부모 요소인 Container 컴포넌트에 설정이 된다. 따라서 label.parentElement를 사용해 Label 컴포넌트의 부모 요소(Container 컴포넌트)에 접근하여 값이 잘 설정 되었는지 확인 한다.\u003c/br\u003e\u003c/br\u003e\\n\\n        Button 컴포넌트는 Props로 BackgroundClolor과 hoverColor이 설정되어 있지 않으면 기본값이 설정되도록 개발 되었다. backgroundColor과 hoverColor가 설정되어 있지 않은 상황에서 기본값이 잘 설정되는지 확인하기 위해 jest-styled-components의 새로운 Matcher인 toHaveStyleRule를 사용하여 확인 하도록 한다.\"}}],[\"$\",\"div\",\"83\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"⑤ 마지막으로, container의 현재 상태를 스냅샷으로 저장하여 이후 테스트 실행 시 컴포넌트의 출력이 변하지 않았는지 확인합니다.\"}}],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"예제 [4] - onClick 함수 테스트\"}],false],[\"$\",\"div\",\"85\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"Button 컴포넌트의 onClick 함수를 테스트 하기 위한 테스트 명세이다.\"}}],[\"$\",\"$L8\",\"86\",{\"code\":\"it('clicks the button', () =\u003e {\\n    ① const handlerClick = jest.fn(); \\n    ② render(\u0026lt;Button label=\\\"Button Test\\\" onClick={handlerClick} /\u003e); \\n    ③ const label = screen.getByText('Button Test'); \\n    ④ expect(handleClick).toHaveBeenCalledTimes(0); \\n    ⑤ fireEvent.click(label); \\n    ⑥ expect(handlerClick).toHaveBeenCalledTimes(1); \\n});\"}],[\"$\",\"div\",\"87\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"\\n        ① 클릭 핸들러 함수로 jest.fn()을 사용하여 mock 함수 생성 \u003c/br\u003e\\n        ② Button 컴포넌트를 렌더링하고, onClick props에 mock 함수 전달\u003c/br\u003e\\n        ③ 화면에서 \\\"Button Test\\\" 라는 텍스트를 가진 요소를 찾음\u003c/br\u003e\\n        ④ 클릭 이벤트가 발생하지 않았는지 확인\u003c/br\u003e\\n        ⑤ 찾은 요소에 클릭 이벤트를 발생시킴\u003c/br\u003e\\n        ⑥ 클릭 이벤트 핸들러가 한 번 호출되었는지 확인\u003c/br\u003e\\n        \"}}],[\"$\",\"div\",\"88\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"그다음 화면에 표시된 버튼 컴포넌트를 찾아서 아직 해당 컴포넌트를 클릭하지 않았음을 확인하기 위해 toHaveBeenCalledTimes 함수를 사용하여 우리가 만든 모의함수가 잘 호출되었는지 확인해준다.\"}}],[false,false,[\"$\",\"blockquote\",null,{\"className\":\"Prompts_prompt_container__In47e Prompts_prompt__caN6p Prompts_prompt_warning__ZYPQt\",\"children\":[\"$\",\"p\",null,{\"className\":\"Prompts_detail__nD6Io\",\"dangerouslySetInnerHTML\":{\"__html\":\"\u003cb\u003e모의 함수(Mocking functions)\u003c/b\u003e\u003c/br\u003e\\n        onClick 이벤트에는 사실 어떤 함수가 연결될지 알 수가 없다. jest에서는 이처럼 어떤 이벤트를 통해 함수가 호출되는지를 확인하기 위해 모의 함수(Mocking functions)를 사용한다. 모의 함수를 사용하여 onClick 이벤트를 테스트 한다.\u003c/br\u003e\u003c/br\u003e\\n\\njest의 모의함수(jest.fn)을 사용하여 handlerClick 변수를 선언하고 Button 컴포넌트의 Props로 onClick을 통해 전달 해준다.\\n        \"}}]}],false],[false,false,[\"$\",\"h3\",null,{\"className\":\"$undefined\",\"children\":\"예제 [5] - \u003cInput /\u003e 입력된 값이 일치 체크\"}],false],[\"$\",\"$L9\",\"91\",{\"keyword\":\"getByDisplayValue,getByPlaceholderText,fireEvent,fireEvent.change\"}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"children\":[\"📝 \",\"getByDisplayValue를 이용하여 input을 찾아 렌더링 하는 예제\"]}]],[\"$\",\"$L8\",\"93\",{\"code\":\"import React from 'react';\\nimport { render, screen, fireEvent } from 'testing-library/react';\\nimport 'jest-styled-components';\\nimport {Input} from './index';\\n\\ndescribe('\u0026lt;Input /\u003e', ()=\u003e{\\n\\tit('renders component correctly', ()=\u003e{\\n      ① const { container } = render(\u0026lt;Input value=\\\"default value\\\" /\u003e);\\n      ② const label = screen.getByDisplayValue(\\\"default value\\\");\\n      ③ expect(label).toBeInTheDocument();\\n      ④ expect(container).toMatchSnapshot();\\n   })\\n})\"}],[\"$\",\"div\",\"94\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"이 코드는 React 컴포넌트 \u0026lt;Input /\u003e를 테스트하기 위해 작성된 Jest 테스트 파일이다. react-testing-library와 jest-styled-components를 사용하여 \u0026lt;Input /\u003e 컴포넌트의 렌더링 및 동작을 한다.\"}}],[\"$\",\"div\",\"95\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"① render 함수는 \u0026lt;Input /\u003e 컴포넌트를 렌더링합니다. 여기서 value prop으로 \\\"default value\\\"를 설정합니다.\u003c/br\u003e\\n② screen.getByDisplayValue 함수는 주어진 값(\\\"default value\\\")을 표시하는 요소를 검색합니다.\u003c/br\u003e\\n　여기서는 \u0026lt;Input /\u003e 컴포넌트가 \\\"default value\\\"라는 값을 가진 입력 필드를 렌더링하는지 확인합니다.\u003c/br\u003e\\n③ expect 함수는 단언(assertion)을 정의합니다. 여기서는 label 요소가 문서 내에 존재하는지 확인합니다.\\n　toBeInTheDocument 매처는 요소가 실제로 DOM에 존재하는지 확인합니다.\"}}],[\"$\",\"div\",\"96\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"Input 컴포넌트는 Button 컴포넌트와 다르게 필수 Props가 존재하지 않는다. 따라서 화면에 표시되었는지를 알기 위해 검색(Query)할 방법이 없다. \u003c/br\u003e\\n\\n그래서 Input 컴포넌트의 필수가 아닌 Props인 value값을 설정하고 react-testing-library의 screen.getByDisplayValue를 사용하여 input 컴포넌트를 찾는다.\"}}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"children\":[\"📝 \",\"getByPlaceholderText를 이용하여 input을 찾아 렌더링 하는 예제\"]}]],[\"$\",\"$L8\",\"98\",{\"code\":\"it('renders placeholder correctly', ()=\u003e{\\n    render(\u0026lt;Input placeholder=\\\"default placeholder\\\" /\u003e);\\n\\n    const input = screen.getByPlaceholderText(\\\"default placeholder\\\");\\n    expect(input).toBeInTheDocument();        \\n})\"}],[false,false,false,[\"$\",\"h4\",null,{\"className\":\"heading_h4__ZTbA0\",\"children\":[\"📝 \",\"fireEvent를 이용하여 이벤트 테스트 하는 예제\"]}]],[\"$\",\"$L8\",\"100\",{\"code\":\"import { render, screen, fireEvent } from 'testing-library/react';\\n\\nit('renders placeholder correctly', ()=\u003e{\\n    render(\u0026lt;Input placeholder=\\\"default placeholder\\\" /\u003e);\\n        \\n    const input = screen.getByPlaceholderText(\\\"default placeholder\\\") as HTMLInputElement;\\n        \\n    fireEvent.change(input, {target:{ value:'study react'}})\\n    expect(input.value).toBe('study react')\\n})\"}],[\"$\",\"div\",\"101\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"Input 컴포넌트의 placeholder를 사용하여 Input 컴포넌트를 화면에 표시하고 해당컴포넌트를 getByPlaceholderText를 통해 찾았다. 이렇게 찾은 컴포넌트는 기본적으로 HTMLElement타입이다. 하지만 HTML의 input 태그를 사용하고 있으므로, 타입스크립트의 as를 사용하여 HTMLInputElement로 타입변환을 해준다.\"}}],[\"$\",\"div\",\"102\",{\"className\":\"postDetail_content__OTeO2\",\"dangerouslySetInnerHTML\":{\"__html\":\"fireEvent의 change함수로 실제 사용자가 데이터를 입력하는 테스트 코드를 작성 해준다.\\n앞에서 찾은 Input 컴포넌트에 데이터를 입력해주고 입력된 데이터가 실제로 화면에 잘 표시 되고 있는지를 확인하기 위해 toBe를 사용하여 input, value값이 우리가 fireEvent를 사용하여 입력한 값과 같은지 확인 하였다.\"}}]],[\"$\",\"$La\",null,{\"postid\":14,\"prePostTitle\":{\"id\":15,\"title\":\"리액트(React) vs 뷰(Vue)\",\"date\":\"2022-08-15 22:11:33\",\"folder\":\"React\",\"tag\":[\"React\",\"Vue\"],\"preview\":\"react는 UI 라이브러리이며 JSX(Javascript XML)형태로 코드를 작성하여 Javascript 문법을 응용하기 때문에 Javascript만으로 UI로직과 DOM을 구현한다. Vue는 제공되는 html 기반의 템플릿이 있어 쉽고 빠르게 제작이 가능하여 진입장벽이 낮으며 개발자간 코드 통일성이 있으며 소규모 프로젝트에 용이하다.\",\"post\":[{\"type\":\"normal\",\"value\":\"\\n        리액트(React)와 뷰(Vue.js)는 모두 현대적인 프론트엔드 JavaScript 라이브러리 및 프레임워크로, 웹 애플리케이션의 사용자 인터페이스(UI)를 개발하기 위해 사용된다. 이 두 기술의 각각 고유한 특징과 장단점에 대해 이야기 해보고자 한다. \u003c/br\u003e\u003c/br\u003e\\n\\n        react는 UI 라이브러리이며 JSX(Javascript XML)형태로 코드를 작성하여 UI로직과 DOM을 구현한다. 자바스크립트를 사용하기 때문에 자바스크립트 문법에 능숙해야 하며 커스터마이징 및 자유도가 높은편이다. 또한 커뮤니티 형성이 잘 되어있고 큰 프로젝트에 용이하다.\u003c/br\u003e\u003c/br\u003e\\n\\n        Vue는 제공되는 html 기반의 템플릿이 있어 쉽고 빠르게 제작이 가능하여 진입장벽이 낮고 개발\\n        자간 코드 통일성이 있으며 소규모 프로젝트에 용이하다.\u003c/br\u003e\u003c/br\u003e\"},{\"type\":\"table\",\"value\":\"\\n      \u003ctable\u003e\\n        \u003cthead\u003e\\n          \u003ctr\u003e\\n            \u003cth\u003e\u003c/th\u003e\\n            \u003cth\u003e데이터 바인딩\u003c/th\u003e\\n            \u003cth\u003e코딩 문법\u003c/th\u003e\\n            \u003cth\u003eUI 구성 아키텍쳐\u003c/th\u003e\\n            \u003cth\u003e공통\u003c/th\u003e\\n          \u003c/tr\u003e\\n        \u003c/thead\u003e\\n        \u003ctbody\u003e\\n          \u003ctr\u003e\\n            \u003ctd\u003e리액트\u003c/td\u003e\\n            \u003ctd\u003e단방향 데이터바인딩\u003c/td\u003e\\n            \u003ctd\u003eUI 라이브러리로 JSX(Javascript XML)문법을 사용\u003c/br\u003e 자바스크립트를 사용하기 때문에 커스터 마이징 및 자유도가 높은 편\u003c/td\u003e\\n            \u003ctd\u003e컴포넌트 기반 아키텍처를 사용하여 UI를 구성\u003c/td\u003e\\n            \u003ctd\u003e가상돔 사용\u003c/td\u003e\\n          \u003c/tr\u003e\\n          \u003ctr\u003e\\n            \u003ctd\u003e뷰\u003c/td\u003e\\n            \u003ctd\u003e양방향 데이터바인딩\u003c/td\u003e\\n            \u003ctd\u003e프레임워크가 지원해주는 문법에 따라 작성하기 때문에 개발자간 코드 통일성이 있다.\u003c/td\u003e\\n            \u003ctd\u003eHTML 기반의 템플릿 문법을 사용하여 UI를 정의\u003c/td\u003e\\n            \u003ctd\u003e가상돔 사용\u003c/td\u003e\\n          \u003c/tr\u003e\\n        \u003c/tbody\u003e\\n      \u003c/table\u003e\\n      \"},{\"type\":\"h2\",\"value\":\"단방향 데이터 바인딩(React)\"},{\"type\":\"normal\",\"value\":\"리액트는 단방향 데이터 바인딩을 사용한다. 리액트는 데이터의 흐름이 상위 컴포넌트에서 하위 컴포넌트로 한 방향으로만 흐르기 때문에 데이터의 변화를 추적하기가 쉽고, 디버깅이 용이하다. 또한, 리액트는 Virtual DOM을 활용하여 성능을 향상시키고, 변경된 부분만을 업데이트하여 성능 저하를 최소화한다. 하지만 화면을 업데이트하기 위해 변화를 감지하고 화면을 업데이트하는 관련 코드를 매번 작성해야 하는 불편함이 있다.\u003c/br\u003e\u003c/br\u003e\\n        리액트에서 상태(State)와 생명주기(Lifecycle) 관리를 위해 사용되는 메서드들이 호출되어야 한다는 의미이다. 예를 들어, 상태가 변경될 때마다 setState 메서드를 호출하여 컴포넌트를 다시 렌더링하거나, 생명주기 메서드 중에서 변화가 감지되는 경우에 관련 코드를 작성해주어야 한다. 이러한 작업은 번거로울 수 있지만, 리액트의 성능 최적화를 위해서는 필수적이다.\"},{\"type\":\"emphasis\",\"value\":\"\u003cb\u003e리액트 장단점\u003c/b\u003e\u003c/br\u003e\\n        - 데이터 변화에 따른 성능 저하 없이 DOM 객체 갱신 가능\u003c/br\u003e\\n        - 데이터 흐름이 단방향(부모-\u003e하위 컴포넌트)이라, 코드를 이해하기 쉽고 데이터 추적과 디버깅이 쉽다.\u003c/br\u003e\\n        - 커뮤니티와 생태계가 크고 활발하여 문제 해결 및 지원이 용이하다.\u003c/br\u003e\\n        - 변화를 감지하고 화면을 업데이트 하는 코드를 매번 작성해 줘야 하는 번거로움이 있다.\"},{\"type\":\"h2\",\"value\":\"양방향 데이터 바인딩(Vue)\"},{\"type\":\"normal\",\"value\":\"뷰는 양방향 데이터 바인딩을 지원한다. 이는 프레임워크가 데이터의 변경을 감지하고 자동으로 DOM 객체에 렌더링하여 사용자 인터페이스를 업데이트 한다. 이러한 방식은 사용자가 입력한 값이나 데이터가 변경될 때마다 화면이 즉시 반영되므로 개발자가 따로 체크하거나 업데이트 코드를 작성할 필요가 없어 편리하다. 그러나 데이터가 많거나 복잡한 애플리케이션의 경우 성능 저하를 초래할 수 있다. \\n      \"},{\"type\":\"emphasis\",\"value\":\"\\n        \u003cb\u003e장단점\u003c/b\u003e\u003c/br\u003e\\n        - 진입 장벽이 낮고, 간단한 프로젝트부터 복잡한 애플리케이션까지 다양한 범위의 프로젝트에 적합하다.\u003c/br\u003e\\n        - 데이터의 변화에 따라 DOM 객체 전체를 렌더링해주거나 데이터를 바꿔주므로, 성능이 감소되는 경우가 있다.\\n        \"},{\"type\":\"h2\",\"value\":\"가상돔(Virtual DOM)\"},{\"type\":\"normal\",\"value\":\"실제 돔에는 브라우저가 화면을 그리는데 필요한 모든 정보가 들어 있어 실제 돔을 조작하는 작업은 무겁기 때문에 가상돔을 만들어 메모리에 저장하고 이전 가상돔에 있던 내용과 현재 가상 돔을 비교하여 바뀐 부분만 실제 돔에 적용한다.\\n      \"}]},\"nextPostTile\":{\"id\":13,\"title\":\"리액트와 불변성\",\"date\":\"2024-01-15 22:11:33\",\"folder\":\"React\",\"tag\":[\"React\"],\"preview\":\"React의 문서를 읽다 보면 불변성을 강조하는 부분 또는 State를 직접적으로 변경하지 말라는 말을 본 적이 있을 것이다. 왜 그런 걸까? 리액트에서 상태를 다룰 때는 객체가 지닌 값을 바꾸고 싶다고 해서 값을 직접 수정하면 안된다.\",\"post\":[{\"type\":\"h2\",\"value\":\"리액트에서 불변성을 지켜야 하는 이유는?\"},{\"type\":\"normal\",\"value\":\"React의 문서를 읽다 보면 불변성을 강조하는 부분 또는 State를 직접적으로 변경하지 말라는 말을 본 적이 있을 것이다. 왜 그런 걸까?\u003c/br\u003e\u003c/br\u003e\\n        리액트에서 상태를 다룰 때는 객체가 지닌 값을 바꾸고 싶다고 해서 값을 직접 수정하면 안된다. 아래처럼 기존 객체는 그대로 두고, 새로운 객체를 만들어 원하는 값을 덮어씌워야 한다.\"},{\"type\":\"code\",\"value\":\"const info={\\nid:1,\\n  name:'John'\\n}\\n      \\nconst nextInfo={\\n  ...info,\\n  name: 'Jane'\\n}\"},{\"type\":\"normal\",\"value\":\"리액트는 컴포넌트에 변화가 필요한지 필요하지 않은지 Props의 변화 통해 알 수 있는데 컴포넌트의 렌더링 성능을 최적화 하기 위해서는 이전에 컴포넌트가 들고 있던 Props와 새로 받아올 Props를 비교하는 과정이 필요하며 불변성을 유지시켜 주어야 한다.\"},{\"type\":\"h4\",\"value\":\"불변성이 유지되지 않은 같은 참조를 가리키고 있는 데이터\"},{\"type\":\"code\",\"value\":\"const data = { id:1, text:'안녕하세요'};\\n    \\nconst sameData = data;\\nsameData.text = '안녕하세요';\\n      \\nconsole.log(sameData === data); // true\"},{\"type\":\"normal\",\"value\":\"sameData에 기존의 data를 대입하고 text 값을 수정 했다. 비록 새로운 이름을 선언 하긴 했지만 sameData와 data는 똑같은 객체를 가리키고 있다.\u003c/br\u003e\u003c/br\u003e\\n        따라서 sameData.text 값을 바꾸면 당연히 data.text 값 또한 바뀌게 된다. sameData와 data는 완전히 일치하는 객채이기 때문에 이를 비교하면 결과는 true 이다.\"},{\"type\":\"emphasis\",\"value\":\"객체의 특정 프로퍼티만 변경하는 작업을 수행하면 리액트에서는 변경이 일어나지 않았다고 인식하여 리렌더링이 일어나지 않는다. \u003cb\u003e불변성을 지켜주면서 값을 전달해 주어야 한다.\u003c/b\u003e\"},{\"type\":\"h2\",\"value\":\"불변성을 유지하면서 상태를 업데이트하는 방법\"},{\"type\":\"code\",\"value\":\"const data = { id:1, text:'안녕하세요'};\\nconst nextData = { ...data, text: '사요나라'};\\n      \\nconsole.log(nextData === data) // false\"},{\"type\":\"normal\",\"value\":\"위 코드는 data 변수를 참조가 끊어진 새로운 값으로 생성 한다. 이번에 선언한 nextData는 완전히 새로운 객체 이다.\u003c/br\u003e\u003c/br\u003e\\n        리액트는 상태가 변경되었는지 여부를 판단할 때 이전 상태와 현재 상태를 비교하여 기본적으로 부모로 부터 내려받는 Props나 내부 상태인 State가 변경되었을 때 컴포넌트를 다시 렌더링 하는 리렌더링 과정이 일어난다.\u003cbr/\u003e\\n        \"},{\"type\":\"emphasis\",\"value\":\"React는 \u003cb\u003eProps\u003c/b\u003e와 \u003cb\u003eState\u003c/b\u003e의 변경을 불변성을 이용해서 감지한다.\"},{\"type\":\"normal\",\"value\":\"객체의 참조를 복사한다는 점을 이용해 단순히 참조만 비교하는 얕은 비교를 이용해서 변경이 일어났는지 확인한다.\u003c/br\u003e\u003c/br\u003e\\n        자바스크립트에서 참조 타입의 데이터인 경우 메모리 힙 영역에 저장이 되어 내부 프로퍼티를 변경해도 같은 참조를 갖고 있다.\u003c/br\u003e\u003c/br\u003e\\n        따라서 객체의 특정 프로퍼티만 변경하는 작업을 수행하면 리액트에서는 변경이 일어나지 않았다고 인식하여 리렌더링이 일어나지 않는다. 따라서 리렌더링을 일으키려면 리액트에 이전의 참조와 다른 참조로 변경되었음을 알려야 한다.\u003c/br\u003e\u003c/br\u003e\\n        상태가 변경되었는지를 정확하게 판단하기 위해서는 불변성을 유지해야 하며 불변성을 유지하지 않으면 리액트가 제대로 동작하지 않고 성능 최적화가 무력화될 수 있다.\u003c/br\u003e\\n        \"}]},\"segment\":\"posts\"}],[\"$\",\"div\",null,{\"className\":\"footer_footer_container__MsSvO\",\"children\":[\"$\",\"footer\",null,{\"className\":\"footer_footer__AwYty\",\"children\":[[\"$\",\"p\",null,{\"className\":\"footer_copylight___J5l0\",\"children\":[\"© 2024 \",\"베짱이가 되고싶은 개미。\",\" Some rights reserved.\"]}],[\"$\",\"p\",null,{\"className\":\"footer_theme__bwXbg\",\"children\":\"portfolio v1.0.0-alpha.3\"}]]}]}]],null]]},[\"$\",\"$Lb\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"categories\",\"children\",\"$c\",\"children\",\"$d\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Le\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/4be7aaf21dbfc26e.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]]},[\"$\",\"$Lb\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"categories\",\"children\",\"$c\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Le\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[\"$\",\"$Lb\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\",\"categories\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Le\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]],\"search\":[\"__DEFAULT__\",{},[\"$f\",\"$L11\",null]]},[null,[\"$\",\"$L12\",null,{\"children\":[\"$\",\"$Lb\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Le\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}],\"search\":[\"$\",\"$Lb\",null,{\"parallelRouterKey\":\"search\",\"segmentPath\":[\"children\",\"(layoutCase)\",\"search\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Le\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$13\",\"styles\":null}],\"params\":{}}],null]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"className\":\"\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css\",\"as\":\"style\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.googleapis.com\"}],[\"$\",\"link\",null,{\"rel\":\"preconnect\",\"href\":\"https://fonts.gstatic.com\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR\u0026display=swap\",\"as\":\"style\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"$Lb\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Le\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":\"$14\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":\"$15\",\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":\"$16\",\"children\":[\"$\",\"h2\",null,{\"style\":\"$17\",\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/04d20c09b3119d43.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]}]]}],null]],\"initialHead\":[false,\"$L18\"],\"globalErrorComponent\":\"$19\"}]]\n"])</script><script>self.__next_f.push([1,"11:E{\"digest\":\"NEXT_NOT_FOUND\"}\n"])</script><script>self.__next_f.push([1,"18:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"be come 💡\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"App for an Ant Who Wants to Become a Bejjangyi\"}]]\n6:null\n10:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>